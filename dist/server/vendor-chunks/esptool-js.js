"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/esptool-js";
exports.ids = ["vendor-chunks/esptool-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/esptool-js/lib/esploader.js":
/*!**************************************************!*\
  !*** ./node_modules/esptool-js/lib/esploader.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESPLoader: () => (/* binding */ ESPLoader)\n/* harmony export */ });\n/* harmony import */ var _types_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/error.js */ \"(ssr)/./node_modules/esptool-js/lib/types/error.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _webserial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webserial.js */ \"(ssr)/./node_modules/esptool-js/lib/webserial.js\");\n/* harmony import */ var _reset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reset.js */ \"(ssr)/./node_modules/esptool-js/lib/reset.js\");\n/* harmony import */ var _stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stubFlasher.js */ \"(ssr)/./node_modules/esptool-js/lib/stubFlasher.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/esptool-js/lib/util.js\");\n\n\n\n\n\n\n/**\n * Return the chip ROM based on the given magic number\n * @param {number} magic - magic hex number to select ROM.\n * @returns {ROM} The chip ROM class related to given magic hex number.\n */\nasync function magic2Chip(magic) {\n    switch (magic) {\n        case 0x00f01d83: {\n            const { ESP32ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32.js\"));\n            return new ESP32ROM();\n        }\n        case 0xc21e06f:\n        case 0x6f51306f:\n        case 0x7c41a06f: {\n            const { ESP32C2ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32c2.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c2.js\"));\n            return new ESP32C2ROM();\n        }\n        case 0x6921506f:\n        case 0x1b31506f:\n        case 0x4881606f:\n        case 0x4361606f: {\n            const { ESP32C3ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32c3.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c3.js\"));\n            return new ESP32C3ROM();\n        }\n        case 0x2ce0806f: {\n            const { ESP32C6ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32c6.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c6.js\"));\n            return new ESP32C6ROM();\n        }\n        case 0x2421606f:\n        case 0x33f0206f:\n        case 0x4f81606f: {\n            const { ESP32C61ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32c61.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c61.js\"));\n            return new ESP32C61ROM();\n        }\n        case 0x1101406f:\n        case 0x63e1406f:\n        case 0x5fd1406f: {\n            const { ESP32C5ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32c5.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c5.js\"));\n            return new ESP32C5ROM();\n        }\n        case 0xd7b73e80:\n        case 0x97e30068: {\n            const { ESP32H2ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32h2.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32h2.js\"));\n            return new ESP32H2ROM();\n        }\n        case 0x09: {\n            const { ESP32S3ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32s3.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32s3.js\"));\n            return new ESP32S3ROM();\n        }\n        case 0x000007c6: {\n            const { ESP32S2ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32s2.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32s2.js\"));\n            return new ESP32S2ROM();\n        }\n        case 0xfff0c101: {\n            const { ESP8266ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp8266.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp8266.js\"));\n            return new ESP8266ROM();\n        }\n        case 0x0:\n        case 0x0addbad0:\n        case 0x7039ad9: {\n            const { ESP32P4ROM } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.bind(__webpack_require__, /*! ./targets/esp32p4.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32p4.js\"));\n            return new ESP32P4ROM();\n        }\n        default:\n            return null;\n    }\n}\nclass ESPLoader {\n    /**\n     * Create a new ESPLoader to perform serial communication\n     * such as read/write flash memory and registers using a LoaderOptions object.\n     * @param {LoaderOptions} options - LoaderOptions object argument for ESPLoader.\n     * ```\n     * const myLoader = new ESPLoader({ transport: Transport, baudrate: number, terminal?: IEspLoaderTerminal });\n     * ```\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.ESP_RAM_BLOCK = 0x1800;\n        this.ESP_FLASH_BEGIN = 0x02;\n        this.ESP_FLASH_DATA = 0x03;\n        this.ESP_FLASH_END = 0x04;\n        this.ESP_MEM_BEGIN = 0x05;\n        this.ESP_MEM_END = 0x06;\n        this.ESP_MEM_DATA = 0x07;\n        this.ESP_WRITE_REG = 0x09;\n        this.ESP_READ_REG = 0x0a;\n        this.ESP_SPI_ATTACH = 0x0d;\n        this.ESP_CHANGE_BAUDRATE = 0x0f;\n        this.ESP_FLASH_DEFL_BEGIN = 0x10;\n        this.ESP_FLASH_DEFL_DATA = 0x11;\n        this.ESP_FLASH_DEFL_END = 0x12;\n        this.ESP_SPI_FLASH_MD5 = 0x13;\n        // Only Stub supported commands\n        this.ESP_ERASE_FLASH = 0xd0;\n        this.ESP_ERASE_REGION = 0xd1;\n        this.ESP_READ_FLASH = 0xd2;\n        this.ESP_RUN_USER_CODE = 0xd3;\n        this.ESP_IMAGE_MAGIC = 0xe9;\n        this.ESP_CHECKSUM_MAGIC = 0xef;\n        // Response code(s) sent by ROM\n        this.ROM_INVALID_RECV_MSG = 0x05; // response if an invalid message is received\n        this.DEFAULT_TIMEOUT = 3000;\n        this.ERASE_REGION_TIMEOUT_PER_MB = 30000;\n        this.ERASE_WRITE_TIMEOUT_PER_MB = 40000;\n        this.MD5_TIMEOUT_PER_MB = 8000;\n        this.CHIP_ERASE_TIMEOUT = 120000;\n        this.FLASH_READ_TIMEOUT = 100000;\n        this.MAX_TIMEOUT = this.CHIP_ERASE_TIMEOUT * 2;\n        this.CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000;\n        this.DETECTED_FLASH_SIZES = {\n            0x12: \"256KB\",\n            0x13: \"512KB\",\n            0x14: \"1MB\",\n            0x15: \"2MB\",\n            0x16: \"4MB\",\n            0x17: \"8MB\",\n            0x18: \"16MB\",\n        };\n        this.DETECTED_FLASH_SIZES_NUM = {\n            0x12: 256,\n            0x13: 512,\n            0x14: 1024,\n            0x15: 2048,\n            0x16: 4096,\n            0x17: 8192,\n            0x18: 16384,\n        };\n        this.USB_JTAG_SERIAL_PID = 0x1001;\n        this.romBaudrate = 115200;\n        this.debugLogging = false;\n        this.syncStubDetected = false;\n        /**\n         * Get flash size bytes from flash size string.\n         * @param {string} flashSize Flash Size string\n         * @returns {number} Flash size bytes\n         */\n        this.flashSizeBytes = function (flashSize) {\n            let flashSizeB = -1;\n            if (flashSize.indexOf(\"KB\") !== -1) {\n                flashSizeB = parseInt(flashSize.slice(0, flashSize.indexOf(\"KB\"))) * 1024;\n            }\n            else if (flashSize.indexOf(\"MB\") !== -1) {\n                flashSizeB = parseInt(flashSize.slice(0, flashSize.indexOf(\"MB\"))) * 1024 * 1024;\n            }\n            return flashSizeB;\n        };\n        this.IS_STUB = false;\n        this.FLASH_WRITE_SIZE = 0x4000;\n        this.transport = options.transport;\n        this.baudrate = options.baudrate;\n        this.resetConstructors = {\n            classicReset: (transport, resetDelay) => new _reset_js__WEBPACK_IMPORTED_MODULE_3__.ClassicReset(transport, resetDelay),\n            customReset: (transport, sequenceString) => new _reset_js__WEBPACK_IMPORTED_MODULE_3__.CustomReset(transport, sequenceString),\n            hardReset: (transport, usingUsbOtg) => new _reset_js__WEBPACK_IMPORTED_MODULE_3__.HardReset(transport, usingUsbOtg),\n            usbJTAGSerialReset: (transport) => new _reset_js__WEBPACK_IMPORTED_MODULE_3__.UsbJtagSerialReset(transport),\n        };\n        if (options.serialOptions) {\n            this.serialOptions = options.serialOptions;\n        }\n        if (options.romBaudrate) {\n            this.romBaudrate = options.romBaudrate;\n        }\n        if (options.terminal) {\n            this.terminal = options.terminal;\n            this.terminal.clean();\n        }\n        if (typeof options.debugLogging !== \"undefined\") {\n            this.debugLogging = options.debugLogging;\n        }\n        if (options.port) {\n            this.transport = new _webserial_js__WEBPACK_IMPORTED_MODULE_2__.Transport(options.port);\n        }\n        if (typeof options.enableTracing !== \"undefined\") {\n            this.transport.tracing = options.enableTracing;\n        }\n        if ((_a = options.resetConstructors) === null || _a === void 0 ? void 0 : _a.classicReset) {\n            this.resetConstructors.classicReset = (_b = options.resetConstructors) === null || _b === void 0 ? void 0 : _b.classicReset;\n        }\n        if ((_c = options.resetConstructors) === null || _c === void 0 ? void 0 : _c.customReset) {\n            this.resetConstructors.customReset = (_d = options.resetConstructors) === null || _d === void 0 ? void 0 : _d.customReset;\n        }\n        if ((_e = options.resetConstructors) === null || _e === void 0 ? void 0 : _e.hardReset) {\n            this.resetConstructors.hardReset = (_f = options.resetConstructors) === null || _f === void 0 ? void 0 : _f.hardReset;\n        }\n        if ((_g = options.resetConstructors) === null || _g === void 0 ? void 0 : _g.usbJTAGSerialReset) {\n            this.resetConstructors.usbJTAGSerialReset = (_h = options.resetConstructors) === null || _h === void 0 ? void 0 : _h.usbJTAGSerialReset;\n        }\n        this.info(\"esptool.js\");\n        this.info(\"Serial port \" + this.transport.getInfo());\n    }\n    _sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /**\n     * Write to ESP Loader constructor's terminal with or without new line.\n     * @param {string} str - String to write.\n     * @param {boolean} withNewline - Add new line at the end ?\n     */\n    write(str, withNewline = true) {\n        if (this.terminal) {\n            if (withNewline) {\n                this.terminal.writeLine(str);\n            }\n            else {\n                this.terminal.write(str);\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(str);\n        }\n    }\n    /**\n     * Write error message to ESP Loader constructor's terminal with or without new line.\n     * @param {string} str - String to write.\n     * @param {boolean} withNewline - Add new line at the end ?\n     */\n    error(str, withNewline = true) {\n        this.write(`Error: ${str}`, withNewline);\n    }\n    /**\n     * Write information message to ESP Loader constructor's terminal with or without new line.\n     * @param {string} str - String to write.\n     * @param {boolean} withNewline - Add new line at the end ?\n     */\n    info(str, withNewline = true) {\n        this.write(str, withNewline);\n    }\n    /**\n     * Write debug message to ESP Loader constructor's terminal with or without new line.\n     * @param {string} str - String to write.\n     * @param {boolean} withNewline - Add new line at the end ?\n     */\n    debug(str, withNewline = true) {\n        if (this.debugLogging) {\n            this.write(`Debug: ${str}`, withNewline);\n        }\n    }\n    /**\n     * Convert short integer to byte array\n     * @param {number} i - Number to convert.\n     * @returns {Uint8Array} Byte array.\n     */\n    _shortToBytearray(i) {\n        return new Uint8Array([i & 0xff, (i >> 8) & 0xff]);\n    }\n    /**\n     * Convert an integer to byte array\n     * @param {number} i - Number to convert.\n     * @returns {ROM} The chip ROM class related to given magic hex number.\n     */\n    _intToByteArray(i) {\n        return new Uint8Array([i & 0xff, (i >> 8) & 0xff, (i >> 16) & 0xff, (i >> 24) & 0xff]);\n    }\n    /**\n     * Convert a byte array to short integer.\n     * @param {number} i - Number to convert.\n     * @param {number} j - Number to convert.\n     * @returns {number} Return a short integer number.\n     */\n    _byteArrayToShort(i, j) {\n        return i | (j >> 8);\n    }\n    /**\n     * Convert a byte array to integer.\n     * @param {number} i - Number to convert.\n     * @param {number} j - Number to convert.\n     * @param {number} k - Number to convert.\n     * @param {number} l - Number to convert.\n     * @returns {number} Return a integer number.\n     */\n    _byteArrayToInt(i, j, k, l) {\n        return i | (j << 8) | (k << 16) | (l << 24);\n    }\n    /**\n     * Append a buffer array after another buffer array\n     * @param {ArrayBuffer} buffer1 - First array buffer.\n     * @param {ArrayBuffer} buffer2 - magic hex number to select ROM.\n     * @returns {ArrayBufferLike} Return an array buffer.\n     */\n    _appendBuffer(buffer1, buffer2) {\n        const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n        tmp.set(new Uint8Array(buffer1), 0);\n        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n        return tmp.buffer;\n    }\n    /**\n     * Append a buffer array after another buffer array\n     * @param {Uint8Array} arr1 - First array buffer.\n     * @param {Uint8Array} arr2 - magic hex number to select ROM.\n     * @returns {Uint8Array} Return a 8 bit unsigned array.\n     */\n    _appendArray(arr1, arr2) {\n        const c = new Uint8Array(arr1.length + arr2.length);\n        c.set(arr1, 0);\n        c.set(arr2, arr1.length);\n        return c;\n    }\n    /**\n     * Convert a unsigned 8 bit integer array to byte string.\n     * @param {Uint8Array} u8Array - magic hex number to select ROM.\n     * @returns {string} Return the equivalent string.\n     */\n    ui8ToBstr(u8Array) {\n        let bStr = \"\";\n        for (let i = 0; i < u8Array.length; i++) {\n            bStr += String.fromCharCode(u8Array[i]);\n        }\n        return bStr;\n    }\n    /**\n     * Convert a byte string to unsigned 8 bit integer array.\n     * @param {string} bStr - binary string input\n     * @returns {Uint8Array} Return a 8 bit unsigned integer array.\n     */\n    bstrToUi8(bStr) {\n        const u8Array = new Uint8Array(bStr.length);\n        for (let i = 0; i < bStr.length; i++) {\n            u8Array[i] = bStr.charCodeAt(i);\n        }\n        return u8Array;\n    }\n    /**\n     * Flush the serial input by raw read with 200 ms timeout.\n     */\n    async flushInput() {\n        try {\n            await this.transport.flushInput();\n        }\n        catch (e) {\n            this.error(e.message);\n        }\n    }\n    /**\n     * Use the device serial port read function with given timeout to create a valid packet.\n     * @param {number} op Operation number\n     * @param {number} timeout timeout number in milliseconds\n     * @returns {[number, Uint8Array]} valid response packet.\n     */\n    async readPacket(op = null, timeout = this.DEFAULT_TIMEOUT) {\n        // Check up-to next 100 packets for valid response packet\n        for (let i = 0; i < 100; i++) {\n            const { value: p } = await this.transport.read(timeout).next();\n            if (!p || p.length < 8) {\n                continue;\n            }\n            const resp = p[0];\n            if (resp !== 1) {\n                continue;\n            }\n            const opRet = p[1];\n            const val = this._byteArrayToInt(p[4], p[5], p[6], p[7]);\n            const data = p.slice(8);\n            if (resp == 1) {\n                if (op == null || opRet == op) {\n                    return [val, data];\n                }\n                else if (data[0] != 0 && data[1] == this.ROM_INVALID_RECV_MSG) {\n                    await this.flushInput();\n                    throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"unsupported command error\");\n                }\n            }\n        }\n        throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"invalid response\");\n    }\n    /**\n     * Write a serial command to the chip\n     * @param {number} op - Operation number\n     * @param {Uint8Array} data - Unsigned 8 bit array\n     * @param {number} chk - channel number\n     * @param {boolean} waitResponse - wait for response ?\n     * @param {number} timeout - timeout number in milliseconds\n     * @returns {Promise<[number, Uint8Array]>} Return a number and a 8 bit unsigned integer array.\n     */\n    async command(op = null, data = new Uint8Array(0), chk = 0, waitResponse = true, timeout = this.DEFAULT_TIMEOUT) {\n        if (op != null) {\n            if (this.transport.tracing) {\n                this.transport.trace(`command op:0x${op.toString(16).padStart(2, \"0\")} data len=${data.length} wait_response=${waitResponse ? 1 : 0} timeout=${(timeout / 1000).toFixed(3)} data=${this.transport.hexConvert(data)}`);\n            }\n            const pkt = new Uint8Array(8 + data.length);\n            pkt[0] = 0x00;\n            pkt[1] = op;\n            pkt[2] = this._shortToBytearray(data.length)[0];\n            pkt[3] = this._shortToBytearray(data.length)[1];\n            pkt[4] = this._intToByteArray(chk)[0];\n            pkt[5] = this._intToByteArray(chk)[1];\n            pkt[6] = this._intToByteArray(chk)[2];\n            pkt[7] = this._intToByteArray(chk)[3];\n            let i;\n            for (i = 0; i < data.length; i++) {\n                pkt[8 + i] = data[i];\n            }\n            await this.transport.write(pkt);\n        }\n        if (!waitResponse) {\n            return [0, new Uint8Array(0)];\n        }\n        return this.readPacket(op, timeout);\n    }\n    /**\n     * Read a register from chip.\n     * @param {number} addr - Register address number\n     * @param {number} timeout - Timeout in milliseconds (Default: 3000ms)\n     * @returns {number} - Command number value\n     */\n    async readReg(addr, timeout = this.DEFAULT_TIMEOUT) {\n        const pkt = this._intToByteArray(addr);\n        const val = await this.command(this.ESP_READ_REG, pkt, undefined, undefined, timeout);\n        return val[0];\n    }\n    /**\n     * Write a number value to register address in chip.\n     * @param {number} addr - Register address number\n     * @param {number} value - Number value to write in register\n     * @param {number} mask - Hex number for mask\n     * @param {number} delayUs Delay number\n     * @param {number} delayAfterUs Delay after previous delay\n     */\n    async writeReg(addr, value, mask = 0xffffffff, delayUs = 0, delayAfterUs = 0) {\n        let pkt = this._appendArray(this._intToByteArray(addr), this._intToByteArray(value));\n        pkt = this._appendArray(pkt, this._intToByteArray(mask));\n        pkt = this._appendArray(pkt, this._intToByteArray(delayUs));\n        if (delayAfterUs > 0) {\n            pkt = this._appendArray(pkt, this._intToByteArray(this.chip.UART_DATE_REG_ADDR));\n            pkt = this._appendArray(pkt, this._intToByteArray(0));\n            pkt = this._appendArray(pkt, this._intToByteArray(0));\n            pkt = this._appendArray(pkt, this._intToByteArray(delayAfterUs));\n        }\n        await this.checkCommand(\"write target memory\", this.ESP_WRITE_REG, pkt);\n    }\n    /**\n     * Sync chip by sending sync command.\n     * @returns {[number, Uint8Array]} Command result\n     */\n    async sync() {\n        this.debug(\"Sync\");\n        const cmd = new Uint8Array(36);\n        let i;\n        cmd[0] = 0x07;\n        cmd[1] = 0x07;\n        cmd[2] = 0x12;\n        cmd[3] = 0x20;\n        for (i = 0; i < 32; i++) {\n            cmd[4 + i] = 0x55;\n        }\n        try {\n            let resp = await this.command(0x08, cmd, undefined, undefined, 100);\n            // ROM bootloaders send some non-zero \"val\" response. The flasher stub sends 0.\n            // If we receive 0 then it probably indicates that the chip wasn't or couldn't be\n            // reset properly and esptool is talking to the flasher stub.\n            this.syncStubDetected = resp[0] === 0;\n            for (let i = 0; i < 7; i++) {\n                resp = await this.command();\n                this.syncStubDetected = this.syncStubDetected && resp[0] === 0;\n            }\n            return resp;\n        }\n        catch (e) {\n            this.debug(\"Sync err \" + e);\n            throw e;\n        }\n    }\n    /**\n     * Attempt to connect to the chip by sending a reset sequence and later a sync command.\n     * @param {string} mode - Reset mode to use\n     * @param {ResetStrategy} resetStrategy - Reset strategy class to use for connect\n     * @returns {string} - Returns 'success' or 'error' message.\n     */\n    async _connectAttempt(mode = \"default_reset\", resetStrategy) {\n        this.debug(\"_connect_attempt \" + mode);\n        if (resetStrategy) {\n            await resetStrategy.reset();\n        }\n        const waitingBytes = this.transport.inWaiting();\n        const readBytes = await this.transport.newRead(waitingBytes > 0 ? waitingBytes : 1, this.DEFAULT_TIMEOUT);\n        const binaryString = Array.from(readBytes, (byte) => String.fromCharCode(byte)).join(\"\");\n        const regex = /boot:(0x[0-9a-fA-F]+)(.*waiting for download)?/;\n        const match = binaryString.match(regex);\n        let bootLogDetected = false, bootMode = \"\", downloadMode = false;\n        if (match) {\n            bootLogDetected = true;\n            bootMode = match[1];\n            downloadMode = !!match[2];\n        }\n        let lastError = \"\";\n        for (let i = 0; i < 5; i++) {\n            try {\n                this.debug(`Sync connect attempt ${i}`);\n                const resp = await this.sync();\n                this.debug(resp[0].toString());\n                return \"success\";\n            }\n            catch (error) {\n                this.debug(`Error at sync ${error}`);\n                if (error instanceof Error) {\n                    lastError = error.message;\n                }\n                else if (typeof error === \"string\") {\n                    lastError = error;\n                }\n                else {\n                    lastError = JSON.stringify(error);\n                }\n            }\n        }\n        if (bootLogDetected) {\n            lastError = `Wrong boot mode detected (${bootMode}).\n        This chip needs to be in download mode.`;\n            if (downloadMode) {\n                lastError = `Download mode successfully detected, but getting no sync reply:\n           The serial TX path seems to be down.`;\n            }\n        }\n        return lastError;\n    }\n    /**\n     * Constructs a sequence of reset strategies based on the OS,\n     * used ESP chip, external settings, and environment variables.\n     * Returns a tuple of one or more reset strategies to be tried sequentially.\n     * @param {string} mode - Reset mode to use\n     * @returns {ResetStrategy[]} - Array of reset strategies\n     */\n    constructResetSequence(mode) {\n        if (mode !== \"no_reset\") {\n            if (mode === \"usb_reset\" || this.transport.getPid() === this.USB_JTAG_SERIAL_PID) {\n                // Custom reset sequence, which is required when the device\n                // is connecting via its USB-JTAG-Serial peripheral\n                if (this.resetConstructors.usbJTAGSerialReset) {\n                    this.debug(\"using USB JTAG Serial Reset\");\n                    return [this.resetConstructors.usbJTAGSerialReset(this.transport)];\n                }\n            }\n            else {\n                const DEFAULT_RESET_DELAY = 50;\n                const EXTRA_DELAY = DEFAULT_RESET_DELAY + 500;\n                if (this.resetConstructors.classicReset) {\n                    this.debug(\"using Classic Serial Reset\");\n                    return [\n                        this.resetConstructors.classicReset(this.transport, DEFAULT_RESET_DELAY),\n                        this.resetConstructors.classicReset(this.transport, EXTRA_DELAY),\n                    ];\n                }\n            }\n        }\n        return [];\n    }\n    /**\n     * Perform a connection to chip.\n     * @param {string} mode - Reset mode to use. Example: 'default_reset' | 'no_reset'\n     * @param {number} attempts - Number of connection attempts\n     * @param {boolean} detecting - Detect the connected chip\n     */\n    async connect(mode = \"default_reset\", attempts = 7, detecting = true) {\n        let resp;\n        this.info(\"Connecting...\", false);\n        await this.transport.connect(this.romBaudrate, this.serialOptions);\n        const resetSequences = this.constructResetSequence(mode);\n        for (let i = 0; i < attempts; i++) {\n            const resetSequence = resetSequences.length > 0 ? resetSequences[i % resetSequences.length] : null;\n            resp = await this._connectAttempt(mode, resetSequence);\n            if (resp === \"success\") {\n                break;\n            }\n        }\n        if (resp !== \"success\") {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Failed to connect with the device\");\n        }\n        this.debug(\"Connect attempt successful.\");\n        this.info(\"\\n\\r\", false);\n        if (detecting) {\n            const chipMagicValue = (await this.readReg(this.CHIP_DETECT_MAGIC_REG_ADDR)) >>> 0;\n            this.debug(\"Chip Magic \" + chipMagicValue.toString(16));\n            const chip = await magic2Chip(chipMagicValue);\n            if (this.chip === null) {\n                throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(`Unexpected CHIP magic value ${chipMagicValue}. Failed to autodetect chip type.`);\n            }\n            else {\n                this.chip = chip;\n            }\n        }\n    }\n    /**\n     * Connect and detect the existing chip.\n     * @param {string} mode Reset mode to use for connection.\n     */\n    async detectChip(mode = \"default_reset\") {\n        await this.connect(mode);\n        this.info(\"Detecting chip type... \", false);\n        if (this.chip != null) {\n            this.info(this.chip.CHIP_NAME);\n        }\n        else {\n            this.info(\"unknown!\");\n        }\n    }\n    /**\n     * Execute the command and check the command response.\n     * @param {string} opDescription Command operation description.\n     * @param {number} op Command operation number\n     * @param {Uint8Array} data Command value\n     * @param {number} chk Checksum to use\n     * @param {number} timeout TImeout number in milliseconds (ms)\n     * @returns {number} Command result\n     */\n    async checkCommand(opDescription = \"\", op = null, data = new Uint8Array(0), chk = 0, timeout = this.DEFAULT_TIMEOUT) {\n        this.debug(\"check_command \" + opDescription);\n        const resp = await this.command(op, data, chk, undefined, timeout);\n        if (resp[1].length > 4) {\n            return resp[1];\n        }\n        else {\n            return resp[0];\n        }\n    }\n    /**\n     * Start downloading an application image to RAM\n     * @param {number} size Image size number\n     * @param {number} blocks Number of data blocks\n     * @param {number} blocksize Size of each data block\n     * @param {number} offset Image offset number\n     */\n    async memBegin(size, blocks, blocksize, offset) {\n        /* XXX: Add check to ensure that STUB is not getting overwritten */\n        if (this.IS_STUB) {\n            const loadStart = offset;\n            const loadEnd = offset + size;\n            const stub = await (0,_stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__.getStubJsonByChipName)(this.chip.CHIP_NAME);\n            if (stub) {\n                const areasToCheck = [\n                    [stub.bss_start || stub.data_start, stub.data_start + stub.decodedData.length],\n                    [stub.text_start, stub.text_start + stub.decodedText.length],\n                ];\n                for (const [stubStart, stubEnd] of areasToCheck) {\n                    if (loadStart < stubEnd && loadEnd > stubStart) {\n                        throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(`Software loader is resident at 0x${stubStart.toString(16).padStart(8, \"0\")}-0x${stubEnd\n                            .toString(16)\n                            .padStart(8, \"0\")}.\n            Can't load binary at overlapping address range 0x${loadStart.toString(16).padStart(8, \"0\")}-0x${loadEnd\n                            .toString(16)\n                            .padStart(8, \"0\")}.\n            Either change binary loading address, or use the no-stub option to disable the software loader.`);\n                    }\n                }\n            }\n        }\n        this.debug(\"mem_begin \" + size + \" \" + blocks + \" \" + blocksize + \" \" + offset.toString(16));\n        let pkt = this._appendArray(this._intToByteArray(size), this._intToByteArray(blocks));\n        pkt = this._appendArray(pkt, this._intToByteArray(blocksize));\n        pkt = this._appendArray(pkt, this._intToByteArray(offset));\n        await this.checkCommand(\"enter RAM download mode\", this.ESP_MEM_BEGIN, pkt);\n    }\n    /**\n     * Get the checksum for given unsigned 8-bit array\n     * @param {Uint8Array} data Unsigned 8-bit integer array\n     * @param {number} state Initial checksum\n     * @returns {number} - Array checksum\n     */\n    checksum(data, state = this.ESP_CHECKSUM_MAGIC) {\n        for (let i = 0; i < data.length; i++) {\n            state ^= data[i];\n        }\n        return state;\n    }\n    /**\n     * Send a block of image to RAM\n     * @param {Uint8Array} buffer Unsigned 8-bit array\n     * @param {number} seq Sequence number\n     */\n    async memBlock(buffer, seq) {\n        let pkt = this._appendArray(this._intToByteArray(buffer.length), this._intToByteArray(seq));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, buffer);\n        const checksum = this.checksum(buffer);\n        await this.checkCommand(\"write to target RAM\", this.ESP_MEM_DATA, pkt, checksum);\n    }\n    /**\n     * Leave RAM download mode and run application\n     * @param {number} entrypoint - Entrypoint number\n     */\n    async memFinish(entrypoint) {\n        const isEntry = entrypoint === 0 ? 1 : 0;\n        const pkt = this._appendArray(this._intToByteArray(isEntry), this._intToByteArray(entrypoint));\n        await this.checkCommand(\"leave RAM download mode\", this.ESP_MEM_END, pkt, undefined, 200); // XXX: handle non-stub with diff timeout\n    }\n    /**\n     * Configure SPI flash pins\n     * @param {number} hspiArg -  Argument for SPI attachment\n     */\n    async flashSpiAttach(hspiArg) {\n        const pkt = this._intToByteArray(hspiArg);\n        await this.checkCommand(\"configure SPI flash pins\", this.ESP_SPI_ATTACH, pkt);\n    }\n    /**\n     * Scale timeouts which are size-specific.\n     * @param {number} secondsPerMb Seconds per megabytes as number\n     * @param {number} sizeBytes Size bytes number\n     * @returns {number} - Scaled timeout for specified size.\n     */\n    timeoutPerMb(secondsPerMb, sizeBytes) {\n        const result = secondsPerMb * (sizeBytes / 1000000);\n        if (result < 3000) {\n            return 3000;\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * Start downloading to Flash (performs an erase)\n     * @param {number} size Size to erase\n     * @param {number} offset Offset to erase\n     * @returns {number} Number of blocks (of size self.FLASH_WRITE_SIZE) to write.\n     */\n    async flashBegin(size, offset) {\n        const numBlocks = Math.floor((size + this.FLASH_WRITE_SIZE - 1) / this.FLASH_WRITE_SIZE);\n        const eraseSize = this.chip.getEraseSize(offset, size);\n        const d = new Date();\n        const t1 = d.getTime();\n        let timeout = 3000;\n        if (this.IS_STUB == false) {\n            timeout = this.timeoutPerMb(this.ERASE_REGION_TIMEOUT_PER_MB, size);\n        }\n        this.debug(\"flash begin \" + eraseSize + \" \" + numBlocks + \" \" + this.FLASH_WRITE_SIZE + \" \" + offset + \" \" + size);\n        let pkt = this._appendArray(this._intToByteArray(eraseSize), this._intToByteArray(numBlocks));\n        pkt = this._appendArray(pkt, this._intToByteArray(this.FLASH_WRITE_SIZE));\n        pkt = this._appendArray(pkt, this._intToByteArray(offset));\n        if (this.IS_STUB == false) {\n            pkt = this._appendArray(pkt, this._intToByteArray(0)); // XXX: Support encrypted\n        }\n        await this.checkCommand(\"enter Flash download mode\", this.ESP_FLASH_BEGIN, pkt, undefined, timeout);\n        const t2 = d.getTime();\n        if (size != 0 && this.IS_STUB == false) {\n            this.info(\"Took \" + (t2 - t1) / 1000 + \".\" + ((t2 - t1) % 1000) + \"s to erase flash block\");\n        }\n        return numBlocks;\n    }\n    /**\n     * Start downloading compressed data to Flash (performs an erase)\n     * @param {number} size Write size\n     * @param {number} compsize Compressed size\n     * @param {number} offset Offset for write\n     * @returns {number} Returns number of blocks (size self.FLASH_WRITE_SIZE) to write.\n     */\n    async flashDeflBegin(size, compsize, offset) {\n        const numBlocks = Math.floor((compsize + this.FLASH_WRITE_SIZE - 1) / this.FLASH_WRITE_SIZE);\n        const eraseBlocks = Math.floor((size + this.FLASH_WRITE_SIZE - 1) / this.FLASH_WRITE_SIZE);\n        const d = new Date();\n        const t1 = d.getTime();\n        let writeSize, timeout;\n        if (this.IS_STUB) {\n            writeSize = size;\n            timeout = this.DEFAULT_TIMEOUT;\n        }\n        else {\n            writeSize = eraseBlocks * this.FLASH_WRITE_SIZE;\n            timeout = this.timeoutPerMb(this.ERASE_REGION_TIMEOUT_PER_MB, writeSize);\n        }\n        this.info(\"Compressed \" + size + \" bytes to \" + compsize + \"...\");\n        let pkt = this._appendArray(this._intToByteArray(writeSize), this._intToByteArray(numBlocks));\n        pkt = this._appendArray(pkt, this._intToByteArray(this.FLASH_WRITE_SIZE));\n        pkt = this._appendArray(pkt, this._intToByteArray(offset));\n        if ((this.chip.CHIP_NAME === \"ESP32-S2\" ||\n            this.chip.CHIP_NAME === \"ESP32-S3\" ||\n            this.chip.CHIP_NAME === \"ESP32-C3\" ||\n            this.chip.CHIP_NAME === \"ESP32-C2\") &&\n            this.IS_STUB === false) {\n            pkt = this._appendArray(pkt, this._intToByteArray(0));\n        }\n        await this.checkCommand(\"enter compressed flash mode\", this.ESP_FLASH_DEFL_BEGIN, pkt, undefined, timeout);\n        const t2 = d.getTime();\n        if (size != 0 && this.IS_STUB === false) {\n            this.info(\"Took \" + (t2 - t1) / 1000 + \".\" + ((t2 - t1) % 1000) + \"s to erase flash block\");\n        }\n        return numBlocks;\n    }\n    /**\n     * Write block to flash, retry if fail\n     * @param {Uint8Array} data Unsigned 8-bit array data.\n     * @param {number} seq Sequence number\n     * @param {number} timeout Timeout in milliseconds (ms)\n     */\n    async flashBlock(data, seq, timeout) {\n        let pkt = this._appendArray(this._intToByteArray(data.length), this._intToByteArray(seq));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, data);\n        const checksum = this.checksum(data);\n        await this.checkCommand(\"write to target Flash after seq \" + seq, this.ESP_FLASH_DATA, pkt, checksum, timeout);\n    }\n    /**\n     * Write block to flash, send compressed, retry if fail\n     * @param {Uint8Array} data Unsigned int 8-bit array data to write\n     * @param {number} seq Sequence number\n     * @param {number} timeout Timeout in milliseconds (ms)\n     */\n    async flashDeflBlock(data, seq, timeout) {\n        let pkt = this._appendArray(this._intToByteArray(data.length), this._intToByteArray(seq));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, data);\n        const checksum = this.checksum(data);\n        this.debug(\"flash_defl_block \" + data[0].toString(16) + \" \" + data[1].toString(16));\n        await this.checkCommand(\"write compressed data to flash after seq \" + seq, this.ESP_FLASH_DEFL_DATA, pkt, checksum, timeout);\n    }\n    /**\n     * Leave flash mode and run/reboot\n     * @param {boolean} reboot Reboot after leaving flash mode ?\n     */\n    async flashFinish(reboot = false) {\n        const val = reboot ? 0 : 1;\n        const pkt = this._intToByteArray(val);\n        await this.checkCommand(\"leave Flash mode\", this.ESP_FLASH_END, pkt);\n    }\n    /**\n     * Leave compressed flash mode and run/reboot\n     * @param {boolean} reboot Reboot after leaving flash mode ?\n     */\n    async flashDeflFinish(reboot = false) {\n        const val = reboot ? 0 : 1;\n        const pkt = this._intToByteArray(val);\n        await this.checkCommand(\"leave compressed flash mode\", this.ESP_FLASH_DEFL_END, pkt);\n    }\n    /**\n     * Run an arbitrary SPI flash command.\n     *\n     * This function uses the \"USR_COMMAND\" functionality in the ESP\n     * SPI hardware, rather than the precanned commands supported by\n     * hardware. So the value of spiflashCommand is an actual command\n     * byte, sent over the wire.\n     *\n     * After writing command byte, writes 'data' to MOSI and then\n     * reads back 'readBits' of reply on MISO. Result is a number.\n     * @param {number} spiflashCommand Command to execute in SPI\n     * @param {Uint8Array} data Data to send\n     * @param {number} readBits Number of bits to read\n     * @returns {number} Register SPI_W0_REG value\n     */\n    async runSpiflashCommand(spiflashCommand, data, readBits) {\n        // SPI_USR register flags\n        const SPI_USR_COMMAND = 1 << 31;\n        const SPI_USR_MISO = 1 << 28;\n        const SPI_USR_MOSI = 1 << 27;\n        // SPI registers, base address differs ESP32* vs 8266\n        const base = this.chip.SPI_REG_BASE;\n        const SPI_CMD_REG = base + 0x00;\n        const SPI_USR_REG = base + this.chip.SPI_USR_OFFS;\n        const SPI_USR1_REG = base + this.chip.SPI_USR1_OFFS;\n        const SPI_USR2_REG = base + this.chip.SPI_USR2_OFFS;\n        const SPI_W0_REG = base + this.chip.SPI_W0_OFFS;\n        let setDataLengths;\n        if (this.chip.SPI_MOSI_DLEN_OFFS != null) {\n            setDataLengths = async (mosiBits, misoBits) => {\n                const SPI_MOSI_DLEN_REG = base + this.chip.SPI_MOSI_DLEN_OFFS;\n                const SPI_MISO_DLEN_REG = base + this.chip.SPI_MISO_DLEN_OFFS;\n                if (mosiBits > 0) {\n                    await this.writeReg(SPI_MOSI_DLEN_REG, mosiBits - 1);\n                }\n                if (misoBits > 0) {\n                    await this.writeReg(SPI_MISO_DLEN_REG, misoBits - 1);\n                }\n            };\n        }\n        else {\n            setDataLengths = async (mosiBits, misoBits) => {\n                const SPI_DATA_LEN_REG = SPI_USR1_REG;\n                const SPI_MOSI_BITLEN_S = 17;\n                const SPI_MISO_BITLEN_S = 8;\n                const mosiMask = mosiBits === 0 ? 0 : mosiBits - 1;\n                const misoMask = misoBits === 0 ? 0 : misoBits - 1;\n                const val = (misoMask << SPI_MISO_BITLEN_S) | (mosiMask << SPI_MOSI_BITLEN_S);\n                await this.writeReg(SPI_DATA_LEN_REG, val);\n            };\n        }\n        const SPI_CMD_USR = 1 << 18;\n        const SPI_USR2_COMMAND_LEN_SHIFT = 28;\n        if (readBits > 32) {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Reading more than 32 bits back from a SPI flash operation is unsupported\");\n        }\n        if (data.length > 64) {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Writing more than 64 bytes of data with one SPI command is unsupported\");\n        }\n        const dataBits = data.length * 8;\n        const oldSpiUsr = await this.readReg(SPI_USR_REG);\n        const oldSpiUsr2 = await this.readReg(SPI_USR2_REG);\n        let flags = SPI_USR_COMMAND;\n        let i;\n        if (readBits > 0) {\n            flags |= SPI_USR_MISO;\n        }\n        if (dataBits > 0) {\n            flags |= SPI_USR_MOSI;\n        }\n        await setDataLengths(dataBits, readBits);\n        await this.writeReg(SPI_USR_REG, flags);\n        let val = (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflashCommand;\n        await this.writeReg(SPI_USR2_REG, val);\n        if (dataBits == 0) {\n            await this.writeReg(SPI_W0_REG, 0);\n        }\n        else {\n            if (data.length % 4 != 0) {\n                const padding = new Uint8Array(data.length % 4);\n                data = this._appendArray(data, padding);\n            }\n            let nextReg = SPI_W0_REG;\n            for (i = 0; i < data.length - 4; i += 4) {\n                val = this._byteArrayToInt(data[i], data[i + 1], data[i + 2], data[i + 3]);\n                await this.writeReg(nextReg, val);\n                nextReg += 4;\n            }\n        }\n        await this.writeReg(SPI_CMD_REG, SPI_CMD_USR);\n        for (i = 0; i < 10; i++) {\n            val = (await this.readReg(SPI_CMD_REG)) & SPI_CMD_USR;\n            if (val == 0) {\n                break;\n            }\n        }\n        if (i === 10) {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"SPI command did not complete in time\");\n        }\n        const stat = await this.readReg(SPI_W0_REG);\n        await this.writeReg(SPI_USR_REG, oldSpiUsr);\n        await this.writeReg(SPI_USR2_REG, oldSpiUsr2);\n        return stat;\n    }\n    /**\n     * Read flash id by executing the SPIFLASH_RDID flash command.\n     * @returns {Promise<number>} Register SPI_W0_REG value\n     */\n    async readFlashId() {\n        const SPIFLASH_RDID = 0x9f;\n        const pkt = new Uint8Array(0);\n        return await this.runSpiflashCommand(SPIFLASH_RDID, pkt, 24);\n    }\n    /**\n     * Execute the erase flash command\n     * @returns {Promise<number | Uint8Array>} Erase flash command result\n     */\n    async eraseFlash() {\n        this.info(\"Erasing flash (this may take a while)...\");\n        let d = new Date();\n        const t1 = d.getTime();\n        const ret = await this.checkCommand(\"erase flash\", this.ESP_ERASE_FLASH, undefined, undefined, this.CHIP_ERASE_TIMEOUT);\n        d = new Date();\n        const t2 = d.getTime();\n        this.info(\"Chip erase completed successfully in \" + (t2 - t1) / 1000 + \"s\");\n        return ret;\n    }\n    /**\n     * Convert a number or unsigned 8-bit array to hex string\n     * @param {number | Uint8Array } buffer Data to convert to hex string.\n     * @returns {string} A hex string\n     */\n    toHex(buffer) {\n        return Array.prototype.map.call(buffer, (x) => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n    }\n    /**\n     * Calculate the MD5 Checksum command\n     * @param {number} addr Address number\n     * @param {number} size Package size\n     * @returns {string} MD5 Checksum string\n     */\n    async flashMd5sum(addr, size) {\n        const timeout = this.timeoutPerMb(this.MD5_TIMEOUT_PER_MB, size);\n        let pkt = this._appendArray(this._intToByteArray(addr), this._intToByteArray(size));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        pkt = this._appendArray(pkt, this._intToByteArray(0));\n        let res = await this.checkCommand(\"calculate md5sum\", this.ESP_SPI_FLASH_MD5, pkt, undefined, timeout);\n        if (res instanceof Uint8Array && res.length > 16) {\n            res = res.slice(0, 16);\n        }\n        const strmd5 = this.toHex(res);\n        return strmd5;\n    }\n    async readFlash(addr, size, onPacketReceived = null) {\n        let pkt = this._appendArray(this._intToByteArray(addr), this._intToByteArray(size));\n        pkt = this._appendArray(pkt, this._intToByteArray(0x1000));\n        pkt = this._appendArray(pkt, this._intToByteArray(1024));\n        const res = await this.checkCommand(\"read flash\", this.ESP_READ_FLASH, pkt);\n        if (res != 0) {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Failed to read memory: \" + res);\n        }\n        let resp = new Uint8Array(0);\n        while (resp.length < size) {\n            const { value: packet } = await this.transport.read(this.FLASH_READ_TIMEOUT).next();\n            if (packet instanceof Uint8Array) {\n                if (packet.length > 0) {\n                    resp = this._appendArray(resp, packet);\n                    await this.transport.write(this._intToByteArray(resp.length));\n                    if (onPacketReceived) {\n                        onPacketReceived(packet, resp.length, size);\n                    }\n                }\n            }\n            else {\n                throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Failed to read memory: \" + packet);\n            }\n        }\n        return resp;\n    }\n    /**\n     * Upload the flasher ROM bootloader (flasher stub) to the chip.\n     * @returns {ROM} The Chip ROM\n     */\n    async runStub() {\n        if (this.syncStubDetected) {\n            this.info(\"Stub is already running. No upload is necessary.\");\n            return this.chip;\n        }\n        this.info(\"Uploading stub...\");\n        const stubFlasher = await (0,_stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__.getStubJsonByChipName)(this.chip.CHIP_NAME);\n        if (stubFlasher === undefined) {\n            this.debug(\"Error loading Stub json\");\n            throw new Error(\"Error loading Stub json\");\n        }\n        const stub = [stubFlasher.decodedText, stubFlasher.decodedData];\n        for (let i = 0; i < stub.length; i++) {\n            if (stub[i]) {\n                const offs = i === 0 ? stubFlasher.text_start : stubFlasher.data_start;\n                const length = stub[i].length;\n                const blocks = Math.floor((length + this.ESP_RAM_BLOCK - 1) / this.ESP_RAM_BLOCK);\n                await this.memBegin(length, blocks, this.ESP_RAM_BLOCK, offs);\n                for (let seq = 0; seq < blocks; seq++) {\n                    const fromOffs = seq * this.ESP_RAM_BLOCK;\n                    const toOffs = fromOffs + this.ESP_RAM_BLOCK;\n                    await this.memBlock(stub[i].slice(fromOffs, toOffs), seq);\n                }\n            }\n        }\n        this.info(\"Running stub...\");\n        await this.memFinish(stubFlasher.entry);\n        const { value: packetResult } = await this.transport.read(this.DEFAULT_TIMEOUT).next();\n        const packetStr = String.fromCharCode(...packetResult);\n        if (packetStr !== \"OHAI\") {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(`Failed to start stub. Unexpected response ${packetStr}`);\n        }\n        this.info(\"Stub running...\");\n        this.IS_STUB = true;\n        return this.chip;\n    }\n    /**\n     * Change the chip baudrate.\n     */\n    async changeBaud() {\n        this.info(\"Changing baudrate to \" + this.baudrate);\n        const secondArg = this.IS_STUB ? this.romBaudrate : 0;\n        const pkt = this._appendArray(this._intToByteArray(this.baudrate), this._intToByteArray(secondArg));\n        await this.command(this.ESP_CHANGE_BAUDRATE, pkt);\n        this.info(\"Changed\");\n        await this.transport.disconnect();\n        await this._sleep(50);\n        await this.transport.connect(this.baudrate, this.serialOptions);\n    }\n    /**\n     * Execute the main function of ESPLoader.\n     * @param {string} mode Reset mode to use\n     * @returns {string} chip ROM\n     */\n    async main(mode = \"default_reset\") {\n        await this.detectChip(mode);\n        const chip = await this.chip.getChipDescription(this);\n        this.info(\"Chip is \" + chip);\n        this.info(\"Features: \" + (await this.chip.getChipFeatures(this)));\n        this.info(\"Crystal is \" + (await this.chip.getCrystalFreq(this)) + \"MHz\");\n        this.info(\"MAC: \" + (await this.chip.readMac(this)));\n        await this.chip.readMac(this);\n        if (typeof this.chip.postConnect != \"undefined\") {\n            await this.chip.postConnect(this);\n        }\n        await this.runStub();\n        if (this.romBaudrate !== this.baudrate) {\n            await this.changeBaud();\n        }\n        return chip;\n    }\n    /**\n     * Parse a given flash size string to a number\n     * @param {string} flsz Flash size to request\n     * @returns {number} Flash size number\n     */\n    parseFlashSizeArg(flsz) {\n        if (typeof this.chip.FLASH_SIZES[flsz] === \"undefined\") {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Flash size \" + flsz + \" is not supported by this chip type. Supported sizes: \" + this.chip.FLASH_SIZES);\n        }\n        return this.chip.FLASH_SIZES[flsz];\n    }\n    /**\n     * Update the image flash parameters with given arguments.\n     * @param {string} image binary image as string\n     * @param {number} address flash address number\n     * @param {string} flashSize Flash size string\n     * @param {string} flashMode Flash mode string\n     * @param {string} flashFreq Flash frequency string\n     * @returns {string} modified image string\n     */\n    _updateImageFlashParams(image, address, flashSize, flashMode, flashFreq) {\n        this.debug(\"_update_image_flash_params \" + flashSize + \" \" + flashMode + \" \" + flashFreq);\n        if (image.length < 8) {\n            return image;\n        }\n        if (address != this.chip.BOOTLOADER_FLASH_OFFSET) {\n            return image;\n        }\n        if (flashSize === \"keep\" && flashMode === \"keep\" && flashFreq === \"keep\") {\n            this.info(\"Not changing the image\");\n            return image;\n        }\n        const magic = parseInt(image[0]);\n        let aFlashMode = parseInt(image[2]);\n        const flashSizeFreq = parseInt(image[3]);\n        if (magic !== this.ESP_IMAGE_MAGIC) {\n            this.info(\"Warning: Image file at 0x\" +\n                address.toString(16) +\n                \" doesn't look like an image file, so not changing any flash settings.\");\n            return image;\n        }\n        /* XXX: Yet to implement actual image verification */\n        if (flashMode !== \"keep\") {\n            const flashModes = { qio: 0, qout: 1, dio: 2, dout: 3 };\n            aFlashMode = flashModes[flashMode];\n        }\n        let aFlashFreq = flashSizeFreq & 0x0f;\n        if (flashFreq !== \"keep\") {\n            const flashFreqs = { \"40m\": 0, \"26m\": 1, \"20m\": 2, \"80m\": 0xf };\n            aFlashFreq = flashFreqs[flashFreq];\n        }\n        let aFlashSize = flashSizeFreq & 0xf0;\n        if (flashSize !== \"keep\") {\n            aFlashSize = this.parseFlashSizeArg(flashSize);\n        }\n        const flashParams = (aFlashMode << 8) | (aFlashFreq + aFlashSize);\n        this.info(\"Flash params set to \" + flashParams.toString(16));\n        if (parseInt(image[2]) !== aFlashMode << 8) {\n            image = image.substring(0, 2) + (aFlashMode << 8).toString() + image.substring(2 + 1);\n        }\n        if (parseInt(image[3]) !== aFlashFreq + aFlashSize) {\n            image = image.substring(0, 3) + (aFlashFreq + aFlashSize).toString() + image.substring(3 + 1);\n        }\n        return image;\n    }\n    /**\n     * Write set of file images into given address based on given FlashOptions object.\n     * @param {FlashOptions} options FlashOptions to configure how and what to write into flash.\n     */\n    async writeFlash(options) {\n        this.debug(\"EspLoader program\");\n        if (options.flashSize !== \"keep\") {\n            const flashEnd = this.flashSizeBytes(options.flashSize);\n            for (let i = 0; i < options.fileArray.length; i++) {\n                if (options.fileArray[i].data.length + options.fileArray[i].address > flashEnd) {\n                    throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(`File ${i + 1} doesn't fit in the available flash`);\n                }\n            }\n        }\n        if (this.IS_STUB === true && options.eraseAll === true) {\n            await this.eraseFlash();\n        }\n        let image, address;\n        for (let i = 0; i < options.fileArray.length; i++) {\n            this.debug(\"Data Length \" + options.fileArray[i].data.length);\n            image = options.fileArray[i].data;\n            this.debug(\"Image Length \" + image.length);\n            if (image.length === 0) {\n                this.debug(\"Warning: File is empty\");\n                continue;\n            }\n            image = this.ui8ToBstr((0,_util_js__WEBPACK_IMPORTED_MODULE_5__.padTo)(this.bstrToUi8(image), 4));\n            address = options.fileArray[i].address;\n            image = this._updateImageFlashParams(image, address, options.flashSize, options.flashMode, options.flashFreq);\n            let calcmd5 = null;\n            if (options.calculateMD5Hash) {\n                calcmd5 = options.calculateMD5Hash(image);\n                this.debug(\"Image MD5 \" + calcmd5);\n            }\n            const uncsize = image.length;\n            let blocks;\n            if (options.compress) {\n                const uncimage = this.bstrToUi8(image);\n                image = this.ui8ToBstr((0,pako__WEBPACK_IMPORTED_MODULE_1__.deflate)(uncimage, { level: 9 }));\n                blocks = await this.flashDeflBegin(uncsize, image.length, address);\n            }\n            else {\n                blocks = await this.flashBegin(uncsize, address);\n            }\n            let seq = 0;\n            let bytesSent = 0;\n            const totalBytes = image.length;\n            if (options.reportProgress)\n                options.reportProgress(i, 0, totalBytes);\n            let d = new Date();\n            const t1 = d.getTime();\n            let timeout = 5000;\n            // Create a decompressor to keep track of the size of uncompressed data\n            // to be written in each chunk.\n            const inflate = new pako__WEBPACK_IMPORTED_MODULE_1__.Inflate({ chunkSize: 1 });\n            let totalLenUncompressed = 0;\n            inflate.onData = function (chunk) {\n                totalLenUncompressed += chunk.byteLength;\n            };\n            while (image.length > 0) {\n                this.debug(\"Write loop \" + address + \" \" + seq + \" \" + blocks);\n                this.info(\"Writing at 0x\" +\n                    (address + totalLenUncompressed).toString(16) +\n                    \"... (\" +\n                    Math.floor((100 * (seq + 1)) / blocks) +\n                    \"%)\");\n                const block = this.bstrToUi8(image.slice(0, this.FLASH_WRITE_SIZE));\n                if (options.compress) {\n                    const lenUncompressedPrevious = totalLenUncompressed;\n                    inflate.push(block, false);\n                    const blockUncompressed = totalLenUncompressed - lenUncompressedPrevious;\n                    let blockTimeout = 3000;\n                    if (this.timeoutPerMb(this.ERASE_WRITE_TIMEOUT_PER_MB, blockUncompressed) > 3000) {\n                        blockTimeout = this.timeoutPerMb(this.ERASE_WRITE_TIMEOUT_PER_MB, blockUncompressed);\n                    }\n                    if (this.IS_STUB === false) {\n                        // ROM code writes block to flash before ACKing\n                        timeout = blockTimeout;\n                    }\n                    await this.flashDeflBlock(block, seq, timeout);\n                    if (this.IS_STUB) {\n                        // Stub ACKs when block is received, then writes to flash while receiving the block after it\n                        timeout = blockTimeout;\n                    }\n                }\n                else {\n                    throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Yet to handle Non Compressed writes\");\n                }\n                bytesSent += block.length;\n                image = image.slice(this.FLASH_WRITE_SIZE, image.length);\n                seq++;\n                if (options.reportProgress)\n                    options.reportProgress(i, bytesSent, totalBytes);\n            }\n            if (this.IS_STUB) {\n                await this.readReg(this.CHIP_DETECT_MAGIC_REG_ADDR, timeout);\n            }\n            d = new Date();\n            const t = d.getTime() - t1;\n            if (options.compress) {\n                this.info(\"Wrote \" +\n                    uncsize +\n                    \" bytes (\" +\n                    bytesSent +\n                    \" compressed) at 0x\" +\n                    address.toString(16) +\n                    \" in \" +\n                    t / 1000 +\n                    \" seconds.\");\n            }\n            if (calcmd5) {\n                const res = await this.flashMd5sum(address, uncsize);\n                if (new String(res).valueOf() != new String(calcmd5).valueOf()) {\n                    this.info(\"File  md5: \" + calcmd5);\n                    this.info(\"Flash md5: \" + res);\n                    throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"MD5 of file does not match data in flash!\");\n                }\n                else {\n                    this.info(\"Hash of data verified.\");\n                }\n            }\n        }\n        this.info(\"Leaving...\");\n        if (this.IS_STUB) {\n            await this.flashBegin(0, 0);\n            if (options.compress) {\n                await this.flashDeflFinish();\n            }\n            else {\n                await this.flashFinish();\n            }\n        }\n    }\n    /**\n     * Read SPI flash manufacturer and device id.\n     */\n    async flashId() {\n        this.debug(\"flash_id\");\n        const flashid = await this.readFlashId();\n        this.info(\"Manufacturer: \" + (flashid & 0xff).toString(16));\n        const flidLowbyte = (flashid >> 16) & 0xff;\n        this.info(\"Device: \" + ((flashid >> 8) & 0xff).toString(16) + flidLowbyte.toString(16));\n        this.info(\"Detected flash size: \" + this.DETECTED_FLASH_SIZES[flidLowbyte]);\n    }\n    async getFlashSize() {\n        this.debug(\"flash_id\");\n        const flashid = await this.readFlashId();\n        const flidLowbyte = (flashid >> 16) & 0xff;\n        return this.DETECTED_FLASH_SIZES_NUM[flidLowbyte];\n    }\n    /**\n     * Soft reset the device chip. Soft reset with run user code is the closest.\n     * @param {boolean} stayInBootloader Flag to indicate if to stay in bootloader\n     */\n    async softReset(stayInBootloader) {\n        if (!this.IS_STUB) {\n            if (stayInBootloader) {\n                return; // ROM bootloader is already in bootloader!\n            }\n            // \"run user code\" is as close to a soft reset as we can do\n            await this.flashBegin(0, 0);\n            await this.flashFinish(false);\n        }\n        else if (this.chip.CHIP_NAME != \"ESP8266\") {\n            throw new _types_error_js__WEBPACK_IMPORTED_MODULE_0__.ESPError(\"Soft resetting is currently only supported on ESP8266\");\n        }\n        else {\n            if (stayInBootloader) {\n                // soft resetting from the stub loader\n                // will re-load the ROM bootloader\n                await this.flashBegin(0, 0);\n                await this.flashFinish(true);\n            }\n            else {\n                // running user code from stub loader requires some hacks\n                // in the stub loader\n                await this.command(this.ESP_RUN_USER_CODE, undefined, undefined, false);\n            }\n        }\n    }\n    /**\n     * Execute this function to execute after operation reset functions.\n     * @param {After} mode After operation mode. Default is 'hard_reset'.\n     * @param { boolean } usingUsbOtg For 'hard_reset' to specify if using USB-OTG\n     */\n    async after(mode = \"hard_reset\", usingUsbOtg) {\n        switch (mode) {\n            case \"hard_reset\":\n                if (this.resetConstructors.hardReset) {\n                    this.info(\"Hard resetting via RTS pin...\");\n                    const hardReset = this.resetConstructors.hardReset(this.transport, usingUsbOtg);\n                    await hardReset.reset();\n                }\n                break;\n            case \"soft_reset\":\n                this.info(\"Soft resetting...\");\n                await this.softReset(false);\n                break;\n            case \"no_reset_stub\":\n                this.info(\"Staying in flasher stub.\");\n                break;\n            default:\n                this.info(\"Staying in bootloader.\");\n                if (this.IS_STUB) {\n                    this.softReset(true);\n                }\n                break;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvZXNwbG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDSjtBQUNHO0FBQzJDO0FBQzdCO0FBQ3ZCO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsUUFBUSx1TUFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLFFBQVEsMk1BQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLFFBQVEsMk1BQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLFFBQVEsMk1BQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxRQUFRLDZNQUErQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWEsUUFBUSwyTUFBOEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxRQUFRLDJNQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxRQUFRLDJNQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxRQUFRLDJNQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxRQUFRLDJNQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWEsUUFBUSwyTUFBOEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSx3Q0FBd0MsdUVBQXVFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL2VzcGxvYWRlci5qcz83ZTc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVTUEVycm9yIH0gZnJvbSBcIi4vdHlwZXMvZXJyb3IuanNcIjtcbmltcG9ydCB7IGRlZmxhdGUsIEluZmxhdGUgfSBmcm9tIFwicGFrb1wiO1xuaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4vd2Vic2VyaWFsLmpzXCI7XG5pbXBvcnQgeyBDbGFzc2ljUmVzZXQsIEN1c3RvbVJlc2V0LCBIYXJkUmVzZXQsIFVzYkp0YWdTZXJpYWxSZXNldCB9IGZyb20gXCIuL3Jlc2V0LmpzXCI7XG5pbXBvcnQgeyBnZXRTdHViSnNvbkJ5Q2hpcE5hbWUgfSBmcm9tIFwiLi9zdHViRmxhc2hlci5qc1wiO1xuaW1wb3J0IHsgcGFkVG8gfSBmcm9tIFwiLi91dGlsLmpzXCI7XG4vKipcbiAqIFJldHVybiB0aGUgY2hpcCBST00gYmFzZWQgb24gdGhlIGdpdmVuIG1hZ2ljIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IG1hZ2ljIC0gbWFnaWMgaGV4IG51bWJlciB0byBzZWxlY3QgUk9NLlxuICogQHJldHVybnMge1JPTX0gVGhlIGNoaXAgUk9NIGNsYXNzIHJlbGF0ZWQgdG8gZ2l2ZW4gbWFnaWMgaGV4IG51bWJlci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFnaWMyQ2hpcChtYWdpYykge1xuICAgIHN3aXRjaCAobWFnaWMpIHtcbiAgICAgICAgY2FzZSAweDAwZjAxZDgzOiB7XG4gICAgICAgICAgICBjb25zdCB7IEVTUDMyUk9NIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvZXNwMzIuanNcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVTUDMyUk9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAweGMyMWUwNmY6XG4gICAgICAgIGNhc2UgMHg2ZjUxMzA2ZjpcbiAgICAgICAgY2FzZSAweDdjNDFhMDZmOiB7XG4gICAgICAgICAgICBjb25zdCB7IEVTUDMyQzJST00gfSA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9lc3AzMmMyLmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFU1AzMkMyUk9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAweDY5MjE1MDZmOlxuICAgICAgICBjYXNlIDB4MWIzMTUwNmY6XG4gICAgICAgIGNhc2UgMHg0ODgxNjA2ZjpcbiAgICAgICAgY2FzZSAweDQzNjE2MDZmOiB7XG4gICAgICAgICAgICBjb25zdCB7IEVTUDMyQzNST00gfSA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9lc3AzMmMzLmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFU1AzMkMzUk9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAweDJjZTA4MDZmOiB7XG4gICAgICAgICAgICBjb25zdCB7IEVTUDMyQzZST00gfSA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9lc3AzMmM2LmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFU1AzMkM2Uk9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAweDI0MjE2MDZmOlxuICAgICAgICBjYXNlIDB4MzNmMDIwNmY6XG4gICAgICAgIGNhc2UgMHg0ZjgxNjA2Zjoge1xuICAgICAgICAgICAgY29uc3QgeyBFU1AzMkM2MVJPTSB9ID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL2VzcDMyYzYxLmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFU1AzMkM2MVJPTSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMHgxMTAxNDA2ZjpcbiAgICAgICAgY2FzZSAweDYzZTE0MDZmOlxuICAgICAgICBjYXNlIDB4NWZkMTQwNmY6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRVNQMzJDNVJPTSB9ID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL2VzcDMyYzUuanNcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVTUDMyQzVST00oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDB4ZDdiNzNlODA6XG4gICAgICAgIGNhc2UgMHg5N2UzMDA2ODoge1xuICAgICAgICAgICAgY29uc3QgeyBFU1AzMkgyUk9NIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvZXNwMzJoMi5qc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRVNQMzJIMlJPTSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMHgwOToge1xuICAgICAgICAgICAgY29uc3QgeyBFU1AzMlMzUk9NIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvZXNwMzJzMy5qc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRVNQMzJTM1JPTSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMHgwMDAwMDdjNjoge1xuICAgICAgICAgICAgY29uc3QgeyBFU1AzMlMyUk9NIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvZXNwMzJzMi5qc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRVNQMzJTMlJPTSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMHhmZmYwYzEwMToge1xuICAgICAgICAgICAgY29uc3QgeyBFU1A4MjY2Uk9NIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvZXNwODI2Ni5qc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRVNQODI2NlJPTSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMHgwOlxuICAgICAgICBjYXNlIDB4MGFkZGJhZDA6XG4gICAgICAgIGNhc2UgMHg3MDM5YWQ5OiB7XG4gICAgICAgICAgICBjb25zdCB7IEVTUDMyUDRST00gfSA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9lc3AzMnA0LmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFU1AzMlA0Uk9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFU1BMb2FkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBFU1BMb2FkZXIgdG8gcGVyZm9ybSBzZXJpYWwgY29tbXVuaWNhdGlvblxuICAgICAqIHN1Y2ggYXMgcmVhZC93cml0ZSBmbGFzaCBtZW1vcnkgYW5kIHJlZ2lzdGVycyB1c2luZyBhIExvYWRlck9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TG9hZGVyT3B0aW9uc30gb3B0aW9ucyAtIExvYWRlck9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGZvciBFU1BMb2FkZXIuXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbXlMb2FkZXIgPSBuZXcgRVNQTG9hZGVyKHsgdHJhbnNwb3J0OiBUcmFuc3BvcnQsIGJhdWRyYXRlOiBudW1iZXIsIHRlcm1pbmFsPzogSUVzcExvYWRlclRlcm1pbmFsIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgdGhpcy5FU1BfUkFNX0JMT0NLID0gMHgxODAwO1xuICAgICAgICB0aGlzLkVTUF9GTEFTSF9CRUdJTiA9IDB4MDI7XG4gICAgICAgIHRoaXMuRVNQX0ZMQVNIX0RBVEEgPSAweDAzO1xuICAgICAgICB0aGlzLkVTUF9GTEFTSF9FTkQgPSAweDA0O1xuICAgICAgICB0aGlzLkVTUF9NRU1fQkVHSU4gPSAweDA1O1xuICAgICAgICB0aGlzLkVTUF9NRU1fRU5EID0gMHgwNjtcbiAgICAgICAgdGhpcy5FU1BfTUVNX0RBVEEgPSAweDA3O1xuICAgICAgICB0aGlzLkVTUF9XUklURV9SRUcgPSAweDA5O1xuICAgICAgICB0aGlzLkVTUF9SRUFEX1JFRyA9IDB4MGE7XG4gICAgICAgIHRoaXMuRVNQX1NQSV9BVFRBQ0ggPSAweDBkO1xuICAgICAgICB0aGlzLkVTUF9DSEFOR0VfQkFVRFJBVEUgPSAweDBmO1xuICAgICAgICB0aGlzLkVTUF9GTEFTSF9ERUZMX0JFR0lOID0gMHgxMDtcbiAgICAgICAgdGhpcy5FU1BfRkxBU0hfREVGTF9EQVRBID0gMHgxMTtcbiAgICAgICAgdGhpcy5FU1BfRkxBU0hfREVGTF9FTkQgPSAweDEyO1xuICAgICAgICB0aGlzLkVTUF9TUElfRkxBU0hfTUQ1ID0gMHgxMztcbiAgICAgICAgLy8gT25seSBTdHViIHN1cHBvcnRlZCBjb21tYW5kc1xuICAgICAgICB0aGlzLkVTUF9FUkFTRV9GTEFTSCA9IDB4ZDA7XG4gICAgICAgIHRoaXMuRVNQX0VSQVNFX1JFR0lPTiA9IDB4ZDE7XG4gICAgICAgIHRoaXMuRVNQX1JFQURfRkxBU0ggPSAweGQyO1xuICAgICAgICB0aGlzLkVTUF9SVU5fVVNFUl9DT0RFID0gMHhkMztcbiAgICAgICAgdGhpcy5FU1BfSU1BR0VfTUFHSUMgPSAweGU5O1xuICAgICAgICB0aGlzLkVTUF9DSEVDS1NVTV9NQUdJQyA9IDB4ZWY7XG4gICAgICAgIC8vIFJlc3BvbnNlIGNvZGUocykgc2VudCBieSBST01cbiAgICAgICAgdGhpcy5ST01fSU5WQUxJRF9SRUNWX01TRyA9IDB4MDU7IC8vIHJlc3BvbnNlIGlmIGFuIGludmFsaWQgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgICAgICB0aGlzLkRFRkFVTFRfVElNRU9VVCA9IDMwMDA7XG4gICAgICAgIHRoaXMuRVJBU0VfUkVHSU9OX1RJTUVPVVRfUEVSX01CID0gMzAwMDA7XG4gICAgICAgIHRoaXMuRVJBU0VfV1JJVEVfVElNRU9VVF9QRVJfTUIgPSA0MDAwMDtcbiAgICAgICAgdGhpcy5NRDVfVElNRU9VVF9QRVJfTUIgPSA4MDAwO1xuICAgICAgICB0aGlzLkNISVBfRVJBU0VfVElNRU9VVCA9IDEyMDAwMDtcbiAgICAgICAgdGhpcy5GTEFTSF9SRUFEX1RJTUVPVVQgPSAxMDAwMDA7XG4gICAgICAgIHRoaXMuTUFYX1RJTUVPVVQgPSB0aGlzLkNISVBfRVJBU0VfVElNRU9VVCAqIDI7XG4gICAgICAgIHRoaXMuQ0hJUF9ERVRFQ1RfTUFHSUNfUkVHX0FERFIgPSAweDQwMDAxMDAwO1xuICAgICAgICB0aGlzLkRFVEVDVEVEX0ZMQVNIX1NJWkVTID0ge1xuICAgICAgICAgICAgMHgxMjogXCIyNTZLQlwiLFxuICAgICAgICAgICAgMHgxMzogXCI1MTJLQlwiLFxuICAgICAgICAgICAgMHgxNDogXCIxTUJcIixcbiAgICAgICAgICAgIDB4MTU6IFwiMk1CXCIsXG4gICAgICAgICAgICAweDE2OiBcIjRNQlwiLFxuICAgICAgICAgICAgMHgxNzogXCI4TUJcIixcbiAgICAgICAgICAgIDB4MTg6IFwiMTZNQlwiLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLkRFVEVDVEVEX0ZMQVNIX1NJWkVTX05VTSA9IHtcbiAgICAgICAgICAgIDB4MTI6IDI1NixcbiAgICAgICAgICAgIDB4MTM6IDUxMixcbiAgICAgICAgICAgIDB4MTQ6IDEwMjQsXG4gICAgICAgICAgICAweDE1OiAyMDQ4LFxuICAgICAgICAgICAgMHgxNjogNDA5NixcbiAgICAgICAgICAgIDB4MTc6IDgxOTIsXG4gICAgICAgICAgICAweDE4OiAxNjM4NCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5VU0JfSlRBR19TRVJJQUxfUElEID0gMHgxMDAxO1xuICAgICAgICB0aGlzLnJvbUJhdWRyYXRlID0gMTE1MjAwO1xuICAgICAgICB0aGlzLmRlYnVnTG9nZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNTdHViRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmbGFzaCBzaXplIGJ5dGVzIGZyb20gZmxhc2ggc2l6ZSBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFzaFNpemUgRmxhc2ggU2l6ZSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gRmxhc2ggc2l6ZSBieXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFzaFNpemVCeXRlcyA9IGZ1bmN0aW9uIChmbGFzaFNpemUpIHtcbiAgICAgICAgICAgIGxldCBmbGFzaFNpemVCID0gLTE7XG4gICAgICAgICAgICBpZiAoZmxhc2hTaXplLmluZGV4T2YoXCJLQlwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmbGFzaFNpemVCID0gcGFyc2VJbnQoZmxhc2hTaXplLnNsaWNlKDAsIGZsYXNoU2l6ZS5pbmRleE9mKFwiS0JcIikpKSAqIDEwMjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmbGFzaFNpemUuaW5kZXhPZihcIk1CXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZsYXNoU2l6ZUIgPSBwYXJzZUludChmbGFzaFNpemUuc2xpY2UoMCwgZmxhc2hTaXplLmluZGV4T2YoXCJNQlwiKSkpICogMTAyNCAqIDEwMjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhc2hTaXplQjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5JU19TVFVCID0gZmFsc2U7XG4gICAgICAgIHRoaXMuRkxBU0hfV1JJVEVfU0laRSA9IDB4NDAwMDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5iYXVkcmF0ZSA9IG9wdGlvbnMuYmF1ZHJhdGU7XG4gICAgICAgIHRoaXMucmVzZXRDb25zdHJ1Y3RvcnMgPSB7XG4gICAgICAgICAgICBjbGFzc2ljUmVzZXQ6ICh0cmFuc3BvcnQsIHJlc2V0RGVsYXkpID0+IG5ldyBDbGFzc2ljUmVzZXQodHJhbnNwb3J0LCByZXNldERlbGF5KSxcbiAgICAgICAgICAgIGN1c3RvbVJlc2V0OiAodHJhbnNwb3J0LCBzZXF1ZW5jZVN0cmluZykgPT4gbmV3IEN1c3RvbVJlc2V0KHRyYW5zcG9ydCwgc2VxdWVuY2VTdHJpbmcpLFxuICAgICAgICAgICAgaGFyZFJlc2V0OiAodHJhbnNwb3J0LCB1c2luZ1VzYk90ZykgPT4gbmV3IEhhcmRSZXNldCh0cmFuc3BvcnQsIHVzaW5nVXNiT3RnKSxcbiAgICAgICAgICAgIHVzYkpUQUdTZXJpYWxSZXNldDogKHRyYW5zcG9ydCkgPT4gbmV3IFVzYkp0YWdTZXJpYWxSZXNldCh0cmFuc3BvcnQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5zZXJpYWxPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbE9wdGlvbnMgPSBvcHRpb25zLnNlcmlhbE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucm9tQmF1ZHJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucm9tQmF1ZHJhdGUgPSBvcHRpb25zLnJvbUJhdWRyYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRlcm1pbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmFsID0gb3B0aW9ucy50ZXJtaW5hbDtcbiAgICAgICAgICAgIHRoaXMudGVybWluYWwuY2xlYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVidWdMb2dnaW5nICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2luZyA9IG9wdGlvbnMuZGVidWdMb2dnaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydChvcHRpb25zLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lbmFibGVUcmFjaW5nICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC50cmFjaW5nID0gb3B0aW9ucy5lbmFibGVUcmFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2EgPSBvcHRpb25zLnJlc2V0Q29uc3RydWN0b3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NpY1Jlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q29uc3RydWN0b3JzLmNsYXNzaWNSZXNldCA9IChfYiA9IG9wdGlvbnMucmVzZXRDb25zdHJ1Y3RvcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzc2ljUmVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYyA9IG9wdGlvbnMucmVzZXRDb25zdHJ1Y3RvcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXN0b21SZXNldCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldENvbnN0cnVjdG9ycy5jdXN0b21SZXNldCA9IChfZCA9IG9wdGlvbnMucmVzZXRDb25zdHJ1Y3RvcnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jdXN0b21SZXNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9lID0gb3B0aW9ucy5yZXNldENvbnN0cnVjdG9ycykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmhhcmRSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldENvbnN0cnVjdG9ycy5oYXJkUmVzZXQgPSAoX2YgPSBvcHRpb25zLnJlc2V0Q29uc3RydWN0b3JzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaGFyZFJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2cgPSBvcHRpb25zLnJlc2V0Q29uc3RydWN0b3JzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudXNiSlRBR1NlcmlhbFJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q29uc3RydWN0b3JzLnVzYkpUQUdTZXJpYWxSZXNldCA9IChfaCA9IG9wdGlvbnMucmVzZXRDb25zdHJ1Y3RvcnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC51c2JKVEFHU2VyaWFsUmVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvKFwiZXNwdG9vbC5qc1wiKTtcbiAgICAgICAgdGhpcy5pbmZvKFwiU2VyaWFsIHBvcnQgXCIgKyB0aGlzLnRyYW5zcG9ydC5nZXRJbmZvKCkpO1xuICAgIH1cbiAgICBfc2xlZXAobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIEVTUCBMb2FkZXIgY29uc3RydWN0b3IncyB0ZXJtaW5hbCB3aXRoIG9yIHdpdGhvdXQgbmV3IGxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhOZXdsaW5lIC0gQWRkIG5ldyBsaW5lIGF0IHRoZSBlbmQgP1xuICAgICAqL1xuICAgIHdyaXRlKHN0ciwgd2l0aE5ld2xpbmUgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRlcm1pbmFsKSB7XG4gICAgICAgICAgICBpZiAod2l0aE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmFsLndyaXRlTGluZShzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hbC53cml0ZShzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgZXJyb3IgbWVzc2FnZSB0byBFU1AgTG9hZGVyIGNvbnN0cnVjdG9yJ3MgdGVybWluYWwgd2l0aCBvciB3aXRob3V0IG5ldyBsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoTmV3bGluZSAtIEFkZCBuZXcgbGluZSBhdCB0aGUgZW5kID9cbiAgICAgKi9cbiAgICBlcnJvcihzdHIsIHdpdGhOZXdsaW5lID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLndyaXRlKGBFcnJvcjogJHtzdHJ9YCwgd2l0aE5ld2xpbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBpbmZvcm1hdGlvbiBtZXNzYWdlIHRvIEVTUCBMb2FkZXIgY29uc3RydWN0b3IncyB0ZXJtaW5hbCB3aXRoIG9yIHdpdGhvdXQgbmV3IGxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhOZXdsaW5lIC0gQWRkIG5ldyBsaW5lIGF0IHRoZSBlbmQgP1xuICAgICAqL1xuICAgIGluZm8oc3RyLCB3aXRoTmV3bGluZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShzdHIsIHdpdGhOZXdsaW5lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgZGVidWcgbWVzc2FnZSB0byBFU1AgTG9hZGVyIGNvbnN0cnVjdG9yJ3MgdGVybWluYWwgd2l0aCBvciB3aXRob3V0IG5ldyBsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoTmV3bGluZSAtIEFkZCBuZXcgbGluZSBhdCB0aGUgZW5kID9cbiAgICAgKi9cbiAgICBkZWJ1ZyhzdHIsIHdpdGhOZXdsaW5lID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z0xvZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoYERlYnVnOiAke3N0cn1gLCB3aXRoTmV3bGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBzaG9ydCBpbnRlZ2VyIHRvIGJ5dGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSAtIE51bWJlciB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCeXRlIGFycmF5LlxuICAgICAqL1xuICAgIF9zaG9ydFRvQnl0ZWFycmF5KGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtpICYgMHhmZiwgKGkgPj4gOCkgJiAweGZmXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gaW50ZWdlciB0byBieXRlIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgLSBOdW1iZXIgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7Uk9NfSBUaGUgY2hpcCBST00gY2xhc3MgcmVsYXRlZCB0byBnaXZlbiBtYWdpYyBoZXggbnVtYmVyLlxuICAgICAqL1xuICAgIF9pbnRUb0J5dGVBcnJheShpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbaSAmIDB4ZmYsIChpID4+IDgpICYgMHhmZiwgKGkgPj4gMTYpICYgMHhmZiwgKGkgPj4gMjQpICYgMHhmZl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBzaG9ydCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gTnVtYmVyIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGogLSBOdW1iZXIgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm4gYSBzaG9ydCBpbnRlZ2VyIG51bWJlci5cbiAgICAgKi9cbiAgICBfYnl0ZUFycmF5VG9TaG9ydChpLCBqKSB7XG4gICAgICAgIHJldHVybiBpIHwgKGogPj4gOCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgLSBOdW1iZXIgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaiAtIE51bWJlciB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrIC0gTnVtYmVyIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGwgLSBOdW1iZXIgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm4gYSBpbnRlZ2VyIG51bWJlci5cbiAgICAgKi9cbiAgICBfYnl0ZUFycmF5VG9JbnQoaSwgaiwgaywgbCkge1xuICAgICAgICByZXR1cm4gaSB8IChqIDw8IDgpIHwgKGsgPDwgMTYpIHwgKGwgPDwgMjQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBidWZmZXIgYXJyYXkgYWZ0ZXIgYW5vdGhlciBidWZmZXIgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIxIC0gRmlyc3QgYXJyYXkgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlcjIgLSBtYWdpYyBoZXggbnVtYmVyIHRvIHNlbGVjdCBST00uXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyTGlrZX0gUmV0dXJuIGFuIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBfYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChuZXcgVWludDhBcnJheShidWZmZXIxKSwgMCk7XG4gICAgICAgIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0bXAuYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBidWZmZXIgYXJyYXkgYWZ0ZXIgYW5vdGhlciBidWZmZXIgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycjEgLSBGaXJzdCBhcnJheSBidWZmZXIuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIyIC0gbWFnaWMgaGV4IG51bWJlciB0byBzZWxlY3QgUk9NLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBSZXR1cm4gYSA4IGJpdCB1bnNpZ25lZCBhcnJheS5cbiAgICAgKi9cbiAgICBfYXBwZW5kQXJyYXkoYXJyMSwgYXJyMikge1xuICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYXJyMS5sZW5ndGggKyBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGMuc2V0KGFycjEsIDApO1xuICAgICAgICBjLnNldChhcnIyLCBhcnIxLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdW5zaWduZWQgOCBiaXQgaW50ZWdlciBhcnJheSB0byBieXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHU4QXJyYXkgLSBtYWdpYyBoZXggbnVtYmVyIHRvIHNlbGVjdCBST00uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJuIHRoZSBlcXVpdmFsZW50IHN0cmluZy5cbiAgICAgKi9cbiAgICB1aThUb0JzdHIodThBcnJheSkge1xuICAgICAgICBsZXQgYlN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdThBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYlN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHU4QXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiU3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgYnl0ZSBzdHJpbmcgdG8gdW5zaWduZWQgOCBiaXQgaW50ZWdlciBhcnJheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYlN0ciAtIGJpbmFyeSBzdHJpbmcgaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gUmV0dXJuIGEgOCBiaXQgdW5zaWduZWQgaW50ZWdlciBhcnJheS5cbiAgICAgKi9cbiAgICBic3RyVG9VaTgoYlN0cikge1xuICAgICAgICBjb25zdCB1OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYlN0ci5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHU4QXJyYXlbaV0gPSBiU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU4QXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHRoZSBzZXJpYWwgaW5wdXQgYnkgcmF3IHJlYWQgd2l0aCAyMDAgbXMgdGltZW91dC5cbiAgICAgKi9cbiAgICBhc3luYyBmbHVzaElucHV0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuZmx1c2hJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBkZXZpY2Ugc2VyaWFsIHBvcnQgcmVhZCBmdW5jdGlvbiB3aXRoIGdpdmVuIHRpbWVvdXQgdG8gY3JlYXRlIGEgdmFsaWQgcGFja2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcCBPcGVyYXRpb24gbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgdGltZW91dCBudW1iZXIgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge1tudW1iZXIsIFVpbnQ4QXJyYXldfSB2YWxpZCByZXNwb25zZSBwYWNrZXQuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZFBhY2tldChvcCA9IG51bGwsIHRpbWVvdXQgPSB0aGlzLkRFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICAvLyBDaGVjayB1cC10byBuZXh0IDEwMCBwYWNrZXRzIGZvciB2YWxpZCByZXNwb25zZSBwYWNrZXRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcCB9ID0gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVhZCh0aW1lb3V0KS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIXAgfHwgcC5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwID0gcFswXTtcbiAgICAgICAgICAgIGlmIChyZXNwICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcFJldCA9IHBbMV07XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9ieXRlQXJyYXlUb0ludChwWzRdLCBwWzVdLCBwWzZdLCBwWzddKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwLnNsaWNlKDgpO1xuICAgICAgICAgICAgaWYgKHJlc3AgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChvcCA9PSBudWxsIHx8IG9wUmV0ID09IG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmFsLCBkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVswXSAhPSAwICYmIGRhdGFbMV0gPT0gdGhpcy5ST01fSU5WQUxJRF9SRUNWX01TRykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZsdXNoSW5wdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKFwidW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBzZXJpYWwgY29tbWFuZCB0byB0aGUgY2hpcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcCAtIE9wZXJhdGlvbiBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBVbnNpZ25lZCA4IGJpdCBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGsgLSBjaGFubmVsIG51bWJlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FpdFJlc3BvbnNlIC0gd2FpdCBmb3IgcmVzcG9uc2UgP1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gdGltZW91dCBudW1iZXIgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8W251bWJlciwgVWludDhBcnJheV0+fSBSZXR1cm4gYSBudW1iZXIgYW5kIGEgOCBiaXQgdW5zaWduZWQgaW50ZWdlciBhcnJheS5cbiAgICAgKi9cbiAgICBhc3luYyBjb21tYW5kKG9wID0gbnVsbCwgZGF0YSA9IG5ldyBVaW50OEFycmF5KDApLCBjaGsgPSAwLCB3YWl0UmVzcG9uc2UgPSB0cnVlLCB0aW1lb3V0ID0gdGhpcy5ERUZBVUxUX1RJTUVPVVQpIHtcbiAgICAgICAgaWYgKG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydC50cmFjaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQudHJhY2UoYGNvbW1hbmQgb3A6MHgke29wLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIil9IGRhdGEgbGVuPSR7ZGF0YS5sZW5ndGh9IHdhaXRfcmVzcG9uc2U9JHt3YWl0UmVzcG9uc2UgPyAxIDogMH0gdGltZW91dD0keyh0aW1lb3V0IC8gMTAwMCkudG9GaXhlZCgzKX0gZGF0YT0ke3RoaXMudHJhbnNwb3J0LmhleENvbnZlcnQoZGF0YSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwa3QgPSBuZXcgVWludDhBcnJheSg4ICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcGt0WzBdID0gMHgwMDtcbiAgICAgICAgICAgIHBrdFsxXSA9IG9wO1xuICAgICAgICAgICAgcGt0WzJdID0gdGhpcy5fc2hvcnRUb0J5dGVhcnJheShkYXRhLmxlbmd0aClbMF07XG4gICAgICAgICAgICBwa3RbM10gPSB0aGlzLl9zaG9ydFRvQnl0ZWFycmF5KGRhdGEubGVuZ3RoKVsxXTtcbiAgICAgICAgICAgIHBrdFs0XSA9IHRoaXMuX2ludFRvQnl0ZUFycmF5KGNoaylbMF07XG4gICAgICAgICAgICBwa3RbNV0gPSB0aGlzLl9pbnRUb0J5dGVBcnJheShjaGspWzFdO1xuICAgICAgICAgICAgcGt0WzZdID0gdGhpcy5faW50VG9CeXRlQXJyYXkoY2hrKVsyXTtcbiAgICAgICAgICAgIHBrdFs3XSA9IHRoaXMuX2ludFRvQnl0ZUFycmF5KGNoaylbM107XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGt0WzggKyBpXSA9IGRhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC53cml0ZShwa3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2FpdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIG5ldyBVaW50OEFycmF5KDApXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkUGFja2V0KG9wLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIHJlZ2lzdGVyIGZyb20gY2hpcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkciAtIFJlZ2lzdGVyIGFkZHJlc3MgbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyAoRGVmYXVsdDogMzAwMG1zKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQ29tbWFuZCBudW1iZXIgdmFsdWVcbiAgICAgKi9cbiAgICBhc3luYyByZWFkUmVnKGFkZHIsIHRpbWVvdXQgPSB0aGlzLkRFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICBjb25zdCBwa3QgPSB0aGlzLl9pbnRUb0J5dGVBcnJheShhZGRyKTtcbiAgICAgICAgY29uc3QgdmFsID0gYXdhaXQgdGhpcy5jb21tYW5kKHRoaXMuRVNQX1JFQURfUkVHLCBwa3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIHZhbFswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBudW1iZXIgdmFsdWUgdG8gcmVnaXN0ZXIgYWRkcmVzcyBpbiBjaGlwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRyIC0gUmVnaXN0ZXIgYWRkcmVzcyBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gd3JpdGUgaW4gcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFzayAtIEhleCBudW1iZXIgZm9yIG1hc2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlVcyBEZWxheSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlBZnRlclVzIERlbGF5IGFmdGVyIHByZXZpb3VzIGRlbGF5XG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVSZWcoYWRkciwgdmFsdWUsIG1hc2sgPSAweGZmZmZmZmZmLCBkZWxheVVzID0gMCwgZGVsYXlBZnRlclVzID0gMCkge1xuICAgICAgICBsZXQgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoYWRkciksIHRoaXMuX2ludFRvQnl0ZUFycmF5KHZhbHVlKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkobWFzaykpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KGRlbGF5VXMpKTtcbiAgICAgICAgaWYgKGRlbGF5QWZ0ZXJVcyA+IDApIHtcbiAgICAgICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkodGhpcy5jaGlwLlVBUlRfREFURV9SRUdfQUREUikpO1xuICAgICAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCB0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7XG4gICAgICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKTtcbiAgICAgICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkoZGVsYXlBZnRlclVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoXCJ3cml0ZSB0YXJnZXQgbWVtb3J5XCIsIHRoaXMuRVNQX1dSSVRFX1JFRywgcGt0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luYyBjaGlwIGJ5IHNlbmRpbmcgc3luYyBjb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtbbnVtYmVyLCBVaW50OEFycmF5XX0gQ29tbWFuZCByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBzeW5jKCkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiU3luY1wiKTtcbiAgICAgICAgY29uc3QgY21kID0gbmV3IFVpbnQ4QXJyYXkoMzYpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY21kWzBdID0gMHgwNztcbiAgICAgICAgY21kWzFdID0gMHgwNztcbiAgICAgICAgY21kWzJdID0gMHgxMjtcbiAgICAgICAgY21kWzNdID0gMHgyMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGNtZFs0ICsgaV0gPSAweDU1O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzcCA9IGF3YWl0IHRoaXMuY29tbWFuZCgweDA4LCBjbWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAxMDApO1xuICAgICAgICAgICAgLy8gUk9NIGJvb3Rsb2FkZXJzIHNlbmQgc29tZSBub24temVybyBcInZhbFwiIHJlc3BvbnNlLiBUaGUgZmxhc2hlciBzdHViIHNlbmRzIDAuXG4gICAgICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIDAgdGhlbiBpdCBwcm9iYWJseSBpbmRpY2F0ZXMgdGhhdCB0aGUgY2hpcCB3YXNuJ3Qgb3IgY291bGRuJ3QgYmVcbiAgICAgICAgICAgIC8vIHJlc2V0IHByb3Blcmx5IGFuZCBlc3B0b29sIGlzIHRhbGtpbmcgdG8gdGhlIGZsYXNoZXIgc3R1Yi5cbiAgICAgICAgICAgIHRoaXMuc3luY1N0dWJEZXRlY3RlZCA9IHJlc3BbMF0gPT09IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBhd2FpdCB0aGlzLmNvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTdHViRGV0ZWN0ZWQgPSB0aGlzLnN5bmNTdHViRGV0ZWN0ZWQgJiYgcmVzcFswXSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiU3luYyBlcnIgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBjaGlwIGJ5IHNlbmRpbmcgYSByZXNldCBzZXF1ZW5jZSBhbmQgbGF0ZXIgYSBzeW5jIGNvbW1hbmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBSZXNldCBtb2RlIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7UmVzZXRTdHJhdGVneX0gcmVzZXRTdHJhdGVneSAtIFJlc2V0IHN0cmF0ZWd5IGNsYXNzIHRvIHVzZSBmb3IgY29ubmVjdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUmV0dXJucyAnc3VjY2Vzcycgb3IgJ2Vycm9yJyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIF9jb25uZWN0QXR0ZW1wdChtb2RlID0gXCJkZWZhdWx0X3Jlc2V0XCIsIHJlc2V0U3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIl9jb25uZWN0X2F0dGVtcHQgXCIgKyBtb2RlKTtcbiAgICAgICAgaWYgKHJlc2V0U3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlc2V0U3RyYXRlZ3kucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0aW5nQnl0ZXMgPSB0aGlzLnRyYW5zcG9ydC5pbldhaXRpbmcoKTtcbiAgICAgICAgY29uc3QgcmVhZEJ5dGVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnQubmV3UmVhZCh3YWl0aW5nQnl0ZXMgPiAwID8gd2FpdGluZ0J5dGVzIDogMSwgdGhpcy5ERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBBcnJheS5mcm9tKHJlYWRCeXRlcywgKGJ5dGUpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpLmpvaW4oXCJcIik7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL2Jvb3Q6KDB4WzAtOWEtZkEtRl0rKSguKndhaXRpbmcgZm9yIGRvd25sb2FkKT8vO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGJpbmFyeVN0cmluZy5tYXRjaChyZWdleCk7XG4gICAgICAgIGxldCBib290TG9nRGV0ZWN0ZWQgPSBmYWxzZSwgYm9vdE1vZGUgPSBcIlwiLCBkb3dubG9hZE1vZGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBib290TG9nRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYm9vdE1vZGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGRvd25sb2FkTW9kZSA9ICEhbWF0Y2hbMl07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RFcnJvciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYFN5bmMgY29ubmVjdCBhdHRlbXB0ICR7aX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5zeW5jKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhyZXNwWzBdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYEVycm9yIGF0IHN5bmMgJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChib290TG9nRGV0ZWN0ZWQpIHtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGBXcm9uZyBib290IG1vZGUgZGV0ZWN0ZWQgKCR7Ym9vdE1vZGV9KS5cbiAgICAgICAgVGhpcyBjaGlwIG5lZWRzIHRvIGJlIGluIGRvd25sb2FkIG1vZGUuYDtcbiAgICAgICAgICAgIGlmIChkb3dubG9hZE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBgRG93bmxvYWQgbW9kZSBzdWNjZXNzZnVsbHkgZGV0ZWN0ZWQsIGJ1dCBnZXR0aW5nIG5vIHN5bmMgcmVwbHk6XG4gICAgICAgICAgIFRoZSBzZXJpYWwgVFggcGF0aCBzZWVtcyB0byBiZSBkb3duLmA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RFcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIHNlcXVlbmNlIG9mIHJlc2V0IHN0cmF0ZWdpZXMgYmFzZWQgb24gdGhlIE9TLFxuICAgICAqIHVzZWQgRVNQIGNoaXAsIGV4dGVybmFsIHNldHRpbmdzLCBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAqIFJldHVybnMgYSB0dXBsZSBvZiBvbmUgb3IgbW9yZSByZXNldCBzdHJhdGVnaWVzIHRvIGJlIHRyaWVkIHNlcXVlbnRpYWxseS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIFJlc2V0IG1vZGUgdG8gdXNlXG4gICAgICogQHJldHVybnMge1Jlc2V0U3RyYXRlZ3lbXX0gLSBBcnJheSBvZiByZXNldCBzdHJhdGVnaWVzXG4gICAgICovXG4gICAgY29uc3RydWN0UmVzZXRTZXF1ZW5jZShtb2RlKSB7XG4gICAgICAgIGlmIChtb2RlICE9PSBcIm5vX3Jlc2V0XCIpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInVzYl9yZXNldFwiIHx8IHRoaXMudHJhbnNwb3J0LmdldFBpZCgpID09PSB0aGlzLlVTQl9KVEFHX1NFUklBTF9QSUQpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gcmVzZXQgc2VxdWVuY2UsIHdoaWNoIGlzIHJlcXVpcmVkIHdoZW4gdGhlIGRldmljZVxuICAgICAgICAgICAgICAgIC8vIGlzIGNvbm5lY3RpbmcgdmlhIGl0cyBVU0ItSlRBRy1TZXJpYWwgcGVyaXBoZXJhbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc2V0Q29uc3RydWN0b3JzLnVzYkpUQUdTZXJpYWxSZXNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwidXNpbmcgVVNCIEpUQUcgU2VyaWFsIFJlc2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMucmVzZXRDb25zdHJ1Y3RvcnMudXNiSlRBR1NlcmlhbFJlc2V0KHRoaXMudHJhbnNwb3J0KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgREVGQVVMVF9SRVNFVF9ERUxBWSA9IDUwO1xuICAgICAgICAgICAgICAgIGNvbnN0IEVYVFJBX0RFTEFZID0gREVGQVVMVF9SRVNFVF9ERUxBWSArIDUwMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNldENvbnN0cnVjdG9ycy5jbGFzc2ljUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcInVzaW5nIENsYXNzaWMgU2VyaWFsIFJlc2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldENvbnN0cnVjdG9ycy5jbGFzc2ljUmVzZXQodGhpcy50cmFuc3BvcnQsIERFRkFVTFRfUkVTRVRfREVMQVkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldENvbnN0cnVjdG9ycy5jbGFzc2ljUmVzZXQodGhpcy50cmFuc3BvcnQsIEVYVFJBX0RFTEFZKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgY29ubmVjdGlvbiB0byBjaGlwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gUmVzZXQgbW9kZSB0byB1c2UuIEV4YW1wbGU6ICdkZWZhdWx0X3Jlc2V0JyB8ICdub19yZXNldCdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXR0ZW1wdHMgLSBOdW1iZXIgb2YgY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGV0ZWN0aW5nIC0gRGV0ZWN0IHRoZSBjb25uZWN0ZWQgY2hpcFxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QobW9kZSA9IFwiZGVmYXVsdF9yZXNldFwiLCBhdHRlbXB0cyA9IDcsIGRldGVjdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgIHRoaXMuaW5mbyhcIkNvbm5lY3RpbmcuLi5cIiwgZmFsc2UpO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5jb25uZWN0KHRoaXMucm9tQmF1ZHJhdGUsIHRoaXMuc2VyaWFsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc2V0U2VxdWVuY2VzID0gdGhpcy5jb25zdHJ1Y3RSZXNldFNlcXVlbmNlKG1vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2VxdWVuY2UgPSByZXNldFNlcXVlbmNlcy5sZW5ndGggPiAwID8gcmVzZXRTZXF1ZW5jZXNbaSAlIHJlc2V0U2VxdWVuY2VzLmxlbmd0aF0gOiBudWxsO1xuICAgICAgICAgICAgcmVzcCA9IGF3YWl0IHRoaXMuX2Nvbm5lY3RBdHRlbXB0KG1vZGUsIHJlc2V0U2VxdWVuY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3AgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3AgIT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB3aXRoIHRoZSBkZXZpY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkNvbm5lY3QgYXR0ZW1wdCBzdWNjZXNzZnVsLlwiKTtcbiAgICAgICAgdGhpcy5pbmZvKFwiXFxuXFxyXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKGRldGVjdGluZykge1xuICAgICAgICAgICAgY29uc3QgY2hpcE1hZ2ljVmFsdWUgPSAoYXdhaXQgdGhpcy5yZWFkUmVnKHRoaXMuQ0hJUF9ERVRFQ1RfTUFHSUNfUkVHX0FERFIpKSA+Pj4gMDtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJDaGlwIE1hZ2ljIFwiICsgY2hpcE1hZ2ljVmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaXAgPSBhd2FpdCBtYWdpYzJDaGlwKGNoaXBNYWdpY1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoYFVuZXhwZWN0ZWQgQ0hJUCBtYWdpYyB2YWx1ZSAke2NoaXBNYWdpY1ZhbHVlfS4gRmFpbGVkIHRvIGF1dG9kZXRlY3QgY2hpcCB0eXBlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlwID0gY2hpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGFuZCBkZXRlY3QgdGhlIGV4aXN0aW5nIGNoaXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgUmVzZXQgbW9kZSB0byB1c2UgZm9yIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgZGV0ZWN0Q2hpcChtb2RlID0gXCJkZWZhdWx0X3Jlc2V0XCIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KG1vZGUpO1xuICAgICAgICB0aGlzLmluZm8oXCJEZXRlY3RpbmcgY2hpcCB0eXBlLi4uIFwiLCBmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNoaXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmZvKHRoaXMuY2hpcC5DSElQX05BTUUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmZvKFwidW5rbm93biFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY29tbWFuZCBhbmQgY2hlY2sgdGhlIGNvbW1hbmQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wRGVzY3JpcHRpb24gQ29tbWFuZCBvcGVyYXRpb24gZGVzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wIENvbW1hbmQgb3BlcmF0aW9uIG51bWJlclxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSBDb21tYW5kIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoayBDaGVja3N1bSB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUSW1lb3V0IG51bWJlciBpbiBtaWxsaXNlY29uZHMgKG1zKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENvbW1hbmQgcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tDb21tYW5kKG9wRGVzY3JpcHRpb24gPSBcIlwiLCBvcCA9IG51bGwsIGRhdGEgPSBuZXcgVWludDhBcnJheSgwKSwgY2hrID0gMCwgdGltZW91dCA9IHRoaXMuREVGQVVMVF9USU1FT1VUKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJjaGVja19jb21tYW5kIFwiICsgb3BEZXNjcmlwdGlvbik7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNvbW1hbmQob3AsIGRhdGEsIGNoaywgdW5kZWZpbmVkLCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHJlc3BbMV0ubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBkb3dubG9hZGluZyBhbiBhcHBsaWNhdGlvbiBpbWFnZSB0byBSQU1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBJbWFnZSBzaXplIG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja3MgTnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2Nrc2l6ZSBTaXplIG9mIGVhY2ggZGF0YSBibG9ja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgSW1hZ2Ugb2Zmc2V0IG51bWJlclxuICAgICAqL1xuICAgIGFzeW5jIG1lbUJlZ2luKHNpemUsIGJsb2NrcywgYmxvY2tzaXplLCBvZmZzZXQpIHtcbiAgICAgICAgLyogWFhYOiBBZGQgY2hlY2sgdG8gZW5zdXJlIHRoYXQgU1RVQiBpcyBub3QgZ2V0dGluZyBvdmVyd3JpdHRlbiAqL1xuICAgICAgICBpZiAodGhpcy5JU19TVFVCKSB7XG4gICAgICAgICAgICBjb25zdCBsb2FkU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBsb2FkRW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0dWIgPSBhd2FpdCBnZXRTdHViSnNvbkJ5Q2hpcE5hbWUodGhpcy5jaGlwLkNISVBfTkFNRSk7XG4gICAgICAgICAgICBpZiAoc3R1Yikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWFzVG9DaGVjayA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3N0dWIuYnNzX3N0YXJ0IHx8IHN0dWIuZGF0YV9zdGFydCwgc3R1Yi5kYXRhX3N0YXJ0ICsgc3R1Yi5kZWNvZGVkRGF0YS5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICBbc3R1Yi50ZXh0X3N0YXJ0LCBzdHViLnRleHRfc3RhcnQgKyBzdHViLmRlY29kZWRUZXh0Lmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzdHViU3RhcnQsIHN0dWJFbmRdIG9mIGFyZWFzVG9DaGVjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZFN0YXJ0IDwgc3R1YkVuZCAmJiBsb2FkRW5kID4gc3R1YlN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoYFNvZnR3YXJlIGxvYWRlciBpcyByZXNpZGVudCBhdCAweCR7c3R1YlN0YXJ0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIil9LTB4JHtzdHViRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCg4LCBcIjBcIil9LlxuICAgICAgICAgICAgQ2FuJ3QgbG9hZCBiaW5hcnkgYXQgb3ZlcmxhcHBpbmcgYWRkcmVzcyByYW5nZSAweCR7bG9hZFN0YXJ0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIil9LTB4JHtsb2FkRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCg4LCBcIjBcIil9LlxuICAgICAgICAgICAgRWl0aGVyIGNoYW5nZSBiaW5hcnkgbG9hZGluZyBhZGRyZXNzLCBvciB1c2UgdGhlIG5vLXN0dWIgb3B0aW9uIHRvIGRpc2FibGUgdGhlIHNvZnR3YXJlIGxvYWRlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKFwibWVtX2JlZ2luIFwiICsgc2l6ZSArIFwiIFwiICsgYmxvY2tzICsgXCIgXCIgKyBibG9ja3NpemUgKyBcIiBcIiArIG9mZnNldC50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoc2l6ZSksIHRoaXMuX2ludFRvQnl0ZUFycmF5KGJsb2NrcykpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KGJsb2Nrc2l6ZSkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KG9mZnNldCkpO1xuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrQ29tbWFuZChcImVudGVyIFJBTSBkb3dubG9hZCBtb2RlXCIsIHRoaXMuRVNQX01FTV9CRUdJTiwgcGt0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGVja3N1bSBmb3IgZ2l2ZW4gdW5zaWduZWQgOC1iaXQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgVW5zaWduZWQgOC1iaXQgaW50ZWdlciBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0ZSBJbml0aWFsIGNoZWNrc3VtXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBBcnJheSBjaGVja3N1bVxuICAgICAqL1xuICAgIGNoZWNrc3VtKGRhdGEsIHN0YXRlID0gdGhpcy5FU1BfQ0hFQ0tTVU1fTUFHSUMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGF0ZSBePSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGJsb2NrIG9mIGltYWdlIHRvIFJBTVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFVuc2lnbmVkIDgtYml0IGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcSBTZXF1ZW5jZSBudW1iZXJcbiAgICAgKi9cbiAgICBhc3luYyBtZW1CbG9jayhidWZmZXIsIHNlcSkge1xuICAgICAgICBsZXQgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoYnVmZmVyLmxlbmd0aCksIHRoaXMuX2ludFRvQnl0ZUFycmF5KHNlcSkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKTtcbiAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCB0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSB0aGlzLmNoZWNrc3VtKGJ1ZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwid3JpdGUgdG8gdGFyZ2V0IFJBTVwiLCB0aGlzLkVTUF9NRU1fREFUQSwgcGt0LCBjaGVja3N1bSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlIFJBTSBkb3dubG9hZCBtb2RlIGFuZCBydW4gYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW50cnlwb2ludCAtIEVudHJ5cG9pbnQgbnVtYmVyXG4gICAgICovXG4gICAgYXN5bmMgbWVtRmluaXNoKGVudHJ5cG9pbnQpIHtcbiAgICAgICAgY29uc3QgaXNFbnRyeSA9IGVudHJ5cG9pbnQgPT09IDAgPyAxIDogMDtcbiAgICAgICAgY29uc3QgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoaXNFbnRyeSksIHRoaXMuX2ludFRvQnl0ZUFycmF5KGVudHJ5cG9pbnQpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoXCJsZWF2ZSBSQU0gZG93bmxvYWQgbW9kZVwiLCB0aGlzLkVTUF9NRU1fRU5ELCBwa3QsIHVuZGVmaW5lZCwgMjAwKTsgLy8gWFhYOiBoYW5kbGUgbm9uLXN0dWIgd2l0aCBkaWZmIHRpbWVvdXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIFNQSSBmbGFzaCBwaW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhzcGlBcmcgLSAgQXJndW1lbnQgZm9yIFNQSSBhdHRhY2htZW50XG4gICAgICovXG4gICAgYXN5bmMgZmxhc2hTcGlBdHRhY2goaHNwaUFyZykge1xuICAgICAgICBjb25zdCBwa3QgPSB0aGlzLl9pbnRUb0J5dGVBcnJheShoc3BpQXJnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoXCJjb25maWd1cmUgU1BJIGZsYXNoIHBpbnNcIiwgdGhpcy5FU1BfU1BJX0FUVEFDSCwgcGt0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGltZW91dHMgd2hpY2ggYXJlIHNpemUtc3BlY2lmaWMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNQZXJNYiBTZWNvbmRzIHBlciBtZWdhYnl0ZXMgYXMgbnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVCeXRlcyBTaXplIGJ5dGVzIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gU2NhbGVkIHRpbWVvdXQgZm9yIHNwZWNpZmllZCBzaXplLlxuICAgICAqL1xuICAgIHRpbWVvdXRQZXJNYihzZWNvbmRzUGVyTWIsIHNpemVCeXRlcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZWNvbmRzUGVyTWIgKiAoc2l6ZUJ5dGVzIC8gMTAwMDAwMCk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAzMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMzAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZG93bmxvYWRpbmcgdG8gRmxhc2ggKHBlcmZvcm1zIGFuIGVyYXNlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFNpemUgdG8gZXJhc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldCB0byBlcmFzZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBibG9ja3MgKG9mIHNpemUgc2VsZi5GTEFTSF9XUklURV9TSVpFKSB0byB3cml0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBmbGFzaEJlZ2luKHNpemUsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBudW1CbG9ja3MgPSBNYXRoLmZsb29yKChzaXplICsgdGhpcy5GTEFTSF9XUklURV9TSVpFIC0gMSkgLyB0aGlzLkZMQVNIX1dSSVRFX1NJWkUpO1xuICAgICAgICBjb25zdCBlcmFzZVNpemUgPSB0aGlzLmNoaXAuZ2V0RXJhc2VTaXplKG9mZnNldCwgc2l6ZSk7XG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0MSA9IGQuZ2V0VGltZSgpO1xuICAgICAgICBsZXQgdGltZW91dCA9IDMwMDA7XG4gICAgICAgIGlmICh0aGlzLklTX1NUVUIgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXRQZXJNYih0aGlzLkVSQVNFX1JFR0lPTl9USU1FT1VUX1BFUl9NQiwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcImZsYXNoIGJlZ2luIFwiICsgZXJhc2VTaXplICsgXCIgXCIgKyBudW1CbG9ja3MgKyBcIiBcIiArIHRoaXMuRkxBU0hfV1JJVEVfU0laRSArIFwiIFwiICsgb2Zmc2V0ICsgXCIgXCIgKyBzaXplKTtcbiAgICAgICAgbGV0IHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGVyYXNlU2l6ZSksIHRoaXMuX2ludFRvQnl0ZUFycmF5KG51bUJsb2NrcykpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KHRoaXMuRkxBU0hfV1JJVEVfU0laRSkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KG9mZnNldCkpO1xuICAgICAgICBpZiAodGhpcy5JU19TVFVCID09IGZhbHNlKSB7XG4gICAgICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKTsgLy8gWFhYOiBTdXBwb3J0IGVuY3J5cHRlZFxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwiZW50ZXIgRmxhc2ggZG93bmxvYWQgbW9kZVwiLCB0aGlzLkVTUF9GTEFTSF9CRUdJTiwgcGt0LCB1bmRlZmluZWQsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCB0MiA9IGQuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoc2l6ZSAhPSAwICYmIHRoaXMuSVNfU1RVQiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pbmZvKFwiVG9vayBcIiArICh0MiAtIHQxKSAvIDEwMDAgKyBcIi5cIiArICgodDIgLSB0MSkgJSAxMDAwKSArIFwicyB0byBlcmFzZSBmbGFzaCBibG9ja1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtQmxvY2tzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBkb3dubG9hZGluZyBjb21wcmVzc2VkIGRhdGEgdG8gRmxhc2ggKHBlcmZvcm1zIGFuIGVyYXNlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFdyaXRlIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29tcHNpemUgQ29tcHJlc3NlZCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgZm9yIHdyaXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBudW1iZXIgb2YgYmxvY2tzIChzaXplIHNlbGYuRkxBU0hfV1JJVEVfU0laRSkgdG8gd3JpdGUuXG4gICAgICovXG4gICAgYXN5bmMgZmxhc2hEZWZsQmVnaW4oc2l6ZSwgY29tcHNpemUsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBudW1CbG9ja3MgPSBNYXRoLmZsb29yKChjb21wc2l6ZSArIHRoaXMuRkxBU0hfV1JJVEVfU0laRSAtIDEpIC8gdGhpcy5GTEFTSF9XUklURV9TSVpFKTtcbiAgICAgICAgY29uc3QgZXJhc2VCbG9ja3MgPSBNYXRoLmZsb29yKChzaXplICsgdGhpcy5GTEFTSF9XUklURV9TSVpFIC0gMSkgLyB0aGlzLkZMQVNIX1dSSVRFX1NJWkUpO1xuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdDEgPSBkLmdldFRpbWUoKTtcbiAgICAgICAgbGV0IHdyaXRlU2l6ZSwgdGltZW91dDtcbiAgICAgICAgaWYgKHRoaXMuSVNfU1RVQikge1xuICAgICAgICAgICAgd3JpdGVTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0aGlzLkRFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlU2l6ZSA9IGVyYXNlQmxvY2tzICogdGhpcy5GTEFTSF9XUklURV9TSVpFO1xuICAgICAgICAgICAgdGltZW91dCA9IHRoaXMudGltZW91dFBlck1iKHRoaXMuRVJBU0VfUkVHSU9OX1RJTUVPVVRfUEVSX01CLCB3cml0ZVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mbyhcIkNvbXByZXNzZWQgXCIgKyBzaXplICsgXCIgYnl0ZXMgdG8gXCIgKyBjb21wc2l6ZSArIFwiLi4uXCIpO1xuICAgICAgICBsZXQgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkod3JpdGVTaXplKSwgdGhpcy5faW50VG9CeXRlQXJyYXkobnVtQmxvY2tzKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkodGhpcy5GTEFTSF9XUklURV9TSVpFKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkob2Zmc2V0KSk7XG4gICAgICAgIGlmICgodGhpcy5jaGlwLkNISVBfTkFNRSA9PT0gXCJFU1AzMi1TMlwiIHx8XG4gICAgICAgICAgICB0aGlzLmNoaXAuQ0hJUF9OQU1FID09PSBcIkVTUDMyLVMzXCIgfHxcbiAgICAgICAgICAgIHRoaXMuY2hpcC5DSElQX05BTUUgPT09IFwiRVNQMzItQzNcIiB8fFxuICAgICAgICAgICAgdGhpcy5jaGlwLkNISVBfTkFNRSA9PT0gXCJFU1AzMi1DMlwiKSAmJlxuICAgICAgICAgICAgdGhpcy5JU19TVFVCID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCB0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoXCJlbnRlciBjb21wcmVzc2VkIGZsYXNoIG1vZGVcIiwgdGhpcy5FU1BfRkxBU0hfREVGTF9CRUdJTiwgcGt0LCB1bmRlZmluZWQsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCB0MiA9IGQuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoc2l6ZSAhPSAwICYmIHRoaXMuSVNfU1RVQiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mbyhcIlRvb2sgXCIgKyAodDIgLSB0MSkgLyAxMDAwICsgXCIuXCIgKyAoKHQyIC0gdDEpICUgMTAwMCkgKyBcInMgdG8gZXJhc2UgZmxhc2ggYmxvY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bUJsb2NrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYmxvY2sgdG8gZmxhc2gsIHJldHJ5IGlmIGZhaWxcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgVW5zaWduZWQgOC1iaXQgYXJyYXkgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VxIFNlcXVlbmNlIG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIChtcylcbiAgICAgKi9cbiAgICBhc3luYyBmbGFzaEJsb2NrKGRhdGEsIHNlcSwgdGltZW91dCkge1xuICAgICAgICBsZXQgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoZGF0YS5sZW5ndGgpLCB0aGlzLl9pbnRUb0J5dGVBcnJheShzZXEpKTtcbiAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCB0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIGRhdGEpO1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IHRoaXMuY2hlY2tzdW0oZGF0YSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwid3JpdGUgdG8gdGFyZ2V0IEZsYXNoIGFmdGVyIHNlcSBcIiArIHNlcSwgdGhpcy5FU1BfRkxBU0hfREFUQSwgcGt0LCBjaGVja3N1bSwgdGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGJsb2NrIHRvIGZsYXNoLCBzZW5kIGNvbXByZXNzZWQsIHJldHJ5IGlmIGZhaWxcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgVW5zaWduZWQgaW50IDgtYml0IGFycmF5IGRhdGEgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VxIFNlcXVlbmNlIG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIChtcylcbiAgICAgKi9cbiAgICBhc3luYyBmbGFzaERlZmxCbG9jayhkYXRhLCBzZXEsIHRpbWVvdXQpIHtcbiAgICAgICAgbGV0IHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGRhdGEubGVuZ3RoKSwgdGhpcy5faW50VG9CeXRlQXJyYXkoc2VxKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKTtcbiAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCBkYXRhKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSB0aGlzLmNoZWNrc3VtKGRhdGEpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiZmxhc2hfZGVmbF9ibG9jayBcIiArIGRhdGFbMF0udG9TdHJpbmcoMTYpICsgXCIgXCIgKyBkYXRhWzFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwid3JpdGUgY29tcHJlc3NlZCBkYXRhIHRvIGZsYXNoIGFmdGVyIHNlcSBcIiArIHNlcSwgdGhpcy5FU1BfRkxBU0hfREVGTF9EQVRBLCBwa3QsIGNoZWNrc3VtLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmUgZmxhc2ggbW9kZSBhbmQgcnVuL3JlYm9vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVib290IFJlYm9vdCBhZnRlciBsZWF2aW5nIGZsYXNoIG1vZGUgP1xuICAgICAqL1xuICAgIGFzeW5jIGZsYXNoRmluaXNoKHJlYm9vdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHJlYm9vdCA/IDAgOiAxO1xuICAgICAgICBjb25zdCBwa3QgPSB0aGlzLl9pbnRUb0J5dGVBcnJheSh2YWwpO1xuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrQ29tbWFuZChcImxlYXZlIEZsYXNoIG1vZGVcIiwgdGhpcy5FU1BfRkxBU0hfRU5ELCBwa3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZSBjb21wcmVzc2VkIGZsYXNoIG1vZGUgYW5kIHJ1bi9yZWJvb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYm9vdCBSZWJvb3QgYWZ0ZXIgbGVhdmluZyBmbGFzaCBtb2RlID9cbiAgICAgKi9cbiAgICBhc3luYyBmbGFzaERlZmxGaW5pc2gocmVib290ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdmFsID0gcmVib290ID8gMCA6IDE7XG4gICAgICAgIGNvbnN0IHBrdCA9IHRoaXMuX2ludFRvQnl0ZUFycmF5KHZhbCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwibGVhdmUgY29tcHJlc3NlZCBmbGFzaCBtb2RlXCIsIHRoaXMuRVNQX0ZMQVNIX0RFRkxfRU5ELCBwa3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gYW4gYXJiaXRyYXJ5IFNQSSBmbGFzaCBjb21tYW5kLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBcIlVTUl9DT01NQU5EXCIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgRVNQXG4gICAgICogU1BJIGhhcmR3YXJlLCByYXRoZXIgdGhhbiB0aGUgcHJlY2FubmVkIGNvbW1hbmRzIHN1cHBvcnRlZCBieVxuICAgICAqIGhhcmR3YXJlLiBTbyB0aGUgdmFsdWUgb2Ygc3BpZmxhc2hDb21tYW5kIGlzIGFuIGFjdHVhbCBjb21tYW5kXG4gICAgICogYnl0ZSwgc2VudCBvdmVyIHRoZSB3aXJlLlxuICAgICAqXG4gICAgICogQWZ0ZXIgd3JpdGluZyBjb21tYW5kIGJ5dGUsIHdyaXRlcyAnZGF0YScgdG8gTU9TSSBhbmQgdGhlblxuICAgICAqIHJlYWRzIGJhY2sgJ3JlYWRCaXRzJyBvZiByZXBseSBvbiBNSVNPLiBSZXN1bHQgaXMgYSBudW1iZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwaWZsYXNoQ29tbWFuZCBDb21tYW5kIHRvIGV4ZWN1dGUgaW4gU1BJXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIERhdGEgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWFkQml0cyBOdW1iZXIgb2YgYml0cyB0byByZWFkXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmVnaXN0ZXIgU1BJX1cwX1JFRyB2YWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIHJ1blNwaWZsYXNoQ29tbWFuZChzcGlmbGFzaENvbW1hbmQsIGRhdGEsIHJlYWRCaXRzKSB7XG4gICAgICAgIC8vIFNQSV9VU1IgcmVnaXN0ZXIgZmxhZ3NcbiAgICAgICAgY29uc3QgU1BJX1VTUl9DT01NQU5EID0gMSA8PCAzMTtcbiAgICAgICAgY29uc3QgU1BJX1VTUl9NSVNPID0gMSA8PCAyODtcbiAgICAgICAgY29uc3QgU1BJX1VTUl9NT1NJID0gMSA8PCAyNztcbiAgICAgICAgLy8gU1BJIHJlZ2lzdGVycywgYmFzZSBhZGRyZXNzIGRpZmZlcnMgRVNQMzIqIHZzIDgyNjZcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuY2hpcC5TUElfUkVHX0JBU0U7XG4gICAgICAgIGNvbnN0IFNQSV9DTURfUkVHID0gYmFzZSArIDB4MDA7XG4gICAgICAgIGNvbnN0IFNQSV9VU1JfUkVHID0gYmFzZSArIHRoaXMuY2hpcC5TUElfVVNSX09GRlM7XG4gICAgICAgIGNvbnN0IFNQSV9VU1IxX1JFRyA9IGJhc2UgKyB0aGlzLmNoaXAuU1BJX1VTUjFfT0ZGUztcbiAgICAgICAgY29uc3QgU1BJX1VTUjJfUkVHID0gYmFzZSArIHRoaXMuY2hpcC5TUElfVVNSMl9PRkZTO1xuICAgICAgICBjb25zdCBTUElfVzBfUkVHID0gYmFzZSArIHRoaXMuY2hpcC5TUElfVzBfT0ZGUztcbiAgICAgICAgbGV0IHNldERhdGFMZW5ndGhzO1xuICAgICAgICBpZiAodGhpcy5jaGlwLlNQSV9NT1NJX0RMRU5fT0ZGUyAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXREYXRhTGVuZ3RocyA9IGFzeW5jIChtb3NpQml0cywgbWlzb0JpdHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBTUElfTU9TSV9ETEVOX1JFRyA9IGJhc2UgKyB0aGlzLmNoaXAuU1BJX01PU0lfRExFTl9PRkZTO1xuICAgICAgICAgICAgICAgIGNvbnN0IFNQSV9NSVNPX0RMRU5fUkVHID0gYmFzZSArIHRoaXMuY2hpcC5TUElfTUlTT19ETEVOX09GRlM7XG4gICAgICAgICAgICAgICAgaWYgKG1vc2lCaXRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVnKFNQSV9NT1NJX0RMRU5fUkVHLCBtb3NpQml0cyAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWlzb0JpdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVSZWcoU1BJX01JU09fRExFTl9SRUcsIG1pc29CaXRzIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldERhdGFMZW5ndGhzID0gYXN5bmMgKG1vc2lCaXRzLCBtaXNvQml0cykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFNQSV9EQVRBX0xFTl9SRUcgPSBTUElfVVNSMV9SRUc7XG4gICAgICAgICAgICAgICAgY29uc3QgU1BJX01PU0lfQklUTEVOX1MgPSAxNztcbiAgICAgICAgICAgICAgICBjb25zdCBTUElfTUlTT19CSVRMRU5fUyA9IDg7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9zaU1hc2sgPSBtb3NpQml0cyA9PT0gMCA/IDAgOiBtb3NpQml0cyAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzb01hc2sgPSBtaXNvQml0cyA9PT0gMCA/IDAgOiBtaXNvQml0cyAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gKG1pc29NYXNrIDw8IFNQSV9NSVNPX0JJVExFTl9TKSB8IChtb3NpTWFzayA8PCBTUElfTU9TSV9CSVRMRU5fUyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZVJlZyhTUElfREFUQV9MRU5fUkVHLCB2YWwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTUElfQ01EX1VTUiA9IDEgPDwgMTg7XG4gICAgICAgIGNvbnN0IFNQSV9VU1IyX0NPTU1BTkRfTEVOX1NISUZUID0gMjg7XG4gICAgICAgIGlmIChyZWFkQml0cyA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoXCJSZWFkaW5nIG1vcmUgdGhhbiAzMiBiaXRzIGJhY2sgZnJvbSBhIFNQSSBmbGFzaCBvcGVyYXRpb24gaXMgdW5zdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFU1BFcnJvcihcIldyaXRpbmcgbW9yZSB0aGFuIDY0IGJ5dGVzIG9mIGRhdGEgd2l0aCBvbmUgU1BJIGNvbW1hbmQgaXMgdW5zdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUJpdHMgPSBkYXRhLmxlbmd0aCAqIDg7XG4gICAgICAgIGNvbnN0IG9sZFNwaVVzciA9IGF3YWl0IHRoaXMucmVhZFJlZyhTUElfVVNSX1JFRyk7XG4gICAgICAgIGNvbnN0IG9sZFNwaVVzcjIgPSBhd2FpdCB0aGlzLnJlYWRSZWcoU1BJX1VTUjJfUkVHKTtcbiAgICAgICAgbGV0IGZsYWdzID0gU1BJX1VTUl9DT01NQU5EO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHJlYWRCaXRzID4gMCkge1xuICAgICAgICAgICAgZmxhZ3MgfD0gU1BJX1VTUl9NSVNPO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhQml0cyA+IDApIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IFNQSV9VU1JfTU9TSTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzZXREYXRhTGVuZ3RocyhkYXRhQml0cywgcmVhZEJpdHMpO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVnKFNQSV9VU1JfUkVHLCBmbGFncyk7XG4gICAgICAgIGxldCB2YWwgPSAoNyA8PCBTUElfVVNSMl9DT01NQU5EX0xFTl9TSElGVCkgfCBzcGlmbGFzaENvbW1hbmQ7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVSZWcoU1BJX1VTUjJfUkVHLCB2YWwpO1xuICAgICAgICBpZiAoZGF0YUJpdHMgPT0gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZVJlZyhTUElfVzBfUkVHLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAlIDQgIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAlIDQpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9hcHBlbmRBcnJheShkYXRhLCBwYWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UmVnID0gU1BJX1cwX1JFRztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDQ7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuX2J5dGVBcnJheVRvSW50KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSwgZGF0YVtpICsgM10pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVSZWcobmV4dFJlZywgdmFsKTtcbiAgICAgICAgICAgICAgICBuZXh0UmVnICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZVJlZyhTUElfQ01EX1JFRywgU1BJX0NNRF9VU1IpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgdmFsID0gKGF3YWl0IHRoaXMucmVhZFJlZyhTUElfQ01EX1JFRykpICYgU1BJX0NNRF9VU1I7XG4gICAgICAgICAgICBpZiAodmFsID09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMTApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFU1BFcnJvcihcIlNQSSBjb21tYW5kIGRpZCBub3QgY29tcGxldGUgaW4gdGltZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgdGhpcy5yZWFkUmVnKFNQSV9XMF9SRUcpO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVnKFNQSV9VU1JfUkVHLCBvbGRTcGlVc3IpO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVnKFNQSV9VU1IyX1JFRywgb2xkU3BpVXNyMik7XG4gICAgICAgIHJldHVybiBzdGF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZsYXNoIGlkIGJ5IGV4ZWN1dGluZyB0aGUgU1BJRkxBU0hfUkRJRCBmbGFzaCBjb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IFJlZ2lzdGVyIFNQSV9XMF9SRUcgdmFsdWVcbiAgICAgKi9cbiAgICBhc3luYyByZWFkRmxhc2hJZCgpIHtcbiAgICAgICAgY29uc3QgU1BJRkxBU0hfUkRJRCA9IDB4OWY7XG4gICAgICAgIGNvbnN0IHBrdCA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5ydW5TcGlmbGFzaENvbW1hbmQoU1BJRkxBU0hfUkRJRCwgcGt0LCAyNCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGVyYXNlIGZsYXNoIGNvbW1hbmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXIgfCBVaW50OEFycmF5Pn0gRXJhc2UgZmxhc2ggY29tbWFuZCByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBlcmFzZUZsYXNoKCkge1xuICAgICAgICB0aGlzLmluZm8oXCJFcmFzaW5nIGZsYXNoICh0aGlzIG1heSB0YWtlIGEgd2hpbGUpLi4uXCIpO1xuICAgICAgICBsZXQgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHQxID0gZC5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKFwiZXJhc2UgZmxhc2hcIiwgdGhpcy5FU1BfRVJBU0VfRkxBU0gsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLkNISVBfRVJBU0VfVElNRU9VVCk7XG4gICAgICAgIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0MiA9IGQuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmluZm8oXCJDaGlwIGVyYXNlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgaW4gXCIgKyAodDIgLSB0MSkgLyAxMDAwICsgXCJzXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgbnVtYmVyIG9yIHVuc2lnbmVkIDgtYml0IGFycmF5IHRvIGhleCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IFVpbnQ4QXJyYXkgfSBidWZmZXIgRGF0YSB0byBjb252ZXJ0IHRvIGhleCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBoZXggc3RyaW5nXG4gICAgICovXG4gICAgdG9IZXgoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnVmZmVyLCAoeCkgPT4gKFwiMDBcIiArIHgudG9TdHJpbmcoMTYpKS5zbGljZSgtMikpLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgTUQ1IENoZWNrc3VtIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkciBBZGRyZXNzIG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFBhY2thZ2Ugc2l6ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IE1ENSBDaGVja3N1bSBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBmbGFzaE1kNXN1bShhZGRyLCBzaXplKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLnRpbWVvdXRQZXJNYih0aGlzLk1ENV9USU1FT1VUX1BFUl9NQiwgc2l6ZSk7XG4gICAgICAgIGxldCBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheSh0aGlzLl9pbnRUb0J5dGVBcnJheShhZGRyKSwgdGhpcy5faW50VG9CeXRlQXJyYXkoc2l6ZSkpO1xuICAgICAgICBwa3QgPSB0aGlzLl9hcHBlbmRBcnJheShwa3QsIHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKTtcbiAgICAgICAgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkocGt0LCB0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmNoZWNrQ29tbWFuZChcImNhbGN1bGF0ZSBtZDVzdW1cIiwgdGhpcy5FU1BfU1BJX0ZMQVNIX01ENSwgcGt0LCB1bmRlZmluZWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiByZXMubGVuZ3RoID4gMTYpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RybWQ1ID0gdGhpcy50b0hleChyZXMpO1xuICAgICAgICByZXR1cm4gc3RybWQ1O1xuICAgIH1cbiAgICBhc3luYyByZWFkRmxhc2goYWRkciwgc2l6ZSwgb25QYWNrZXRSZWNlaXZlZCA9IG51bGwpIHtcbiAgICAgICAgbGV0IHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGFkZHIpLCB0aGlzLl9pbnRUb0J5dGVBcnJheShzaXplKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkoMHgxMDAwKSk7XG4gICAgICAgIHBrdCA9IHRoaXMuX2FwcGVuZEFycmF5KHBrdCwgdGhpcy5faW50VG9CeXRlQXJyYXkoMTAyNCkpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNoZWNrQ29tbWFuZChcInJlYWQgZmxhc2hcIiwgdGhpcy5FU1BfUkVBRF9GTEFTSCwgcGt0KTtcbiAgICAgICAgaWYgKHJlcyAhPSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoXCJGYWlsZWQgdG8gcmVhZCBtZW1vcnk6IFwiICsgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcCA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB3aGlsZSAocmVzcC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBwYWNrZXQgfSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlYWQodGhpcy5GTEFTSF9SRUFEX1RJTUVPVVQpLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChwYWNrZXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3AgPSB0aGlzLl9hcHBlbmRBcnJheShyZXNwLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC53cml0ZSh0aGlzLl9pbnRUb0J5dGVBcnJheShyZXNwLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25QYWNrZXRSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25QYWNrZXRSZWNlaXZlZChwYWNrZXQsIHJlc3AubGVuZ3RoLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFU1BFcnJvcihcIkZhaWxlZCB0byByZWFkIG1lbW9yeTogXCIgKyBwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgdGhlIGZsYXNoZXIgUk9NIGJvb3Rsb2FkZXIgKGZsYXNoZXIgc3R1YikgdG8gdGhlIGNoaXAuXG4gICAgICogQHJldHVybnMge1JPTX0gVGhlIENoaXAgUk9NXG4gICAgICovXG4gICAgYXN5bmMgcnVuU3R1YigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3luY1N0dWJEZXRlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmZvKFwiU3R1YiBpcyBhbHJlYWR5IHJ1bm5pbmcuIE5vIHVwbG9hZCBpcyBuZWNlc3NhcnkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8oXCJVcGxvYWRpbmcgc3R1Yi4uLlwiKTtcbiAgICAgICAgY29uc3Qgc3R1YkZsYXNoZXIgPSBhd2FpdCBnZXRTdHViSnNvbkJ5Q2hpcE5hbWUodGhpcy5jaGlwLkNISVBfTkFNRSk7XG4gICAgICAgIGlmIChzdHViRmxhc2hlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiRXJyb3IgbG9hZGluZyBTdHViIGpzb25cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBsb2FkaW5nIFN0dWIganNvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHViID0gW3N0dWJGbGFzaGVyLmRlY29kZWRUZXh0LCBzdHViRmxhc2hlci5kZWNvZGVkRGF0YV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0dWJbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzID0gaSA9PT0gMCA/IHN0dWJGbGFzaGVyLnRleHRfc3RhcnQgOiBzdHViRmxhc2hlci5kYXRhX3N0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0dWJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoKGxlbmd0aCArIHRoaXMuRVNQX1JBTV9CTE9DSyAtIDEpIC8gdGhpcy5FU1BfUkFNX0JMT0NLKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1lbUJlZ2luKGxlbmd0aCwgYmxvY2tzLCB0aGlzLkVTUF9SQU1fQkxPQ0ssIG9mZnMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlcSA9IDA7IHNlcSA8IGJsb2Nrczsgc2VxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbU9mZnMgPSBzZXEgKiB0aGlzLkVTUF9SQU1fQkxPQ0s7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvT2ZmcyA9IGZyb21PZmZzICsgdGhpcy5FU1BfUkFNX0JMT0NLO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1lbUJsb2NrKHN0dWJbaV0uc2xpY2UoZnJvbU9mZnMsIHRvT2ZmcyksIHNlcSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mbyhcIlJ1bm5pbmcgc3R1Yi4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5tZW1GaW5pc2goc3R1YkZsYXNoZXIuZW50cnkpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYWNrZXRSZXN1bHQgfSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlYWQodGhpcy5ERUZBVUxUX1RJTUVPVVQpLm5leHQoKTtcbiAgICAgICAgY29uc3QgcGFja2V0U3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5wYWNrZXRSZXN1bHQpO1xuICAgICAgICBpZiAocGFja2V0U3RyICE9PSBcIk9IQUlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgc3R1Yi4gVW5leHBlY3RlZCByZXNwb25zZSAke3BhY2tldFN0cn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8oXCJTdHViIHJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuSVNfU1RVQiA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgY2hpcCBiYXVkcmF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VCYXVkKCkge1xuICAgICAgICB0aGlzLmluZm8oXCJDaGFuZ2luZyBiYXVkcmF0ZSB0byBcIiArIHRoaXMuYmF1ZHJhdGUpO1xuICAgICAgICBjb25zdCBzZWNvbmRBcmcgPSB0aGlzLklTX1NUVUIgPyB0aGlzLnJvbUJhdWRyYXRlIDogMDtcbiAgICAgICAgY29uc3QgcGt0ID0gdGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkodGhpcy5iYXVkcmF0ZSksIHRoaXMuX2ludFRvQnl0ZUFycmF5KHNlY29uZEFyZykpO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbW1hbmQodGhpcy5FU1BfQ0hBTkdFX0JBVURSQVRFLCBwa3QpO1xuICAgICAgICB0aGlzLmluZm8oXCJDaGFuZ2VkXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NsZWVwKDUwKTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuY29ubmVjdCh0aGlzLmJhdWRyYXRlLCB0aGlzLnNlcmlhbE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBtYWluIGZ1bmN0aW9uIG9mIEVTUExvYWRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBSZXNldCBtb2RlIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNoaXAgUk9NXG4gICAgICovXG4gICAgYXN5bmMgbWFpbihtb2RlID0gXCJkZWZhdWx0X3Jlc2V0XCIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXRlY3RDaGlwKG1vZGUpO1xuICAgICAgICBjb25zdCBjaGlwID0gYXdhaXQgdGhpcy5jaGlwLmdldENoaXBEZXNjcmlwdGlvbih0aGlzKTtcbiAgICAgICAgdGhpcy5pbmZvKFwiQ2hpcCBpcyBcIiArIGNoaXApO1xuICAgICAgICB0aGlzLmluZm8oXCJGZWF0dXJlczogXCIgKyAoYXdhaXQgdGhpcy5jaGlwLmdldENoaXBGZWF0dXJlcyh0aGlzKSkpO1xuICAgICAgICB0aGlzLmluZm8oXCJDcnlzdGFsIGlzIFwiICsgKGF3YWl0IHRoaXMuY2hpcC5nZXRDcnlzdGFsRnJlcSh0aGlzKSkgKyBcIk1IelwiKTtcbiAgICAgICAgdGhpcy5pbmZvKFwiTUFDOiBcIiArIChhd2FpdCB0aGlzLmNoaXAucmVhZE1hYyh0aGlzKSkpO1xuICAgICAgICBhd2FpdCB0aGlzLmNoaXAucmVhZE1hYyh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNoaXAucG9zdENvbm5lY3QgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGlwLnBvc3RDb25uZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucnVuU3R1YigpO1xuICAgICAgICBpZiAodGhpcy5yb21CYXVkcmF0ZSAhPT0gdGhpcy5iYXVkcmF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGFuZ2VCYXVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgZ2l2ZW4gZmxhc2ggc2l6ZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmxzeiBGbGFzaCBzaXplIHRvIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBGbGFzaCBzaXplIG51bWJlclxuICAgICAqL1xuICAgIHBhcnNlRmxhc2hTaXplQXJnKGZsc3opIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNoaXAuRkxBU0hfU0laRVNbZmxzel0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFU1BFcnJvcihcIkZsYXNoIHNpemUgXCIgKyBmbHN6ICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNoaXAgdHlwZS4gU3VwcG9ydGVkIHNpemVzOiBcIiArIHRoaXMuY2hpcC5GTEFTSF9TSVpFUyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpcC5GTEFTSF9TSVpFU1tmbHN6XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBpbWFnZSBmbGFzaCBwYXJhbWV0ZXJzIHdpdGggZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZSBiaW5hcnkgaW1hZ2UgYXMgc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZHJlc3MgZmxhc2ggYWRkcmVzcyBudW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmxhc2hTaXplIEZsYXNoIHNpemUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZsYXNoTW9kZSBGbGFzaCBtb2RlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFzaEZyZXEgRmxhc2ggZnJlcXVlbmN5IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG1vZGlmaWVkIGltYWdlIHN0cmluZ1xuICAgICAqL1xuICAgIF91cGRhdGVJbWFnZUZsYXNoUGFyYW1zKGltYWdlLCBhZGRyZXNzLCBmbGFzaFNpemUsIGZsYXNoTW9kZSwgZmxhc2hGcmVxKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJfdXBkYXRlX2ltYWdlX2ZsYXNoX3BhcmFtcyBcIiArIGZsYXNoU2l6ZSArIFwiIFwiICsgZmxhc2hNb2RlICsgXCIgXCIgKyBmbGFzaEZyZXEpO1xuICAgICAgICBpZiAoaW1hZ2UubGVuZ3RoIDwgOCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzICE9IHRoaXMuY2hpcC5CT09UTE9BREVSX0ZMQVNIX09GRlNFVCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFzaFNpemUgPT09IFwia2VlcFwiICYmIGZsYXNoTW9kZSA9PT0gXCJrZWVwXCIgJiYgZmxhc2hGcmVxID09PSBcImtlZXBcIikge1xuICAgICAgICAgICAgdGhpcy5pbmZvKFwiTm90IGNoYW5naW5nIHRoZSBpbWFnZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYWdpYyA9IHBhcnNlSW50KGltYWdlWzBdKTtcbiAgICAgICAgbGV0IGFGbGFzaE1vZGUgPSBwYXJzZUludChpbWFnZVsyXSk7XG4gICAgICAgIGNvbnN0IGZsYXNoU2l6ZUZyZXEgPSBwYXJzZUludChpbWFnZVszXSk7XG4gICAgICAgIGlmIChtYWdpYyAhPT0gdGhpcy5FU1BfSU1BR0VfTUFHSUMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mbyhcIldhcm5pbmc6IEltYWdlIGZpbGUgYXQgMHhcIiArXG4gICAgICAgICAgICAgICAgYWRkcmVzcy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgIFwiIGRvZXNuJ3QgbG9vayBsaWtlIGFuIGltYWdlIGZpbGUsIHNvIG5vdCBjaGFuZ2luZyBhbnkgZmxhc2ggc2V0dGluZ3MuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIC8qIFhYWDogWWV0IHRvIGltcGxlbWVudCBhY3R1YWwgaW1hZ2UgdmVyaWZpY2F0aW9uICovXG4gICAgICAgIGlmIChmbGFzaE1vZGUgIT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICBjb25zdCBmbGFzaE1vZGVzID0geyBxaW86IDAsIHFvdXQ6IDEsIGRpbzogMiwgZG91dDogMyB9O1xuICAgICAgICAgICAgYUZsYXNoTW9kZSA9IGZsYXNoTW9kZXNbZmxhc2hNb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYUZsYXNoRnJlcSA9IGZsYXNoU2l6ZUZyZXEgJiAweDBmO1xuICAgICAgICBpZiAoZmxhc2hGcmVxICE9PSBcImtlZXBcIikge1xuICAgICAgICAgICAgY29uc3QgZmxhc2hGcmVxcyA9IHsgXCI0MG1cIjogMCwgXCIyNm1cIjogMSwgXCIyMG1cIjogMiwgXCI4MG1cIjogMHhmIH07XG4gICAgICAgICAgICBhRmxhc2hGcmVxID0gZmxhc2hGcmVxc1tmbGFzaEZyZXFdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhRmxhc2hTaXplID0gZmxhc2hTaXplRnJlcSAmIDB4ZjA7XG4gICAgICAgIGlmIChmbGFzaFNpemUgIT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICBhRmxhc2hTaXplID0gdGhpcy5wYXJzZUZsYXNoU2l6ZUFyZyhmbGFzaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXNoUGFyYW1zID0gKGFGbGFzaE1vZGUgPDwgOCkgfCAoYUZsYXNoRnJlcSArIGFGbGFzaFNpemUpO1xuICAgICAgICB0aGlzLmluZm8oXCJGbGFzaCBwYXJhbXMgc2V0IHRvIFwiICsgZmxhc2hQYXJhbXMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaWYgKHBhcnNlSW50KGltYWdlWzJdKSAhPT0gYUZsYXNoTW9kZSA8PCA4KSB7XG4gICAgICAgICAgICBpbWFnZSA9IGltYWdlLnN1YnN0cmluZygwLCAyKSArIChhRmxhc2hNb2RlIDw8IDgpLnRvU3RyaW5nKCkgKyBpbWFnZS5zdWJzdHJpbmcoMiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUludChpbWFnZVszXSkgIT09IGFGbGFzaEZyZXEgKyBhRmxhc2hTaXplKSB7XG4gICAgICAgICAgICBpbWFnZSA9IGltYWdlLnN1YnN0cmluZygwLCAzKSArIChhRmxhc2hGcmVxICsgYUZsYXNoU2l6ZSkudG9TdHJpbmcoKSArIGltYWdlLnN1YnN0cmluZygzICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBzZXQgb2YgZmlsZSBpbWFnZXMgaW50byBnaXZlbiBhZGRyZXNzIGJhc2VkIG9uIGdpdmVuIEZsYXNoT3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGbGFzaE9wdGlvbnN9IG9wdGlvbnMgRmxhc2hPcHRpb25zIHRvIGNvbmZpZ3VyZSBob3cgYW5kIHdoYXQgdG8gd3JpdGUgaW50byBmbGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZUZsYXNoKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkVzcExvYWRlciBwcm9ncmFtXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5mbGFzaFNpemUgIT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICBjb25zdCBmbGFzaEVuZCA9IHRoaXMuZmxhc2hTaXplQnl0ZXMob3B0aW9ucy5mbGFzaFNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmZpbGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGVBcnJheVtpXS5kYXRhLmxlbmd0aCArIG9wdGlvbnMuZmlsZUFycmF5W2ldLmFkZHJlc3MgPiBmbGFzaEVuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVNQRXJyb3IoYEZpbGUgJHtpICsgMX0gZG9lc24ndCBmaXQgaW4gdGhlIGF2YWlsYWJsZSBmbGFzaGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5JU19TVFVCID09PSB0cnVlICYmIG9wdGlvbnMuZXJhc2VBbGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZXJhc2VGbGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbWFnZSwgYWRkcmVzcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmZpbGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkRhdGEgTGVuZ3RoIFwiICsgb3B0aW9ucy5maWxlQXJyYXlbaV0uZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgaW1hZ2UgPSBvcHRpb25zLmZpbGVBcnJheVtpXS5kYXRhO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkltYWdlIExlbmd0aCBcIiArIGltYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIldhcm5pbmc6IEZpbGUgaXMgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMudWk4VG9Cc3RyKHBhZFRvKHRoaXMuYnN0clRvVWk4KGltYWdlKSwgNCkpO1xuICAgICAgICAgICAgYWRkcmVzcyA9IG9wdGlvbnMuZmlsZUFycmF5W2ldLmFkZHJlc3M7XG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMuX3VwZGF0ZUltYWdlRmxhc2hQYXJhbXMoaW1hZ2UsIGFkZHJlc3MsIG9wdGlvbnMuZmxhc2hTaXplLCBvcHRpb25zLmZsYXNoTW9kZSwgb3B0aW9ucy5mbGFzaEZyZXEpO1xuICAgICAgICAgICAgbGV0IGNhbGNtZDUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsY3VsYXRlTUQ1SGFzaCkge1xuICAgICAgICAgICAgICAgIGNhbGNtZDUgPSBvcHRpb25zLmNhbGN1bGF0ZU1ENUhhc2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJJbWFnZSBNRDUgXCIgKyBjYWxjbWQ1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuY3NpemUgPSBpbWFnZS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYmxvY2tzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNpbWFnZSA9IHRoaXMuYnN0clRvVWk4KGltYWdlKTtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHRoaXMudWk4VG9Cc3RyKGRlZmxhdGUodW5jaW1hZ2UsIHsgbGV2ZWw6IDkgfSkpO1xuICAgICAgICAgICAgICAgIGJsb2NrcyA9IGF3YWl0IHRoaXMuZmxhc2hEZWZsQmVnaW4odW5jc2l6ZSwgaW1hZ2UubGVuZ3RoLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrcyA9IGF3YWl0IHRoaXMuZmxhc2hCZWdpbih1bmNzaXplLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXEgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEJ5dGVzID0gaW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVwb3J0UHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXBvcnRQcm9ncmVzcyhpLCAwLCB0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgIGxldCBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHQxID0gZC5nZXRUaW1lKCk7XG4gICAgICAgICAgICBsZXQgdGltZW91dCA9IDUwMDA7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBkZWNvbXByZXNzb3IgdG8ga2VlcCB0cmFjayBvZiB0aGUgc2l6ZSBvZiB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgLy8gdG8gYmUgd3JpdHRlbiBpbiBlYWNoIGNodW5rLlxuICAgICAgICAgICAgY29uc3QgaW5mbGF0ZSA9IG5ldyBJbmZsYXRlKHsgY2h1bmtTaXplOiAxIH0pO1xuICAgICAgICAgICAgbGV0IHRvdGFsTGVuVW5jb21wcmVzc2VkID0gMDtcbiAgICAgICAgICAgIGluZmxhdGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5VbmNvbXByZXNzZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAoaW1hZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJXcml0ZSBsb29wIFwiICsgYWRkcmVzcyArIFwiIFwiICsgc2VxICsgXCIgXCIgKyBibG9ja3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mbyhcIldyaXRpbmcgYXQgMHhcIiArXG4gICAgICAgICAgICAgICAgICAgIChhZGRyZXNzICsgdG90YWxMZW5VbmNvbXByZXNzZWQpLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgIFwiLi4uIChcIiArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKDEwMCAqIChzZXEgKyAxKSkgLyBibG9ja3MpICtcbiAgICAgICAgICAgICAgICAgICAgXCIlKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuYnN0clRvVWk4KGltYWdlLnNsaWNlKDAsIHRoaXMuRkxBU0hfV1JJVEVfU0laRSkpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlblVuY29tcHJlc3NlZFByZXZpb3VzID0gdG90YWxMZW5VbmNvbXByZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgIGluZmxhdGUucHVzaChibG9jaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja1VuY29tcHJlc3NlZCA9IHRvdGFsTGVuVW5jb21wcmVzc2VkIC0gbGVuVW5jb21wcmVzc2VkUHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBibG9ja1RpbWVvdXQgPSAzMDAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0UGVyTWIodGhpcy5FUkFTRV9XUklURV9USU1FT1VUX1BFUl9NQiwgYmxvY2tVbmNvbXByZXNzZWQpID4gMzAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUaW1lb3V0ID0gdGhpcy50aW1lb3V0UGVyTWIodGhpcy5FUkFTRV9XUklURV9USU1FT1VUX1BFUl9NQiwgYmxvY2tVbmNvbXByZXNzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLklTX1NUVUIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBST00gY29kZSB3cml0ZXMgYmxvY2sgdG8gZmxhc2ggYmVmb3JlIEFDS2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IGJsb2NrVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZsYXNoRGVmbEJsb2NrKGJsb2NrLCBzZXEsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5JU19TVFVCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHViIEFDS3Mgd2hlbiBibG9jayBpcyByZWNlaXZlZCwgdGhlbiB3cml0ZXMgdG8gZmxhc2ggd2hpbGUgcmVjZWl2aW5nIHRoZSBibG9jayBhZnRlciBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IGJsb2NrVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKFwiWWV0IHRvIGhhbmRsZSBOb24gQ29tcHJlc3NlZCB3cml0ZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVzU2VudCArPSBibG9jay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBpbWFnZS5zbGljZSh0aGlzLkZMQVNIX1dSSVRFX1NJWkUsIGltYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2VxKys7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVwb3J0UHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVwb3J0UHJvZ3Jlc3MoaSwgYnl0ZXNTZW50LCB0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLklTX1NUVUIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWRSZWcodGhpcy5DSElQX0RFVEVDVF9NQUdJQ19SRUdfQUREUiwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBkLmdldFRpbWUoKSAtIHQxO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8oXCJXcm90ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIHVuY3NpemUgK1xuICAgICAgICAgICAgICAgICAgICBcIiBieXRlcyAoXCIgK1xuICAgICAgICAgICAgICAgICAgICBieXRlc1NlbnQgK1xuICAgICAgICAgICAgICAgICAgICBcIiBjb21wcmVzc2VkKSBhdCAweFwiICtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICBcIiBpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHQgLyAxMDAwICtcbiAgICAgICAgICAgICAgICAgICAgXCIgc2Vjb25kcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsY21kNSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmxhc2hNZDVzdW0oYWRkcmVzcywgdW5jc2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBTdHJpbmcocmVzKS52YWx1ZU9mKCkgIT0gbmV3IFN0cmluZyhjYWxjbWQ1KS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvKFwiRmlsZSAgbWQ1OiBcIiArIGNhbGNtZDUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8oXCJGbGFzaCBtZDU6IFwiICsgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKFwiTUQ1IG9mIGZpbGUgZG9lcyBub3QgbWF0Y2ggZGF0YSBpbiBmbGFzaCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8oXCJIYXNoIG9mIGRhdGEgdmVyaWZpZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8oXCJMZWF2aW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5JU19TVFVCKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZsYXNoQmVnaW4oMCwgMCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmxhc2hEZWZsRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZsYXNoRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBTUEkgZmxhc2ggbWFudWZhY3R1cmVyIGFuZCBkZXZpY2UgaWQuXG4gICAgICovXG4gICAgYXN5bmMgZmxhc2hJZCgpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImZsYXNoX2lkXCIpO1xuICAgICAgICBjb25zdCBmbGFzaGlkID0gYXdhaXQgdGhpcy5yZWFkRmxhc2hJZCgpO1xuICAgICAgICB0aGlzLmluZm8oXCJNYW51ZmFjdHVyZXI6IFwiICsgKGZsYXNoaWQgJiAweGZmKS50b1N0cmluZygxNikpO1xuICAgICAgICBjb25zdCBmbGlkTG93Ynl0ZSA9IChmbGFzaGlkID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIHRoaXMuaW5mbyhcIkRldmljZTogXCIgKyAoKGZsYXNoaWQgPj4gOCkgJiAweGZmKS50b1N0cmluZygxNikgKyBmbGlkTG93Ynl0ZS50b1N0cmluZygxNikpO1xuICAgICAgICB0aGlzLmluZm8oXCJEZXRlY3RlZCBmbGFzaCBzaXplOiBcIiArIHRoaXMuREVURUNURURfRkxBU0hfU0laRVNbZmxpZExvd2J5dGVdKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hTaXplKCkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZmxhc2hfaWRcIik7XG4gICAgICAgIGNvbnN0IGZsYXNoaWQgPSBhd2FpdCB0aGlzLnJlYWRGbGFzaElkKCk7XG4gICAgICAgIGNvbnN0IGZsaWRMb3dieXRlID0gKGZsYXNoaWQgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIHRoaXMuREVURUNURURfRkxBU0hfU0laRVNfTlVNW2ZsaWRMb3dieXRlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29mdCByZXNldCB0aGUgZGV2aWNlIGNoaXAuIFNvZnQgcmVzZXQgd2l0aCBydW4gdXNlciBjb2RlIGlzIHRoZSBjbG9zZXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RheUluQm9vdGxvYWRlciBGbGFnIHRvIGluZGljYXRlIGlmIHRvIHN0YXkgaW4gYm9vdGxvYWRlclxuICAgICAqL1xuICAgIGFzeW5jIHNvZnRSZXNldChzdGF5SW5Cb290bG9hZGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5JU19TVFVCKSB7XG4gICAgICAgICAgICBpZiAoc3RheUluQm9vdGxvYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gUk9NIGJvb3Rsb2FkZXIgaXMgYWxyZWFkeSBpbiBib290bG9hZGVyIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJydW4gdXNlciBjb2RlXCIgaXMgYXMgY2xvc2UgdG8gYSBzb2Z0IHJlc2V0IGFzIHdlIGNhbiBkb1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mbGFzaEJlZ2luKDAsIDApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mbGFzaEZpbmlzaChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlwLkNISVBfTkFNRSAhPSBcIkVTUDgyNjZcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVTUEVycm9yKFwiU29mdCByZXNldHRpbmcgaXMgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIG9uIEVTUDgyNjZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RheUluQm9vdGxvYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIHNvZnQgcmVzZXR0aW5nIGZyb20gdGhlIHN0dWIgbG9hZGVyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZS1sb2FkIHRoZSBST00gYm9vdGxvYWRlclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmxhc2hCZWdpbigwLCAwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZsYXNoRmluaXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyB1c2VyIGNvZGUgZnJvbSBzdHViIGxvYWRlciByZXF1aXJlcyBzb21lIGhhY2tzXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHN0dWIgbG9hZGVyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb21tYW5kKHRoaXMuRVNQX1JVTl9VU0VSX0NPREUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgb3BlcmF0aW9uIHJlc2V0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0FmdGVyfSBtb2RlIEFmdGVyIG9wZXJhdGlvbiBtb2RlLiBEZWZhdWx0IGlzICdoYXJkX3Jlc2V0Jy5cbiAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gdXNpbmdVc2JPdGcgRm9yICdoYXJkX3Jlc2V0JyB0byBzcGVjaWZ5IGlmIHVzaW5nIFVTQi1PVEdcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlcihtb2RlID0gXCJoYXJkX3Jlc2V0XCIsIHVzaW5nVXNiT3RnKSB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcImhhcmRfcmVzZXRcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNldENvbnN0cnVjdG9ycy5oYXJkUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvKFwiSGFyZCByZXNldHRpbmcgdmlhIFJUUyBwaW4uLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhcmRSZXNldCA9IHRoaXMucmVzZXRDb25zdHJ1Y3RvcnMuaGFyZFJlc2V0KHRoaXMudHJhbnNwb3J0LCB1c2luZ1VzYk90Zyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhcmRSZXNldC5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzb2Z0X3Jlc2V0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvKFwiU29mdCByZXNldHRpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zb2Z0UmVzZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vX3Jlc2V0X3N0dWJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8oXCJTdGF5aW5nIGluIGZsYXNoZXIgc3R1Yi5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuaW5mbyhcIlN0YXlpbmcgaW4gYm9vdGxvYWRlci5cIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSVNfU1RVQikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvZnRSZXNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/esploader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/esptool-js/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClassicReset: () => (/* reexport safe */ _reset_js__WEBPACK_IMPORTED_MODULE_1__.ClassicReset),\n/* harmony export */   CustomReset: () => (/* reexport safe */ _reset_js__WEBPACK_IMPORTED_MODULE_1__.CustomReset),\n/* harmony export */   ESPLoader: () => (/* reexport safe */ _esploader_js__WEBPACK_IMPORTED_MODULE_0__.ESPLoader),\n/* harmony export */   HardReset: () => (/* reexport safe */ _reset_js__WEBPACK_IMPORTED_MODULE_1__.HardReset),\n/* harmony export */   ROM: () => (/* reexport safe */ _targets_rom_js__WEBPACK_IMPORTED_MODULE_2__.ROM),\n/* harmony export */   Transport: () => (/* reexport safe */ _webserial_js__WEBPACK_IMPORTED_MODULE_3__.Transport),\n/* harmony export */   UsbJtagSerialReset: () => (/* reexport safe */ _reset_js__WEBPACK_IMPORTED_MODULE_1__.UsbJtagSerialReset),\n/* harmony export */   decodeBase64Data: () => (/* reexport safe */ _stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__.decodeBase64Data),\n/* harmony export */   getStubJsonByChipName: () => (/* reexport safe */ _stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__.getStubJsonByChipName),\n/* harmony export */   validateCustomResetStringSequence: () => (/* reexport safe */ _reset_js__WEBPACK_IMPORTED_MODULE_1__.validateCustomResetStringSequence)\n/* harmony export */ });\n/* harmony import */ var _esploader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esploader.js */ \"(ssr)/./node_modules/esptool-js/lib/esploader.js\");\n/* harmony import */ var _reset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reset.js */ \"(ssr)/./node_modules/esptool-js/lib/reset.js\");\n/* harmony import */ var _targets_rom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./targets/rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n/* harmony import */ var _webserial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webserial.js */ \"(ssr)/./node_modules/esptool-js/lib/webserial.js\");\n/* harmony import */ var _stubFlasher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stubFlasher.js */ \"(ssr)/./node_modules/esptool-js/lib/stubFlasher.js\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQytFO0FBQ25GO0FBQ0k7QUFDZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvaW5kZXguanM/ODIwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBFU1BMb2FkZXIgfSBmcm9tIFwiLi9lc3Bsb2FkZXIuanNcIjtcbmV4cG9ydCB7IENsYXNzaWNSZXNldCwgQ3VzdG9tUmVzZXQsIEhhcmRSZXNldCwgVXNiSnRhZ1NlcmlhbFJlc2V0LCB2YWxpZGF0ZUN1c3RvbVJlc2V0U3RyaW5nU2VxdWVuY2UsIH0gZnJvbSBcIi4vcmVzZXQuanNcIjtcbmV4cG9ydCB7IFJPTSB9IGZyb20gXCIuL3RhcmdldHMvcm9tLmpzXCI7XG5leHBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi93ZWJzZXJpYWwuanNcIjtcbmV4cG9ydCB7IGRlY29kZUJhc2U2NERhdGEsIGdldFN0dWJKc29uQnlDaGlwTmFtZSB9IGZyb20gXCIuL3N0dWJGbGFzaGVyLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/reset.js":
/*!**********************************************!*\
  !*** ./node_modules/esptool-js/lib/reset.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClassicReset: () => (/* binding */ ClassicReset),\n/* harmony export */   CustomReset: () => (/* binding */ CustomReset),\n/* harmony export */   HardReset: () => (/* binding */ HardReset),\n/* harmony export */   UsbJtagSerialReset: () => (/* binding */ UsbJtagSerialReset),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   validateCustomResetStringSequence: () => (/* binding */ validateCustomResetStringSequence)\n/* harmony export */ });\n/**\n * Sleep for ms milliseconds\n * @param {number} ms Milliseconds to wait\n * @returns {Promise<void>}\n */\nfunction sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n/**\n * Execute a classic set of commands that will reset the chip.\n *\n * Commands (e.g. R0) are defined by a code (R) and an argument (0).\n *\n * The commands are:\n *\n * D: setDTR - 1=True / 0=False\n *\n * R: setRTS - 1=True / 0=False\n *\n * W: Wait (time delay) - positive integer number (miliseconds)\n *\n * \"D0|R1|W100|D1|R0|W50|D0\" represents the classic reset strategy\n * @param {Transport} transport Transport class to perform serial communication.\n * @param {number} resetDelay Delay in milliseconds for reset.\n */\nclass ClassicReset {\n    constructor(transport, resetDelay) {\n        this.resetDelay = resetDelay;\n        this.transport = transport;\n    }\n    async reset() {\n        await this.transport.setDTR(false);\n        await this.transport.setRTS(true);\n        await sleep(100);\n        await this.transport.setDTR(true);\n        await this.transport.setRTS(false);\n        await sleep(this.resetDelay);\n        await this.transport.setDTR(false);\n    }\n}\n/**\n * Execute a set of commands for USB JTAG serial reset.\n *\n * Commands (e.g. R0) are defined by a code (R) and an argument (0).\n *\n * The commands are:\n *\n * D: setDTR - 1=True / 0=False\n *\n * R: setRTS - 1=True / 0=False\n *\n * W: Wait (time delay) - positive integer number (miliseconds)\n * @param {Transport} transport Transport class to perform serial communication.\n */\nclass UsbJtagSerialReset {\n    constructor(transport) {\n        this.transport = transport;\n    }\n    async reset() {\n        await this.transport.setRTS(false);\n        await this.transport.setDTR(false);\n        await sleep(100);\n        await this.transport.setDTR(true);\n        await this.transport.setRTS(false);\n        await sleep(100);\n        await this.transport.setRTS(true);\n        await this.transport.setDTR(false);\n        await this.transport.setRTS(true);\n        await sleep(100);\n        await this.transport.setRTS(false);\n        await this.transport.setDTR(false);\n    }\n}\n/**\n * Execute a set of commands that will hard reset the chip.\n *\n * Commands (e.g. R0) are defined by a code (R) and an argument (0).\n *\n * The commands are:\n *\n * D: setDTR - 1=True / 0=False\n *\n * R: setRTS - 1=True / 0=False\n *\n * W: Wait (time delay) - positive integer number (miliseconds)\n * @param {Transport} transport Transport class to perform serial communication.\n * @param {boolean} usingUsbOtg is it using USB-OTG ?\n */\nclass HardReset {\n    constructor(transport, usingUsbOtg = false) {\n        this.transport = transport;\n        this.usingUsbOtg = usingUsbOtg;\n        this.transport = transport;\n    }\n    async reset() {\n        if (this.usingUsbOtg) {\n            await sleep(200);\n            await this.transport.setRTS(false);\n            await sleep(200);\n        }\n        else {\n            await sleep(100);\n            await this.transport.setRTS(false);\n        }\n    }\n}\n/**\n * Validate a sequence string based on the following format:\n *\n * Commands (e.g. R0) are defined by a code (R) and an argument (0).\n *\n * The commands are:\n *\n * D: setDTR - 1=True / 0=False\n *\n * R: setRTS - 1=True / 0=False\n *\n * W: Wait (time delay) - positive integer number (miliseconds)\n * @param {string} seqStr Sequence string to validate\n * @returns {boolean} Is the sequence string valid ?\n */\nfunction validateCustomResetStringSequence(seqStr) {\n    const commands = [\"D\", \"R\", \"W\"];\n    const commandsList = seqStr.split(\"|\");\n    for (const cmd of commandsList) {\n        const code = cmd[0];\n        const arg = cmd.slice(1);\n        if (!commands.includes(code)) {\n            return false; // Invalid command code\n        }\n        if (code === \"D\" || code === \"R\") {\n            if (arg !== \"0\" && arg !== \"1\") {\n                return false; // Invalid argument for D and R commands\n            }\n        }\n        else if (code === \"W\") {\n            const delay = parseInt(arg);\n            if (isNaN(delay) || delay <= 0) {\n                return false; // Invalid argument for W command\n            }\n        }\n    }\n    return true; // All commands are valid\n}\n/**\n * Custom reset strategy defined with a string.\n *\n * The sequenceString input string consists of individual commands divided by \"|\".\n *\n * Commands (e.g. R0) are defined by a code (R) and an argument (0).\n *\n * The commands are:\n *\n * D: setDTR - 1=True / 0=False\n *\n * R: setRTS - 1=True / 0=False\n *\n * W: Wait (time delay) - positive integer number (miliseconds)\n *\n * \"D0|R1|W100|D1|R0|W50|D0\" represents the classic reset strategy\n * @param {Transport} transport Transport class to perform serial communication.\n * @param {string} sequenceString Custom string sequence for reset strategy\n */\nclass CustomReset {\n    constructor(transport, sequenceString) {\n        this.transport = transport;\n        this.sequenceString = sequenceString;\n        this.transport = transport;\n    }\n    async reset() {\n        const resetDictionary = {\n            D: async (arg) => await this.transport.setDTR(arg),\n            R: async (arg) => await this.transport.setRTS(arg),\n            W: async (delay) => await sleep(delay),\n        };\n        try {\n            const isValidSequence = validateCustomResetStringSequence(this.sequenceString);\n            if (!isValidSequence) {\n                return;\n            }\n            const cmds = this.sequenceString.split(\"|\");\n            for (const cmd of cmds) {\n                const cmdKey = cmd[0];\n                const cmdVal = cmd.slice(1);\n                if (cmdKey === \"W\") {\n                    await resetDictionary[\"W\"](Number(cmdVal));\n                }\n                else if (cmdKey === \"D\" || cmdKey === \"R\") {\n                    await resetDictionary[cmdKey](cmdVal === \"1\");\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(\"Invalid custom reset sequence\");\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ ClassicReset, CustomReset, HardReset, UsbJtagSerialReset, validateCustomResetStringSequence });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvcmVzZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsU0FBUztBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEVBQUUsNkZBQTZGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvcmVzZXQuanM/NWVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNsZWVwIGZvciBtcyBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyBNaWxsaXNlY29uZHMgdG8gd2FpdFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG4vKipcbiAqIEV4ZWN1dGUgYSBjbGFzc2ljIHNldCBvZiBjb21tYW5kcyB0aGF0IHdpbGwgcmVzZXQgdGhlIGNoaXAuXG4gKlxuICogQ29tbWFuZHMgKGUuZy4gUjApIGFyZSBkZWZpbmVkIGJ5IGEgY29kZSAoUikgYW5kIGFuIGFyZ3VtZW50ICgwKS5cbiAqXG4gKiBUaGUgY29tbWFuZHMgYXJlOlxuICpcbiAqIEQ6IHNldERUUiAtIDE9VHJ1ZSAvIDA9RmFsc2VcbiAqXG4gKiBSOiBzZXRSVFMgLSAxPVRydWUgLyAwPUZhbHNlXG4gKlxuICogVzogV2FpdCAodGltZSBkZWxheSkgLSBwb3NpdGl2ZSBpbnRlZ2VyIG51bWJlciAobWlsaXNlY29uZHMpXG4gKlxuICogXCJEMHxSMXxXMTAwfEQxfFIwfFc1MHxEMFwiIHJlcHJlc2VudHMgdGhlIGNsYXNzaWMgcmVzZXQgc3RyYXRlZ3lcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnQgVHJhbnNwb3J0IGNsYXNzIHRvIHBlcmZvcm0gc2VyaWFsIGNvbW11bmljYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzZXREZWxheSBEZWxheSBpbiBtaWxsaXNlY29uZHMgZm9yIHJlc2V0LlxuICovXG5leHBvcnQgY2xhc3MgQ2xhc3NpY1Jlc2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIHJlc2V0RGVsYXkpIHtcbiAgICAgICAgdGhpcy5yZXNldERlbGF5ID0gcmVzZXREZWxheTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIHJlc2V0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXREVFIoZmFsc2UpO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFModHJ1ZSk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUih0cnVlKTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKGZhbHNlKTtcbiAgICAgICAgYXdhaXQgc2xlZXAodGhpcy5yZXNldERlbGF5KTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKGZhbHNlKTtcbiAgICB9XG59XG4vKipcbiAqIEV4ZWN1dGUgYSBzZXQgb2YgY29tbWFuZHMgZm9yIFVTQiBKVEFHIHNlcmlhbCByZXNldC5cbiAqXG4gKiBDb21tYW5kcyAoZS5nLiBSMCkgYXJlIGRlZmluZWQgYnkgYSBjb2RlIChSKSBhbmQgYW4gYXJndW1lbnQgKDApLlxuICpcbiAqIFRoZSBjb21tYW5kcyBhcmU6XG4gKlxuICogRDogc2V0RFRSIC0gMT1UcnVlIC8gMD1GYWxzZVxuICpcbiAqIFI6IHNldFJUUyAtIDE9VHJ1ZSAvIDA9RmFsc2VcbiAqXG4gKiBXOiBXYWl0ICh0aW1lIGRlbGF5KSAtIHBvc2l0aXZlIGludGVnZXIgbnVtYmVyIChtaWxpc2Vjb25kcylcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnQgVHJhbnNwb3J0IGNsYXNzIHRvIHBlcmZvcm0gc2VyaWFsIGNvbW11bmljYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBVc2JKdGFnU2VyaWFsUmVzZXQge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgcmVzZXQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldFJUUyhmYWxzZSk7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUihmYWxzZSk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUih0cnVlKTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKGZhbHNlKTtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKHRydWUpO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXREVFIoZmFsc2UpO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFModHJ1ZSk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldFJUUyhmYWxzZSk7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUihmYWxzZSk7XG4gICAgfVxufVxuLyoqXG4gKiBFeGVjdXRlIGEgc2V0IG9mIGNvbW1hbmRzIHRoYXQgd2lsbCBoYXJkIHJlc2V0IHRoZSBjaGlwLlxuICpcbiAqIENvbW1hbmRzIChlLmcuIFIwKSBhcmUgZGVmaW5lZCBieSBhIGNvZGUgKFIpIGFuZCBhbiBhcmd1bWVudCAoMCkuXG4gKlxuICogVGhlIGNvbW1hbmRzIGFyZTpcbiAqXG4gKiBEOiBzZXREVFIgLSAxPVRydWUgLyAwPUZhbHNlXG4gKlxuICogUjogc2V0UlRTIC0gMT1UcnVlIC8gMD1GYWxzZVxuICpcbiAqIFc6IFdhaXQgKHRpbWUgZGVsYXkpIC0gcG9zaXRpdmUgaW50ZWdlciBudW1iZXIgKG1pbGlzZWNvbmRzKVxuICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydCBUcmFuc3BvcnQgY2xhc3MgdG8gcGVyZm9ybSBzZXJpYWwgY29tbXVuaWNhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNpbmdVc2JPdGcgaXMgaXQgdXNpbmcgVVNCLU9URyA/XG4gKi9cbmV4cG9ydCBjbGFzcyBIYXJkUmVzZXQge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgdXNpbmdVc2JPdGcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy51c2luZ1VzYk90ZyA9IHVzaW5nVXNiT3RnO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzaW5nVXNiT3RnKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKGZhbHNlKTtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGUgYSBzZXF1ZW5jZSBzdHJpbmcgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gKlxuICogQ29tbWFuZHMgKGUuZy4gUjApIGFyZSBkZWZpbmVkIGJ5IGEgY29kZSAoUikgYW5kIGFuIGFyZ3VtZW50ICgwKS5cbiAqXG4gKiBUaGUgY29tbWFuZHMgYXJlOlxuICpcbiAqIEQ6IHNldERUUiAtIDE9VHJ1ZSAvIDA9RmFsc2VcbiAqXG4gKiBSOiBzZXRSVFMgLSAxPVRydWUgLyAwPUZhbHNlXG4gKlxuICogVzogV2FpdCAodGltZSBkZWxheSkgLSBwb3NpdGl2ZSBpbnRlZ2VyIG51bWJlciAobWlsaXNlY29uZHMpXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VxU3RyIFNlcXVlbmNlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IElzIHRoZSBzZXF1ZW5jZSBzdHJpbmcgdmFsaWQgP1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21SZXNldFN0cmluZ1NlcXVlbmNlKHNlcVN0cikge1xuICAgIGNvbnN0IGNvbW1hbmRzID0gW1wiRFwiLCBcIlJcIiwgXCJXXCJdO1xuICAgIGNvbnN0IGNvbW1hbmRzTGlzdCA9IHNlcVN0ci5zcGxpdChcInxcIik7XG4gICAgZm9yIChjb25zdCBjbWQgb2YgY29tbWFuZHNMaXN0KSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBjbWRbMF07XG4gICAgICAgIGNvbnN0IGFyZyA9IGNtZC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFjb21tYW5kcy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnZhbGlkIGNvbW1hbmQgY29kZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID09PSBcIkRcIiB8fCBjb2RlID09PSBcIlJcIikge1xuICAgICAgICAgICAgaWYgKGFyZyAhPT0gXCIwXCIgJiYgYXJnICE9PSBcIjFcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBhcmd1bWVudCBmb3IgRCBhbmQgUiBjb21tYW5kc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IFwiV1wiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHBhcnNlSW50KGFyZyk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGVsYXkpIHx8IGRlbGF5IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEludmFsaWQgYXJndW1lbnQgZm9yIFcgY29tbWFuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyBBbGwgY29tbWFuZHMgYXJlIHZhbGlkXG59XG4vKipcbiAqIEN1c3RvbSByZXNldCBzdHJhdGVneSBkZWZpbmVkIHdpdGggYSBzdHJpbmcuXG4gKlxuICogVGhlIHNlcXVlbmNlU3RyaW5nIGlucHV0IHN0cmluZyBjb25zaXN0cyBvZiBpbmRpdmlkdWFsIGNvbW1hbmRzIGRpdmlkZWQgYnkgXCJ8XCIuXG4gKlxuICogQ29tbWFuZHMgKGUuZy4gUjApIGFyZSBkZWZpbmVkIGJ5IGEgY29kZSAoUikgYW5kIGFuIGFyZ3VtZW50ICgwKS5cbiAqXG4gKiBUaGUgY29tbWFuZHMgYXJlOlxuICpcbiAqIEQ6IHNldERUUiAtIDE9VHJ1ZSAvIDA9RmFsc2VcbiAqXG4gKiBSOiBzZXRSVFMgLSAxPVRydWUgLyAwPUZhbHNlXG4gKlxuICogVzogV2FpdCAodGltZSBkZWxheSkgLSBwb3NpdGl2ZSBpbnRlZ2VyIG51bWJlciAobWlsaXNlY29uZHMpXG4gKlxuICogXCJEMHxSMXxXMTAwfEQxfFIwfFc1MHxEMFwiIHJlcHJlc2VudHMgdGhlIGNsYXNzaWMgcmVzZXQgc3RyYXRlZ3lcbiAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnQgVHJhbnNwb3J0IGNsYXNzIHRvIHBlcmZvcm0gc2VyaWFsIGNvbW11bmljYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VxdWVuY2VTdHJpbmcgQ3VzdG9tIHN0cmluZyBzZXF1ZW5jZSBmb3IgcmVzZXQgc3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbVJlc2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIHNlcXVlbmNlU3RyaW5nKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLnNlcXVlbmNlU3RyaW5nID0gc2VxdWVuY2VTdHJpbmc7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyByZXNldCgpIHtcbiAgICAgICAgY29uc3QgcmVzZXREaWN0aW9uYXJ5ID0ge1xuICAgICAgICAgICAgRDogYXN5bmMgKGFyZykgPT4gYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKGFyZyksXG4gICAgICAgICAgICBSOiBhc3luYyAoYXJnKSA9PiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFMoYXJnKSxcbiAgICAgICAgICAgIFc6IGFzeW5jIChkZWxheSkgPT4gYXdhaXQgc2xlZXAoZGVsYXkpLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNlcXVlbmNlID0gdmFsaWRhdGVDdXN0b21SZXNldFN0cmluZ1NlcXVlbmNlKHRoaXMuc2VxdWVuY2VTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbWRzID0gdGhpcy5zZXF1ZW5jZVN0cmluZy5zcGxpdChcInxcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNtZCBvZiBjbWRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gY21kWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtZFZhbCA9IGNtZC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAoY21kS2V5ID09PSBcIldcIikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXNldERpY3Rpb25hcnlbXCJXXCJdKE51bWJlcihjbWRWYWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21kS2V5ID09PSBcIkRcIiB8fCBjbWRLZXkgPT09IFwiUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc2V0RGljdGlvbmFyeVtjbWRLZXldKGNtZFZhbCA9PT0gXCIxXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY3VzdG9tIHJlc2V0IHNlcXVlbmNlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgeyBDbGFzc2ljUmVzZXQsIEN1c3RvbVJlc2V0LCBIYXJkUmVzZXQsIFVzYkp0YWdTZXJpYWxSZXNldCwgdmFsaWRhdGVDdXN0b21SZXNldFN0cmluZ1NlcXVlbmNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/reset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/stubFlasher.js":
/*!****************************************************!*\
  !*** ./node_modules/esptool-js/lib/stubFlasher.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64Data: () => (/* binding */ decodeBase64Data),\n/* harmony export */   getStubJsonByChipName: () => (/* binding */ getStubJsonByChipName)\n/* harmony export */ });\n/* harmony import */ var atob_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! atob-lite */ \"(ssr)/./node_modules/atob-lite/atob-node.js\");\n/* harmony import */ var atob_lite__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(atob_lite__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Import flash stub json for the given chip name.\n * @param {string} chipName Name of chip to obtain flasher stub\n * @returns {Stub} Stub information and decoded text and data\n */\nasync function getStubJsonByChipName(chipName) {\n    let jsonStub;\n    switch (chipName) {\n        case \"ESP32\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32.json\", 19));\n            break;\n        case \"ESP32-C2\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32c2.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c2.json\", 19));\n            break;\n        case \"ESP32-C3\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32c3.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c3.json\", 19));\n            break;\n        case \"ESP32-C5\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32c5.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c5.json\", 19));\n            break;\n        case \"ESP32-C6\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32c6.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c6.json\", 19));\n            break;\n        case \"ESP32-C61\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32c61.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c61.json\", 19));\n            break;\n        case \"ESP32-H2\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32h2.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32h2.json\", 19));\n            break;\n        case \"ESP32-P4\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32p4.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32p4.json\", 19));\n            break;\n        case \"ESP32-S2\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32s2.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s2.json\", 19));\n            break;\n        case \"ESP32-S3\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_32s3.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s3.json\", 19));\n            break;\n        case \"ESP8266\":\n            jsonStub = await __webpack_require__.e(/*! import() */ \"vendor-chunks/esptool-js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./targets/stub_flasher/stub_flasher_8266.json */ \"(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_8266.json\", 19));\n            break;\n    }\n    if (jsonStub) {\n        return {\n            bss_start: jsonStub.bss_start,\n            data: jsonStub.data,\n            data_start: jsonStub.data_start,\n            entry: jsonStub.entry,\n            text: jsonStub.text,\n            text_start: jsonStub.text_start,\n            decodedData: decodeBase64Data(jsonStub.data),\n            decodedText: decodeBase64Data(jsonStub.text),\n        };\n    }\n    return;\n}\n/**\n * Convert a base 64 string to Uint8Array.\n * @param {string} dataStr Base64 String to decode\n * @returns {Uint8Array} Decoded Uint8Array\n */\nfunction decodeBase64Data(dataStr) {\n    const decoded = atob_lite__WEBPACK_IMPORTED_MODULE_0___default()(dataStr);\n    const chardata = decoded.split(\"\").map(function (x) {\n        return x.charCodeAt(0);\n    });\n    return new Uint8Array(chardata);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvc3R1YkZsYXNoZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtQQUFxRDtBQUNsRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLHFRQUF3RDtBQUNyRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0EsNkJBQTZCLG1RQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ087QUFDUCxvQkFBb0IsZ0RBQUk7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3N0dWJGbGFzaGVyLmpzPzU0OGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF0b2IgZnJvbSBcImF0b2ItbGl0ZVwiO1xuLyoqXG4gKiBJbXBvcnQgZmxhc2ggc3R1YiBqc29uIGZvciB0aGUgZ2l2ZW4gY2hpcCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoaXBOYW1lIE5hbWUgb2YgY2hpcCB0byBvYnRhaW4gZmxhc2hlciBzdHViXG4gKiBAcmV0dXJucyB7U3R1Yn0gU3R1YiBpbmZvcm1hdGlvbiBhbmQgZGVjb2RlZCB0ZXh0IGFuZCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdHViSnNvbkJ5Q2hpcE5hbWUoY2hpcE5hbWUpIHtcbiAgICBsZXQganNvblN0dWI7XG4gICAgc3dpdGNoIChjaGlwTmFtZSkge1xuICAgICAgICBjYXNlIFwiRVNQMzJcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzIuanNvblwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRVNQMzItQzJcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzJjMi5qc29uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJFU1AzMi1DM1wiOlxuICAgICAgICAgICAganNvblN0dWIgPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvc3R1Yl9mbGFzaGVyL3N0dWJfZmxhc2hlcl8zMmMzLmpzb25cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkVTUDMyLUM1XCI6XG4gICAgICAgICAgICBqc29uU3R1YiA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9zdHViX2ZsYXNoZXIvc3R1Yl9mbGFzaGVyXzMyYzUuanNvblwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRVNQMzItQzZcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzJjNi5qc29uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJFU1AzMi1DNjFcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzJjNjEuanNvblwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRVNQMzItSDJcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzJoMi5qc29uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJFU1AzMi1QNFwiOlxuICAgICAgICAgICAganNvblN0dWIgPSBhd2FpdCBpbXBvcnQoXCIuL3RhcmdldHMvc3R1Yl9mbGFzaGVyL3N0dWJfZmxhc2hlcl8zMnA0Lmpzb25cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkVTUDMyLVMyXCI6XG4gICAgICAgICAgICBqc29uU3R1YiA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9zdHViX2ZsYXNoZXIvc3R1Yl9mbGFzaGVyXzMyczIuanNvblwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRVNQMzItUzNcIjpcbiAgICAgICAgICAgIGpzb25TdHViID0gYXdhaXQgaW1wb3J0KFwiLi90YXJnZXRzL3N0dWJfZmxhc2hlci9zdHViX2ZsYXNoZXJfMzJzMy5qc29uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJFU1A4MjY2XCI6XG4gICAgICAgICAgICBqc29uU3R1YiA9IGF3YWl0IGltcG9ydChcIi4vdGFyZ2V0cy9zdHViX2ZsYXNoZXIvc3R1Yl9mbGFzaGVyXzgyNjYuanNvblwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoanNvblN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJzc19zdGFydDoganNvblN0dWIuYnNzX3N0YXJ0LFxuICAgICAgICAgICAgZGF0YToganNvblN0dWIuZGF0YSxcbiAgICAgICAgICAgIGRhdGFfc3RhcnQ6IGpzb25TdHViLmRhdGFfc3RhcnQsXG4gICAgICAgICAgICBlbnRyeToganNvblN0dWIuZW50cnksXG4gICAgICAgICAgICB0ZXh0OiBqc29uU3R1Yi50ZXh0LFxuICAgICAgICAgICAgdGV4dF9zdGFydDoganNvblN0dWIudGV4dF9zdGFydCxcbiAgICAgICAgICAgIGRlY29kZWREYXRhOiBkZWNvZGVCYXNlNjREYXRhKGpzb25TdHViLmRhdGEpLFxuICAgICAgICAgICAgZGVjb2RlZFRleHQ6IGRlY29kZUJhc2U2NERhdGEoanNvblN0dWIudGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBhIGJhc2UgNjQgc3RyaW5nIHRvIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVN0ciBCYXNlNjQgU3RyaW5nIHRvIGRlY29kZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IERlY29kZWQgVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0RGF0YShkYXRhU3RyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGF0b2IoZGF0YVN0cik7XG4gICAgY29uc3QgY2hhcmRhdGEgPSBkZWNvZGVkLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5jaGFyQ29kZUF0KDApO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaGFyZGF0YSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/stubFlasher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32.js":
/*!******************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32ROM: () => (/* binding */ ESP32ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32\";\n        this.IMAGE_CHIP_ID = 0;\n        this.EFUSE_RD_REG_BASE = 0x3ff5a000;\n        this.DR_REG_SYSCON_BASE = 0x3ff66000;\n        this.UART_CLKDIV_REG = 0x3ff40014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x60000078;\n        this.XTAL_CLK_DIVIDER = 1;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0x1000;\n        this.SPI_REG_BASE = 0x3ff42000;\n        this.SPI_USR_OFFS = 0x1c;\n        this.SPI_USR1_OFFS = 0x20;\n        this.SPI_USR2_OFFS = 0x24;\n        this.SPI_W0_OFFS = 0x80;\n        this.SPI_MOSI_DLEN_OFFS = 0x28;\n        this.SPI_MISO_DLEN_OFFS = 0x2c;\n    }\n    async readEfuse(loader, offset) {\n        const addr = this.EFUSE_RD_REG_BASE + 4 * offset;\n        loader.debug(\"Read efuse \" + addr);\n        return await loader.readReg(addr);\n    }\n    async getPkgVersion(loader) {\n        const word3 = await this.readEfuse(loader, 3);\n        let pkgVersion = (word3 >> 9) & 0x07;\n        pkgVersion += ((word3 >> 2) & 0x1) << 3;\n        return pkgVersion;\n    }\n    async getChipRevision(loader) {\n        const word3 = await this.readEfuse(loader, 3);\n        const word5 = await this.readEfuse(loader, 5);\n        const apbCtlDate = await loader.readReg(this.DR_REG_SYSCON_BASE + 0x7c);\n        const revBit0 = (word3 >> 15) & 0x1;\n        const revBit1 = (word5 >> 20) & 0x1;\n        const revBit2 = (apbCtlDate >> 31) & 0x1;\n        if (revBit0 != 0) {\n            if (revBit1 != 0) {\n                if (revBit2 != 0) {\n                    return 3;\n                }\n                else {\n                    return 2;\n                }\n            }\n            else {\n                return 1;\n            }\n        }\n        return 0;\n    }\n    async getChipDescription(loader) {\n        const chipDesc = [\n            \"ESP32-D0WDQ6\",\n            \"ESP32-D0WD\",\n            \"ESP32-D2WD\",\n            \"\",\n            \"ESP32-U4WDH\",\n            \"ESP32-PICO-D4\",\n            \"ESP32-PICO-V3-02\",\n        ];\n        let chipName = \"\";\n        const pkgVersion = await this.getPkgVersion(loader);\n        const chipRevision = await this.getChipRevision(loader);\n        const rev3 = chipRevision == 3;\n        const single_core = (await this.readEfuse(loader, 3)) & (1 << 0);\n        if (single_core != 0) {\n            chipDesc[0] = \"ESP32-S0WDQ6\";\n            chipDesc[1] = \"ESP32-S0WD\";\n        }\n        if (rev3) {\n            chipDesc[5] = \"ESP32-PICO-V3\";\n        }\n        if (pkgVersion >= 0 && pkgVersion <= 6) {\n            chipName = chipDesc[pkgVersion];\n        }\n        else {\n            chipName = \"Unknown ESP32\";\n        }\n        if (rev3 && (pkgVersion === 0 || pkgVersion === 1)) {\n            chipName += \"-V3\";\n        }\n        return chipName + \" (revision \" + chipRevision + \")\";\n    }\n    async getChipFeatures(loader) {\n        const features = [\"Wi-Fi\"];\n        const word3 = await this.readEfuse(loader, 3);\n        const chipVerDisBt = word3 & (1 << 1);\n        if (chipVerDisBt === 0) {\n            features.push(\" BT\");\n        }\n        const chipVerDisAppCpu = word3 & (1 << 0);\n        if (chipVerDisAppCpu !== 0) {\n            features.push(\" Single Core\");\n        }\n        else {\n            features.push(\" Dual Core\");\n        }\n        const chipCpuFreqRated = word3 & (1 << 13);\n        if (chipCpuFreqRated !== 0) {\n            const chipCpuFreqLow = word3 & (1 << 12);\n            if (chipCpuFreqLow !== 0) {\n                features.push(\" 160MHz\");\n            }\n            else {\n                features.push(\" 240MHz\");\n            }\n        }\n        const pkgVersion = await this.getPkgVersion(loader);\n        if ([2, 4, 5, 6].indexOf(pkgVersion) !== -1) {\n            features.push(\" Embedded Flash\");\n        }\n        if (pkgVersion === 6) {\n            features.push(\" Embedded PSRAM\");\n        }\n        const word4 = await this.readEfuse(loader, 4);\n        const adcVref = (word4 >> 8) & 0x1f;\n        if (adcVref !== 0) {\n            features.push(\" VRef calibration in efuse\");\n        }\n        const blk3PartRes = (word3 >> 14) & 0x1;\n        if (blk3PartRes !== 0) {\n            features.push(\" BLK3 partially reserved\");\n        }\n        const word6 = await this.readEfuse(loader, 6);\n        const codingScheme = word6 & 0x3;\n        const codingSchemeArr = [\"None\", \"3/4\", \"Repeat (UNSUPPORTED)\", \"Invalid\"];\n        features.push(\" Coding Scheme \" + codingSchemeArr[codingScheme]);\n        return features;\n    }\n    async getCrystalFreq(loader) {\n        const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;\n        const etsXtal = (loader.transport.baudrate * uartDiv) / 1000000 / this.XTAL_CLK_DIVIDER;\n        let normXtal;\n        if (etsXtal > 33) {\n            normXtal = 40;\n        }\n        else {\n            normXtal = 26;\n        }\n        if (Math.abs(normXtal - etsXtal) > 1) {\n            loader.info(\"WARNING: Unsupported crystal in use\");\n        }\n        return normXtal;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await this.readEfuse(loader, 1);\n        mac0 = mac0 >>> 0;\n        let mac1 = await this.readEfuse(loader, 2);\n        mac1 = mac1 >>> 0;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUN4Qix1QkFBdUIsd0NBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwMzIuanM/NGIyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBST00gfSBmcm9tIFwiLi9yb20uanNcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMlJPTSBleHRlbmRzIFJPTSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuQ0hJUF9OQU1FID0gXCJFU1AzMlwiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSAwO1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFR19CQVNFID0gMHgzZmY1YTAwMDtcbiAgICAgICAgdGhpcy5EUl9SRUdfU1lTQ09OX0JBU0UgPSAweDNmZjY2MDAwO1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX1JFRyA9IDB4M2ZmNDAwMTQ7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfTUFTSyA9IDB4ZmZmZmY7XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg2MDAwMDA3ODtcbiAgICAgICAgdGhpcy5YVEFMX0NMS19ESVZJREVSID0gMTtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5GTEFTSF9XUklURV9TSVpFID0gMHg0MDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAweDEwMDA7XG4gICAgICAgIHRoaXMuU1BJX1JFR19CQVNFID0gMHgzZmY0MjAwMDtcbiAgICAgICAgdGhpcy5TUElfVVNSX09GRlMgPSAweDFjO1xuICAgICAgICB0aGlzLlNQSV9VU1IxX09GRlMgPSAweDIwO1xuICAgICAgICB0aGlzLlNQSV9VU1IyX09GRlMgPSAweDI0O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg4MDtcbiAgICAgICAgdGhpcy5TUElfTU9TSV9ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUyA9IDB4MmM7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRFZnVzZShsb2FkZXIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9SRF9SRUdfQkFTRSArIDQgKiBvZmZzZXQ7XG4gICAgICAgIGxvYWRlci5kZWJ1ZyhcIlJlYWQgZWZ1c2UgXCIgKyBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQa2dWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCB3b3JkMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMyk7XG4gICAgICAgIGxldCBwa2dWZXJzaW9uID0gKHdvcmQzID4+IDkpICYgMHgwNztcbiAgICAgICAgcGtnVmVyc2lvbiArPSAoKHdvcmQzID4+IDIpICYgMHgxKSA8PCAzO1xuICAgICAgICByZXR1cm4gcGtnVmVyc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcFJldmlzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCB3b3JkMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMyk7XG4gICAgICAgIGNvbnN0IHdvcmQ1ID0gYXdhaXQgdGhpcy5yZWFkRWZ1c2UobG9hZGVyLCA1KTtcbiAgICAgICAgY29uc3QgYXBiQ3RsRGF0ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRFJfUkVHX1NZU0NPTl9CQVNFICsgMHg3Yyk7XG4gICAgICAgIGNvbnN0IHJldkJpdDAgPSAod29yZDMgPj4gMTUpICYgMHgxO1xuICAgICAgICBjb25zdCByZXZCaXQxID0gKHdvcmQ1ID4+IDIwKSAmIDB4MTtcbiAgICAgICAgY29uc3QgcmV2Qml0MiA9IChhcGJDdGxEYXRlID4+IDMxKSAmIDB4MTtcbiAgICAgICAgaWYgKHJldkJpdDAgIT0gMCkge1xuICAgICAgICAgICAgaWYgKHJldkJpdDEgIT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXZCaXQyICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBjaGlwRGVzYyA9IFtcbiAgICAgICAgICAgIFwiRVNQMzItRDBXRFE2XCIsXG4gICAgICAgICAgICBcIkVTUDMyLUQwV0RcIixcbiAgICAgICAgICAgIFwiRVNQMzItRDJXRFwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIFwiRVNQMzItVTRXREhcIixcbiAgICAgICAgICAgIFwiRVNQMzItUElDTy1ENFwiLFxuICAgICAgICAgICAgXCJFU1AzMi1QSUNPLVYzLTAyXCIsXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjaGlwTmFtZSA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgY2hpcFJldmlzaW9uID0gYXdhaXQgdGhpcy5nZXRDaGlwUmV2aXNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgcmV2MyA9IGNoaXBSZXZpc2lvbiA9PSAzO1xuICAgICAgICBjb25zdCBzaW5nbGVfY29yZSA9IChhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDMpKSAmICgxIDw8IDApO1xuICAgICAgICBpZiAoc2luZ2xlX2NvcmUgIT0gMCkge1xuICAgICAgICAgICAgY2hpcERlc2NbMF0gPSBcIkVTUDMyLVMwV0RRNlwiO1xuICAgICAgICAgICAgY2hpcERlc2NbMV0gPSBcIkVTUDMyLVMwV0RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2Mykge1xuICAgICAgICAgICAgY2hpcERlc2NbNV0gPSBcIkVTUDMyLVBJQ08tVjNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGtnVmVyc2lvbiA+PSAwICYmIHBrZ1ZlcnNpb24gPD0gNikge1xuICAgICAgICAgICAgY2hpcE5hbWUgPSBjaGlwRGVzY1twa2dWZXJzaW9uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaXBOYW1lID0gXCJVbmtub3duIEVTUDMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldjMgJiYgKHBrZ1ZlcnNpb24gPT09IDAgfHwgcGtnVmVyc2lvbiA9PT0gMSkpIHtcbiAgICAgICAgICAgIGNoaXBOYW1lICs9IFwiLVYzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaXBOYW1lICsgXCIgKHJldmlzaW9uIFwiICsgY2hpcFJldmlzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBGZWF0dXJlcyhsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXCJXaS1GaVwiXTtcbiAgICAgICAgY29uc3Qgd29yZDMgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDMpO1xuICAgICAgICBjb25zdCBjaGlwVmVyRGlzQnQgPSB3b3JkMyAmICgxIDw8IDEpO1xuICAgICAgICBpZiAoY2hpcFZlckRpc0J0ID09PSAwKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIEJUXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaXBWZXJEaXNBcHBDcHUgPSB3b3JkMyAmICgxIDw8IDApO1xuICAgICAgICBpZiAoY2hpcFZlckRpc0FwcENwdSAhPT0gMCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBTaW5nbGUgQ29yZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goXCIgRHVhbCBDb3JlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaXBDcHVGcmVxUmF0ZWQgPSB3b3JkMyAmICgxIDw8IDEzKTtcbiAgICAgICAgaWYgKGNoaXBDcHVGcmVxUmF0ZWQgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaXBDcHVGcmVxTG93ID0gd29yZDMgJiAoMSA8PCAxMik7XG4gICAgICAgICAgICBpZiAoY2hpcENwdUZyZXFMb3cgIT09IDApIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIDE2ME1IelwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goXCIgMjQwTUh6XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgaWYgKFsyLCA0LCA1LCA2XS5pbmRleE9mKHBrZ1ZlcnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBFbWJlZGRlZCBGbGFzaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGtnVmVyc2lvbiA9PT0gNikge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBFbWJlZGRlZCBQU1JBTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkNCA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgNCk7XG4gICAgICAgIGNvbnN0IGFkY1ZyZWYgPSAod29yZDQgPj4gOCkgJiAweDFmO1xuICAgICAgICBpZiAoYWRjVnJlZiAhPT0gMCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChcIiBWUmVmIGNhbGlicmF0aW9uIGluIGVmdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsazNQYXJ0UmVzID0gKHdvcmQzID4+IDE0KSAmIDB4MTtcbiAgICAgICAgaWYgKGJsazNQYXJ0UmVzICE9PSAwKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiIEJMSzMgcGFydGlhbGx5IHJlc2VydmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQ2ID0gYXdhaXQgdGhpcy5yZWFkRWZ1c2UobG9hZGVyLCA2KTtcbiAgICAgICAgY29uc3QgY29kaW5nU2NoZW1lID0gd29yZDYgJiAweDM7XG4gICAgICAgIGNvbnN0IGNvZGluZ1NjaGVtZUFyciA9IFtcIk5vbmVcIiwgXCIzLzRcIiwgXCJSZXBlYXQgKFVOU1VQUE9SVEVEKVwiLCBcIkludmFsaWRcIl07XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCIgQ29kaW5nIFNjaGVtZSBcIiArIGNvZGluZ1NjaGVtZUFycltjb2RpbmdTY2hlbWVdKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgdWFydERpdiA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykpICYgdGhpcy5VQVJUX0NMS0RJVl9NQVNLO1xuICAgICAgICBjb25zdCBldHNYdGFsID0gKGxvYWRlci50cmFuc3BvcnQuYmF1ZHJhdGUgKiB1YXJ0RGl2KSAvIDEwMDAwMDAgLyB0aGlzLlhUQUxfQ0xLX0RJVklERVI7XG4gICAgICAgIGxldCBub3JtWHRhbDtcbiAgICAgICAgaWYgKGV0c1h0YWwgPiAzMykge1xuICAgICAgICAgICAgbm9ybVh0YWwgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1YdGFsID0gMjY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG5vcm1YdGFsIC0gZXRzWHRhbCkgPiAxKSB7XG4gICAgICAgICAgICBsb2FkZXIuaW5mbyhcIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtWHRhbDtcbiAgICB9XG4gICAgX2QyaChkKSB7XG4gICAgICAgIGNvbnN0IGggPSAoK2QpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIGgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoIDogaDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDEpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCB0aGlzLnJlYWRFZnVzZShsb2FkZXIsIDIpO1xuICAgICAgICBtYWMxID0gbWFjMSA+Pj4gMDtcbiAgICAgICAgY29uc3QgbWFjID0gbmV3IFVpbnQ4QXJyYXkoNik7XG4gICAgICAgIG1hY1swXSA9IChtYWMxID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzFdID0gbWFjMSAmIDB4ZmY7XG4gICAgICAgIG1hY1syXSA9IChtYWMwID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIG1hY1szXSA9IChtYWMwID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s0XSA9IChtYWMwID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzVdID0gbWFjMCAmIDB4ZmY7XG4gICAgICAgIHJldHVybiAodGhpcy5fZDJoKG1hY1swXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1sxXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1syXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1szXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s0XSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s1XSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32c2.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32c2.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32C2ROM: () => (/* binding */ ESP32C2ROM)\n/* harmony export */ });\n/* harmony import */ var _esp32c3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esp32c3.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c3.js\");\n\nclass ESP32C2ROM extends _esp32c3_js__WEBPACK_IMPORTED_MODULE_0__.ESP32C3ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-C2\";\n        this.IMAGE_CHIP_ID = 12;\n        this.EFUSE_BASE = 0x60008800;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x040;\n        this.UART_CLKDIV_REG = 0x60000014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x6000007c;\n        this.XTAL_CLK_DIVIDER = 1;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 1;\n        const block1Addr = this.EFUSE_BASE + 0x040;\n        const addr = block1Addr + 4 * numWord;\n        const word3 = await loader.readReg(addr);\n        const pkgVersion = (word3 >> 22) & 0x07;\n        return pkgVersion;\n    }\n    async getChipRevision(loader) {\n        const block1Addr = this.EFUSE_BASE + 0x040;\n        const numWord = 1;\n        const pos = 20;\n        const addr = block1Addr + 4 * numWord;\n        const ret = ((await loader.readReg(addr)) & (0x03 << pos)) >> pos;\n        return ret;\n    }\n    async getChipDescription(loader) {\n        let desc;\n        const pkgVer = await this.getPkgVersion(loader);\n        if (pkgVer === 0 || pkgVer === 1) {\n            desc = \"ESP32-C2\";\n        }\n        else {\n            desc = \"unknown ESP32-C2\";\n        }\n        const chip_rev = await this.getChipRevision(loader);\n        desc += \" (revision \" + chip_rev + \")\";\n        return desc;\n    }\n    async getChipFeatures(loader) {\n        return [\"Wi-Fi\", \"BLE\"];\n    }\n    async getCrystalFreq(loader) {\n        const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;\n        const etsXtal = (loader.transport.baudrate * uartDiv) / 1000000 / this.XTAL_CLK_DIVIDER;\n        let normXtal;\n        if (etsXtal > 33) {\n            normXtal = 40;\n        }\n        else {\n            normXtal = 26;\n        }\n        if (Math.abs(normXtal - etsXtal) > 1) {\n            loader.info(\"WARNING: Unsupported crystal in use\");\n        }\n        return normXtal;\n    }\n    async changeBaudRate(loader) {\n        const rom_with_26M_XTAL = await this.getCrystalFreq(loader);\n        if (rom_with_26M_XTAL === 26) {\n            loader.changeBaud();\n        }\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmMyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQ25DLHlCQUF5QixtREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpb25ib2FyZC11cGxvYWRlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90YXJnZXRzL2VzcDMyYzIuanM/MGVmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFU1AzMkMzUk9NIH0gZnJvbSBcIi4vZXNwMzJjMy5qc1wiO1xuZXhwb3J0IGNsYXNzIEVTUDMyQzJST00gZXh0ZW5kcyBFU1AzMkMzUk9NIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5DSElQX05BTUUgPSBcIkVTUDMyLUMyXCI7XG4gICAgICAgIHRoaXMuSU1BR0VfQ0hJUF9JRCA9IDEyO1xuICAgICAgICB0aGlzLkVGVVNFX0JBU0UgPSAweDYwMDA4ODAwO1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0MDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9SRUcgPSAweDYwMDAwMDE0O1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX01BU0sgPSAweGZmZmZmO1xuICAgICAgICB0aGlzLlVBUlRfREFURV9SRUdfQUREUiA9IDB4NjAwMDAwN2M7XG4gICAgICAgIHRoaXMuWFRBTF9DTEtfRElWSURFUiA9IDE7XG4gICAgICAgIHRoaXMuRkxBU0hfV1JJVEVfU0laRSA9IDB4NDAwO1xuICAgICAgICB0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUID0gMDtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDYwMDAyMDAwO1xuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGtnVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDE7XG4gICAgICAgIGNvbnN0IGJsb2NrMUFkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0MDtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3Qgd29yZDMgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgcGtnVmVyc2lvbiA9ICh3b3JkMyA+PiAyMikgJiAweDA3O1xuICAgICAgICByZXR1cm4gcGtnVmVyc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcFJldmlzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDA7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAxO1xuICAgICAgICBjb25zdCBwb3MgPSAyMDtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmV0ID0gKChhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKSkgJiAoMHgwMyA8PCBwb3MpKSA+PiBwb3M7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihsb2FkZXIpIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGNvbnN0IHBrZ1ZlciA9IGF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihsb2FkZXIpO1xuICAgICAgICBpZiAocGtnVmVyID09PSAwIHx8IHBrZ1ZlciA9PT0gMSkge1xuICAgICAgICAgICAgZGVzYyA9IFwiRVNQMzItQzJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc2MgPSBcInVua25vd24gRVNQMzItQzJcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlwX3JldiA9IGF3YWl0IHRoaXMuZ2V0Q2hpcFJldmlzaW9uKGxvYWRlcik7XG4gICAgICAgIGRlc2MgKz0gXCIgKHJldmlzaW9uIFwiICsgY2hpcF9yZXYgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBGZWF0dXJlcyhsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIFtcIldpLUZpXCIsIFwiQkxFXCJdO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgdWFydERpdiA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykpICYgdGhpcy5VQVJUX0NMS0RJVl9NQVNLO1xuICAgICAgICBjb25zdCBldHNYdGFsID0gKGxvYWRlci50cmFuc3BvcnQuYmF1ZHJhdGUgKiB1YXJ0RGl2KSAvIDEwMDAwMDAgLyB0aGlzLlhUQUxfQ0xLX0RJVklERVI7XG4gICAgICAgIGxldCBub3JtWHRhbDtcbiAgICAgICAgaWYgKGV0c1h0YWwgPiAzMykge1xuICAgICAgICAgICAgbm9ybVh0YWwgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1YdGFsID0gMjY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG5vcm1YdGFsIC0gZXRzWHRhbCkgPiAxKSB7XG4gICAgICAgICAgICBsb2FkZXIuaW5mbyhcIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtWHRhbDtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlQmF1ZFJhdGUobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHJvbV93aXRoXzI2TV9YVEFMID0gYXdhaXQgdGhpcy5nZXRDcnlzdGFsRnJlcShsb2FkZXIpO1xuICAgICAgICBpZiAocm9tX3dpdGhfMjZNX1hUQUwgPT09IDI2KSB7XG4gICAgICAgICAgICBsb2FkZXIuY2hhbmdlQmF1ZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kMmgoZCkge1xuICAgICAgICBjb25zdCBoID0gKCtkKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBoLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaCA6IGg7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRNYWMobG9hZGVyKSB7XG4gICAgICAgIGxldCBtYWMwID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtcbiAgICAgICAgbWFjMCA9IG1hYzAgPj4+IDA7XG4gICAgICAgIGxldCBtYWMxID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHICsgNCk7XG4gICAgICAgIG1hYzEgPSAobWFjMSA+Pj4gMCkgJiAweDAwMDBmZmZmO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgbWFjWzBdID0gKG1hYzEgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbMV0gPSBtYWMxICYgMHhmZjtcbiAgICAgICAgbWFjWzJdID0gKG1hYzAgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgbWFjWzNdID0gKG1hYzAgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gKG1hYzAgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbNV0gPSBtYWMwICYgMHhmZjtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kMmgobWFjWzBdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzFdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzJdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzNdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzRdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzVdKSk7XG4gICAgfVxuICAgIGdldEVyYXNlU2l6ZShvZmZzZXQsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32c2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32c3.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32c3.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32C3ROM: () => (/* binding */ ESP32C3ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32C3ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-C3\";\n        this.IMAGE_CHIP_ID = 5;\n        this.EFUSE_BASE = 0x60008800;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.UART_CLKDIV_REG = 0x3ff40014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x6000007c;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 3;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const word3 = await loader.readReg(addr);\n        const pkgVersion = (word3 >> 21) & 0x07;\n        return pkgVersion;\n    }\n    async getChipRevision(loader) {\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const numWord = 3;\n        const pos = 18;\n        const addr = block1Addr + 4 * numWord;\n        const ret = ((await loader.readReg(addr)) & (0x7 << pos)) >> pos;\n        return ret;\n    }\n    async getMinorChipVersion(loader) {\n        const hiNumWord = 5;\n        const hiAddr = this.EFUSE_BASE + 0x044 + 4 * hiNumWord;\n        const hi = ((await loader.readReg(hiAddr)) >> 23) & 0x01;\n        const lowNumWord = 3;\n        const lowAddr = this.EFUSE_BASE + 0x044 + 4 * lowNumWord;\n        const low = ((await loader.readReg(lowAddr)) >> 18) & 0x07;\n        return (hi << 3) + low;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 5;\n        const addr = this.EFUSE_BASE + 0x044 + 4 * numWord;\n        return ((await loader.readReg(addr)) >> 24) & 0x03;\n    }\n    async getChipDescription(loader) {\n        const chipDesc = {\n            0: \"ESP32-C3 (QFN32)\",\n            1: \"ESP8685 (QFN28)\",\n            2: \"ESP32-C3 AZ (QFN32)\",\n            3: \"ESP8686 (QFN24)\",\n        };\n        const chipIndex = await this.getPkgVersion(loader);\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${chipDesc[chipIndex] || \"Unknown ESP32-C3\"} (revision v${majorRev}.${minorRev})`;\n    }\n    async getFlashCap(loader) {\n        const numWord = 3;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const flashCap = (registerValue >> 27) & 0x07;\n        return flashCap;\n    }\n    async getFlashVendor(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const vendorId = (registerValue >> 0) & 0x07;\n        const vendorMap = {\n            1: \"XMC\",\n            2: \"GD\",\n            3: \"FM\",\n            4: \"TT\",\n            5: \"ZBIT\",\n        };\n        return vendorMap[vendorId] || \"\";\n    }\n    async getChipFeatures(loader) {\n        const features = [\"Wi-Fi\", \"BLE\"];\n        const flashMap = {\n            0: null,\n            1: \"Embedded Flash 4MB\",\n            2: \"Embedded Flash 2MB\",\n            3: \"Embedded Flash 1MB\",\n            4: \"Embedded Flash 8MB\",\n        };\n        const flashCap = await this.getFlashCap(loader);\n        const flashVendor = await this.getFlashVendor(loader);\n        const flash = flashMap[flashCap];\n        const flashDescription = flash !== undefined ? flash : \"Unknown Embedded Flash\";\n        if (flash !== null) {\n            features.push(`${flashDescription} (${flashVendor})`);\n        }\n        return features;\n    }\n    async getCrystalFreq(loader) {\n        return 40;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmMzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDLGFBQWEsU0FBUyxHQUFHLFNBQVM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsR0FBRyxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmMzLmpzPzBjODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUk9NIH0gZnJvbSBcIi4vcm9tLmpzXCI7XG5leHBvcnQgY2xhc3MgRVNQMzJDM1JPTSBleHRlbmRzIFJPTSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuQ0hJUF9OQU1FID0gXCJFU1AzMi1DM1wiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSA1O1xuICAgICAgICB0aGlzLkVGVVNFX0JBU0UgPSAweDYwMDA4ODAwO1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9SRUcgPSAweDNmZjQwMDE0O1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX01BU0sgPSAweGZmZmZmO1xuICAgICAgICB0aGlzLlVBUlRfREFURV9SRUdfQUREUiA9IDB4NjAwMDAwN2M7XG4gICAgICAgIHRoaXMuRkxBU0hfV1JJVEVfU0laRSA9IDB4NDAwO1xuICAgICAgICB0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUID0gMDtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDYwMDAyMDAwO1xuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGtnVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDM7XG4gICAgICAgIGNvbnN0IGJsb2NrMUFkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3Qgd29yZDMgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgcGtnVmVyc2lvbiA9ICh3b3JkMyA+PiAyMSkgJiAweDA3O1xuICAgICAgICByZXR1cm4gcGtnVmVyc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcFJldmlzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICBjb25zdCBwb3MgPSAxODtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmV0ID0gKChhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKSkgJiAoMHg3IDw8IHBvcykpID4+IHBvcztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgaGlOdW1Xb3JkID0gNTtcbiAgICAgICAgY29uc3QgaGlBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQgKyA0ICogaGlOdW1Xb3JkO1xuICAgICAgICBjb25zdCBoaSA9ICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcoaGlBZGRyKSkgPj4gMjMpICYgMHgwMTtcbiAgICAgICAgY29uc3QgbG93TnVtV29yZCA9IDM7XG4gICAgICAgIGNvbnN0IGxvd0FkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NCArIDQgKiBsb3dOdW1Xb3JkO1xuICAgICAgICBjb25zdCBsb3cgPSAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKGxvd0FkZHIpKSA+PiAxOCkgJiAweDA3O1xuICAgICAgICByZXR1cm4gKGhpIDw8IDMpICsgbG93O1xuICAgIH1cbiAgICBhc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gNTtcbiAgICAgICAgY29uc3QgYWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0ICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpKSA+PiAyNCkgJiAweDAzO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGNoaXBEZXNjID0ge1xuICAgICAgICAgICAgMDogXCJFU1AzMi1DMyAoUUZOMzIpXCIsXG4gICAgICAgICAgICAxOiBcIkVTUDg2ODUgKFFGTjI4KVwiLFxuICAgICAgICAgICAgMjogXCJFU1AzMi1DMyBBWiAoUUZOMzIpXCIsXG4gICAgICAgICAgICAzOiBcIkVTUDg2ODYgKFFGTjI0KVwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGlwSW5kZXggPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2NoaXBEZXNjW2NoaXBJbmRleF0gfHwgXCJVbmtub3duIEVTUDMyLUMzXCJ9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hDYXAobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIGNvbnN0IGFkZHIgPSBibG9jazFBZGRyICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVmFsdWUgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgZmxhc2hDYXAgPSAocmVnaXN0ZXJWYWx1ZSA+PiAyNykgJiAweDA3O1xuICAgICAgICByZXR1cm4gZmxhc2hDYXA7XG4gICAgfVxuICAgIGFzeW5jIGdldEZsYXNoVmVuZG9yKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gNDtcbiAgICAgICAgY29uc3QgYmxvY2sxQWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IHZlbmRvcklkID0gKHJlZ2lzdGVyVmFsdWUgPj4gMCkgJiAweDA3O1xuICAgICAgICBjb25zdCB2ZW5kb3JNYXAgPSB7XG4gICAgICAgICAgICAxOiBcIlhNQ1wiLFxuICAgICAgICAgICAgMjogXCJHRFwiLFxuICAgICAgICAgICAgMzogXCJGTVwiLFxuICAgICAgICAgICAgNDogXCJUVFwiLFxuICAgICAgICAgICAgNTogXCJaQklUXCIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2ZW5kb3JNYXBbdmVuZG9ySWRdIHx8IFwiXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBGZWF0dXJlcyhsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXCJXaS1GaVwiLCBcIkJMRVwiXTtcbiAgICAgICAgY29uc3QgZmxhc2hNYXAgPSB7XG4gICAgICAgICAgICAwOiBudWxsLFxuICAgICAgICAgICAgMTogXCJFbWJlZGRlZCBGbGFzaCA0TUJcIixcbiAgICAgICAgICAgIDI6IFwiRW1iZWRkZWQgRmxhc2ggMk1CXCIsXG4gICAgICAgICAgICAzOiBcIkVtYmVkZGVkIEZsYXNoIDFNQlwiLFxuICAgICAgICAgICAgNDogXCJFbWJlZGRlZCBGbGFzaCA4TUJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhc2hDYXAgPSBhd2FpdCB0aGlzLmdldEZsYXNoQ2FwKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IGZsYXNoVmVuZG9yID0gYXdhaXQgdGhpcy5nZXRGbGFzaFZlbmRvcihsb2FkZXIpO1xuICAgICAgICBjb25zdCBmbGFzaCA9IGZsYXNoTWFwW2ZsYXNoQ2FwXTtcbiAgICAgICAgY29uc3QgZmxhc2hEZXNjcmlwdGlvbiA9IGZsYXNoICE9PSB1bmRlZmluZWQgPyBmbGFzaCA6IFwiVW5rbm93biBFbWJlZGRlZCBGbGFzaFwiO1xuICAgICAgICBpZiAoZmxhc2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goYCR7Zmxhc2hEZXNjcmlwdGlvbn0gKCR7Zmxhc2hWZW5kb3J9KWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3J5c3RhbEZyZXEobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiA0MDtcbiAgICB9XG4gICAgX2QyaChkKSB7XG4gICAgICAgIGNvbnN0IGggPSAoK2QpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIGgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoIDogaDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcgKyA0KTtcbiAgICAgICAgbWFjMSA9IChtYWMxID4+PiAwKSAmIDB4MDAwMGZmZmY7XG4gICAgICAgIGNvbnN0IG1hYyA9IG5ldyBVaW50OEFycmF5KDYpO1xuICAgICAgICBtYWNbMF0gPSAobWFjMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1sxXSA9IG1hYzEgJiAweGZmO1xuICAgICAgICBtYWNbMl0gPSAobWFjMCA+PiAyNCkgJiAweGZmO1xuICAgICAgICBtYWNbM10gPSAobWFjMCA+PiAxNikgJiAweGZmO1xuICAgICAgICBtYWNbNF0gPSAobWFjMCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s1XSA9IG1hYzAgJiAweGZmO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2QyaChtYWNbMF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMV0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMl0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbM10pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNV0pKTtcbiAgICB9XG4gICAgZ2V0RXJhc2VTaXplKG9mZnNldCwgc2l6ZSkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32c3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32c5.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32c5.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32C5ROM: () => (/* binding */ ESP32C5ROM)\n/* harmony export */ });\n/* harmony import */ var _esp32c6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esp32c6 */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c6.js\");\n\nclass ESP32C5ROM extends _esp32c6__WEBPACK_IMPORTED_MODULE_0__.ESP32C6ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-C5\";\n        this.IMAGE_CHIP_ID = 23;\n        this.BOOTLOADER_FLASH_OFFSET = 0x2000;\n        this.EFUSE_BASE = 0x600b4800;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.UART_CLKDIV_REG = 0x60000014;\n        this.EFUSE_RD_REG_BASE = this.EFUSE_BASE + 0x030; // BLOCK0 read base address\n        this.EFUSE_PURPOSE_KEY0_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY0_SHIFT = 24;\n        this.EFUSE_PURPOSE_KEY1_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY1_SHIFT = 28;\n        this.EFUSE_PURPOSE_KEY2_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY2_SHIFT = 0;\n        this.EFUSE_PURPOSE_KEY3_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY3_SHIFT = 4;\n        this.EFUSE_PURPOSE_KEY4_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY4_SHIFT = 8;\n        this.EFUSE_PURPOSE_KEY5_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY5_SHIFT = 12;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = this.EFUSE_RD_REG_BASE;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 20;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_REG = this.EFUSE_BASE + 0x034;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18;\n        this.EFUSE_SECURE_BOOT_EN_REG = this.EFUSE_BASE + 0x038;\n        this.EFUSE_SECURE_BOOT_EN_MASK = 1 << 20;\n        this.IROM_MAP_START = 0x42000000;\n        this.IROM_MAP_END = 0x42800000;\n        this.DROM_MAP_START = 0x42800000;\n        this.DROM_MAP_END = 0x43000000;\n        this.PCR_SYSCLK_CONF_REG = 0x60096110;\n        this.PCR_SYSCLK_XTAL_FREQ_V = 0x7f << 24;\n        this.PCR_SYSCLK_XTAL_FREQ_S = 24;\n        this.XTAL_CLK_DIVIDER = 1;\n        this.UARTDEV_BUF_NO = 0x4085f51c; // Variable in ROM .bss which indicates the port in use\n        // Magic value for ESP32C5\n        this.CHIP_DETECT_MAGIC_VALUE = [0x1101406f, 0x63e1406f, 0x5fd1406f];\n        this.FLASH_FREQUENCY = {\n            \"80m\": 0xf,\n            \"40m\": 0x0,\n            \"20m\": 0x2,\n        };\n        this.MEMORY_MAP = [\n            [0x00000000, 0x00010000, \"PADDING\"],\n            [0x42800000, 0x43000000, \"DROM\"],\n            [0x40800000, 0x40860000, \"DRAM\"],\n            [0x40800000, 0x40860000, \"BYTE_ACCESSIBLE\"],\n            [0x4003a000, 0x40040000, \"DROM_MASK\"],\n            [0x40000000, 0x4003a000, \"IROM_MASK\"],\n            [0x42000000, 0x42800000, \"IROM\"],\n            [0x40800000, 0x40860000, \"IRAM\"],\n            [0x50000000, 0x50004000, \"RTC_IRAM\"],\n            [0x50000000, 0x50004000, \"RTC_DRAM\"],\n            [0x600fe000, 0x60100000, \"MEM_INTERNAL2\"],\n        ];\n        this.UF2_FAMILY_ID = 0xf71c0343;\n        this.EFUSE_MAX_KEY = 5;\n        this.KEY_PURPOSES = {\n            0: \"USER/EMPTY\",\n            1: \"ECDSA_KEY\",\n            2: \"XTS_AES_256_KEY_1\",\n            3: \"XTS_AES_256_KEY_2\",\n            4: \"XTS_AES_128_KEY\",\n            5: \"HMAC_DOWN_ALL\",\n            6: \"HMAC_DOWN_JTAG\",\n            7: \"HMAC_DOWN_DIGITAL_SIGNATURE\",\n            8: \"HMAC_UP\",\n            9: \"SECURE_BOOT_DIGEST0\",\n            10: \"SECURE_BOOT_DIGEST1\",\n            11: \"SECURE_BOOT_DIGEST2\",\n            12: \"KM_INIT_KEY\",\n        };\n    }\n    async getPkgVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 26) & 0x07;\n    }\n    async getMinorChipVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 0) & 0x0f;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 4) & 0x03;\n    }\n    async getChipDescription(loader) {\n        const pkgVer = await this.getPkgVersion(loader);\n        let desc;\n        if (pkgVer === 0) {\n            desc = \"ESP32-C5\";\n        }\n        else {\n            desc = \"unknown ESP32-C5\";\n        }\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${desc} (revision v${majorRev}.${minorRev})`;\n    }\n    async getChipFeatures(loader) {\n        return [\"Wi-Fi 6 (dual-band)\", \"BT 5 (LE)\"];\n    }\n    async getCrystalFreq(loader) {\n        // The crystal detection algorithm of ESP32/ESP8266\n        // works for ESP32-C5 as well.\n        const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;\n        const etsXtal = (loader.transport.baudrate * uartDiv) / 1000000 / this.XTAL_CLK_DIVIDER;\n        let normXtal;\n        if (etsXtal > 45) {\n            normXtal = 48;\n        }\n        else if (etsXtal > 33) {\n            normXtal = 40;\n        }\n        else {\n            normXtal = 26;\n        }\n        if (Math.abs(normXtal - etsXtal) > 1) {\n            loader.info(\"WARNING: Unsupported crystal in use\");\n        }\n        return normXtal;\n    }\n    async getCrystalFreqRomExpect(loader) {\n        return (((await loader.readReg(this.PCR_SYSCLK_CONF_REG)) & this.PCR_SYSCLK_XTAL_FREQ_V) >> this.PCR_SYSCLK_XTAL_FREQ_S);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ2hDLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLGFBQWEsU0FBUyxHQUFHLFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmM1LmpzPzQ4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRVNQMzJDNlJPTSB9IGZyb20gXCIuL2VzcDMyYzZcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMkM1Uk9NIGV4dGVuZHMgRVNQMzJDNlJPTSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuQ0hJUF9OQU1FID0gXCJFU1AzMi1DNVwiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSAyMztcbiAgICAgICAgdGhpcy5CT09UTE9BREVSX0ZMQVNIX09GRlNFVCA9IDB4MjAwMDtcbiAgICAgICAgdGhpcy5FRlVTRV9CQVNFID0gMHg2MDBiNDgwMDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzFfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9SRUcgPSAweDYwMDAwMDE0O1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFR19CQVNFID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwMzA7IC8vIEJMT0NLMCByZWFkIGJhc2UgYWRkcmVzc1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9TSElGVCA9IDI0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9TSElGVCA9IDI4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9TSElGVCA9IDA7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4Mzg7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUID0gNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlQgPSA4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9TSElGVCA9IDEyO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVF9SRUcgPSB0aGlzLkVGVVNFX1JEX1JFR19CQVNFO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVCA9IDEgPDwgMjA7XG4gICAgICAgIHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9NQVNLID0gMHg3IDw8IDE4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX01BU0sgPSAxIDw8IDIwO1xuICAgICAgICB0aGlzLklST01fTUFQX1NUQVJUID0gMHg0MjAwMDAwMDtcbiAgICAgICAgdGhpcy5JUk9NX01BUF9FTkQgPSAweDQyODAwMDAwO1xuICAgICAgICB0aGlzLkRST01fTUFQX1NUQVJUID0gMHg0MjgwMDAwMDtcbiAgICAgICAgdGhpcy5EUk9NX01BUF9FTkQgPSAweDQzMDAwMDAwO1xuICAgICAgICB0aGlzLlBDUl9TWVNDTEtfQ09ORl9SRUcgPSAweDYwMDk2MTEwO1xuICAgICAgICB0aGlzLlBDUl9TWVNDTEtfWFRBTF9GUkVRX1YgPSAweDdmIDw8IDI0O1xuICAgICAgICB0aGlzLlBDUl9TWVNDTEtfWFRBTF9GUkVRX1MgPSAyNDtcbiAgICAgICAgdGhpcy5YVEFMX0NMS19ESVZJREVSID0gMTtcbiAgICAgICAgdGhpcy5VQVJUREVWX0JVRl9OTyA9IDB4NDA4NWY1MWM7IC8vIFZhcmlhYmxlIGluIFJPTSAuYnNzIHdoaWNoIGluZGljYXRlcyB0aGUgcG9ydCBpbiB1c2VcbiAgICAgICAgLy8gTWFnaWMgdmFsdWUgZm9yIEVTUDMyQzVcbiAgICAgICAgdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRSA9IFsweDExMDE0MDZmLCAweDYzZTE0MDZmLCAweDVmZDE0MDZmXTtcbiAgICAgICAgdGhpcy5GTEFTSF9GUkVRVUVOQ1kgPSB7XG4gICAgICAgICAgICBcIjgwbVwiOiAweGYsXG4gICAgICAgICAgICBcIjQwbVwiOiAweDAsXG4gICAgICAgICAgICBcIjIwbVwiOiAweDIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuTUVNT1JZX01BUCA9IFtcbiAgICAgICAgICAgIFsweDAwMDAwMDAwLCAweDAwMDEwMDAwLCBcIlBBRERJTkdcIl0sXG4gICAgICAgICAgICBbMHg0MjgwMDAwMCwgMHg0MzAwMDAwMCwgXCJEUk9NXCJdLFxuICAgICAgICAgICAgWzB4NDA4MDAwMDAsIDB4NDA4NjAwMDAsIFwiRFJBTVwiXSxcbiAgICAgICAgICAgIFsweDQwODAwMDAwLCAweDQwODYwMDAwLCBcIkJZVEVfQUNDRVNTSUJMRVwiXSxcbiAgICAgICAgICAgIFsweDQwMDNhMDAwLCAweDQwMDQwMDAwLCBcIkRST01fTUFTS1wiXSxcbiAgICAgICAgICAgIFsweDQwMDAwMDAwLCAweDQwMDNhMDAwLCBcIklST01fTUFTS1wiXSxcbiAgICAgICAgICAgIFsweDQyMDAwMDAwLCAweDQyODAwMDAwLCBcIklST01cIl0sXG4gICAgICAgICAgICBbMHg0MDgwMDAwMCwgMHg0MDg2MDAwMCwgXCJJUkFNXCJdLFxuICAgICAgICAgICAgWzB4NTAwMDAwMDAsIDB4NTAwMDQwMDAsIFwiUlRDX0lSQU1cIl0sXG4gICAgICAgICAgICBbMHg1MDAwMDAwMCwgMHg1MDAwNDAwMCwgXCJSVENfRFJBTVwiXSxcbiAgICAgICAgICAgIFsweDYwMGZlMDAwLCAweDYwMTAwMDAwLCBcIk1FTV9JTlRFUk5BTDJcIl0sXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuVUYyX0ZBTUlMWV9JRCA9IDB4ZjcxYzAzNDM7XG4gICAgICAgIHRoaXMuRUZVU0VfTUFYX0tFWSA9IDU7XG4gICAgICAgIHRoaXMuS0VZX1BVUlBPU0VTID0ge1xuICAgICAgICAgICAgMDogXCJVU0VSL0VNUFRZXCIsXG4gICAgICAgICAgICAxOiBcIkVDRFNBX0tFWVwiLFxuICAgICAgICAgICAgMjogXCJYVFNfQUVTXzI1Nl9LRVlfMVwiLFxuICAgICAgICAgICAgMzogXCJYVFNfQUVTXzI1Nl9LRVlfMlwiLFxuICAgICAgICAgICAgNDogXCJYVFNfQUVTXzEyOF9LRVlcIixcbiAgICAgICAgICAgIDU6IFwiSE1BQ19ET1dOX0FMTFwiLFxuICAgICAgICAgICAgNjogXCJITUFDX0RPV05fSlRBR1wiLFxuICAgICAgICAgICAgNzogXCJITUFDX0RPV05fRElHSVRBTF9TSUdOQVRVUkVcIixcbiAgICAgICAgICAgIDg6IFwiSE1BQ19VUFwiLFxuICAgICAgICAgICAgOTogXCJTRUNVUkVfQk9PVF9ESUdFU1QwXCIsXG4gICAgICAgICAgICAxMDogXCJTRUNVUkVfQk9PVF9ESUdFU1QxXCIsXG4gICAgICAgICAgICAxMTogXCJTRUNVUkVfQk9PVF9ESUdFU1QyXCIsXG4gICAgICAgICAgICAxMjogXCJLTV9JTklUX0tFWVwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRQa2dWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMjtcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkKSkgPj4gMjYpICYgMHgwNztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDI7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDApICYgMHgwZjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFqb3JDaGlwVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDI7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDQpICYgMHgwMztcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBwa2dWZXIgPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGlmIChwa2dWZXIgPT09IDApIHtcbiAgICAgICAgICAgIGRlc2MgPSBcIkVTUDMyLUM1XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXNjID0gXCJ1bmtub3duIEVTUDMyLUM1XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2Rlc2N9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGxvYWRlcikge1xuICAgICAgICByZXR1cm4gW1wiV2ktRmkgNiAoZHVhbC1iYW5kKVwiLCBcIkJUIDUgKExFKVwiXTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3J5c3RhbEZyZXEobG9hZGVyKSB7XG4gICAgICAgIC8vIFRoZSBjcnlzdGFsIGRldGVjdGlvbiBhbGdvcml0aG0gb2YgRVNQMzIvRVNQODI2NlxuICAgICAgICAvLyB3b3JrcyBmb3IgRVNQMzItQzUgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgdWFydERpdiA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykpICYgdGhpcy5VQVJUX0NMS0RJVl9NQVNLO1xuICAgICAgICBjb25zdCBldHNYdGFsID0gKGxvYWRlci50cmFuc3BvcnQuYmF1ZHJhdGUgKiB1YXJ0RGl2KSAvIDEwMDAwMDAgLyB0aGlzLlhUQUxfQ0xLX0RJVklERVI7XG4gICAgICAgIGxldCBub3JtWHRhbDtcbiAgICAgICAgaWYgKGV0c1h0YWwgPiA0NSkge1xuICAgICAgICAgICAgbm9ybVh0YWwgPSA0ODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldHNYdGFsID4gMzMpIHtcbiAgICAgICAgICAgIG5vcm1YdGFsID0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtWHRhbCA9IDI2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhub3JtWHRhbCAtIGV0c1h0YWwpID4gMSkge1xuICAgICAgICAgICAgbG9hZGVyLmluZm8oXCJXQVJOSU5HOiBVbnN1cHBvcnRlZCBjcnlzdGFsIGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybVh0YWw7XG4gICAgfVxuICAgIGFzeW5jIGdldENyeXN0YWxGcmVxUm9tRXhwZWN0KGxvYWRlcikge1xuICAgICAgICByZXR1cm4gKCgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5QQ1JfU1lTQ0xLX0NPTkZfUkVHKSkgJiB0aGlzLlBDUl9TWVNDTEtfWFRBTF9GUkVRX1YpID4+IHRoaXMuUENSX1NZU0NMS19YVEFMX0ZSRVFfUyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32c5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32c6.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32c6.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32C6ROM: () => (/* binding */ ESP32C6ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32C6ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-C6\";\n        this.IMAGE_CHIP_ID = 13;\n        this.EFUSE_BASE = 0x600b0800;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.UART_CLKDIV_REG = 0x3ff40014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x6000007c;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 3;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const word3 = await loader.readReg(addr);\n        const pkgVersion = (word3 >> 21) & 0x07;\n        return pkgVersion;\n    }\n    async getChipRevision(loader) {\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const numWord = 3;\n        const pos = 18;\n        const addr = block1Addr + 4 * numWord;\n        const ret = ((await loader.readReg(addr)) & (0x7 << pos)) >> pos;\n        return ret;\n    }\n    async getChipDescription(loader) {\n        let desc;\n        const pkgVer = await this.getPkgVersion(loader);\n        if (pkgVer === 0) {\n            desc = \"ESP32-C6\";\n        }\n        else {\n            desc = \"unknown ESP32-C6\";\n        }\n        const chipRev = await this.getChipRevision(loader);\n        desc += \" (revision \" + chipRev + \")\";\n        return desc;\n    }\n    async getChipFeatures(loader) {\n        return [\"Wi-Fi 6\", \"BT 5\", \"IEEE802.15.4\"];\n    }\n    async getCrystalFreq(loader) {\n        return 40;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmM2LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpb25ib2FyZC11cGxvYWRlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90YXJnZXRzL2VzcDMyYzYuanM/MzhjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBST00gfSBmcm9tIFwiLi9yb20uanNcIjtcbmV4cG9ydCBjbGFzcyBFU1AzMkM2Uk9NIGV4dGVuZHMgUk9NIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5DSElQX05BTUUgPSBcIkVTUDMyLUM2XCI7XG4gICAgICAgIHRoaXMuSU1BR0VfQ0hJUF9JRCA9IDEzO1xuICAgICAgICB0aGlzLkVGVVNFX0JBU0UgPSAweDYwMGIwODAwO1xuICAgICAgICB0aGlzLkVGVVNFX0JMT0NLMV9BRERSID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIHRoaXMuTUFDX0VGVVNFX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX1JFRyA9IDB4M2ZmNDAwMTQ7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfTUFTSyA9IDB4ZmZmZmY7XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg2MDAwMDA3YztcbiAgICAgICAgdGhpcy5GTEFTSF9XUklURV9TSVpFID0gMHg0MDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAwO1xuICAgICAgICB0aGlzLkZMQVNIX1NJWkVTID0ge1xuICAgICAgICAgICAgXCIxTUJcIjogMHgwMCxcbiAgICAgICAgICAgIFwiMk1CXCI6IDB4MTAsXG4gICAgICAgICAgICBcIjRNQlwiOiAweDIwLFxuICAgICAgICAgICAgXCI4TUJcIjogMHgzMCxcbiAgICAgICAgICAgIFwiMTZNQlwiOiAweDQwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLlNQSV9SRUdfQkFTRSA9IDB4NjAwMDIwMDA7XG4gICAgICAgIHRoaXMuU1BJX1VTUl9PRkZTID0gMHgxODtcbiAgICAgICAgdGhpcy5TUElfVVNSMV9PRkZTID0gMHgxYztcbiAgICAgICAgdGhpcy5TUElfVVNSMl9PRkZTID0gMHgyMDtcbiAgICAgICAgdGhpcy5TUElfTU9TSV9ETEVOX09GRlMgPSAweDI0O1xuICAgICAgICB0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUyA9IDB4Mjg7XG4gICAgICAgIHRoaXMuU1BJX1cwX09GRlMgPSAweDU4O1xuICAgIH1cbiAgICBhc3luYyBnZXRQa2dWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMztcbiAgICAgICAgY29uc3QgYmxvY2sxQWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCB3b3JkMyA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgICAgICBjb25zdCBwa2dWZXJzaW9uID0gKHdvcmQzID4+IDIxKSAmIDB4MDc7XG4gICAgICAgIHJldHVybiBwa2dWZXJzaW9uO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwUmV2aXNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrMUFkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDM7XG4gICAgICAgIGNvbnN0IHBvcyA9IDE4O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZXQgPSAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpKSAmICgweDcgPDwgcG9zKSkgPj4gcG9zO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBjb25zdCBwa2dWZXIgPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgaWYgKHBrZ1ZlciA9PT0gMCkge1xuICAgICAgICAgICAgZGVzYyA9IFwiRVNQMzItQzZcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc2MgPSBcInVua25vd24gRVNQMzItQzZcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlwUmV2ID0gYXdhaXQgdGhpcy5nZXRDaGlwUmV2aXNpb24obG9hZGVyKTtcbiAgICAgICAgZGVzYyArPSBcIiAocmV2aXNpb24gXCIgKyBjaGlwUmV2ICsgXCIpXCI7XG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRmVhdHVyZXMobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBbXCJXaS1GaSA2XCIsIFwiQlQgNVwiLCBcIklFRUU4MDIuMTUuNFwiXTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3J5c3RhbEZyZXEobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiA0MDtcbiAgICB9XG4gICAgX2QyaChkKSB7XG4gICAgICAgIGNvbnN0IGggPSAoK2QpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIGgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoIDogaDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcgKyA0KTtcbiAgICAgICAgbWFjMSA9IChtYWMxID4+PiAwKSAmIDB4MDAwMGZmZmY7XG4gICAgICAgIGNvbnN0IG1hYyA9IG5ldyBVaW50OEFycmF5KDYpO1xuICAgICAgICBtYWNbMF0gPSAobWFjMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1sxXSA9IG1hYzEgJiAweGZmO1xuICAgICAgICBtYWNbMl0gPSAobWFjMCA+PiAyNCkgJiAweGZmO1xuICAgICAgICBtYWNbM10gPSAobWFjMCA+PiAxNikgJiAweGZmO1xuICAgICAgICBtYWNbNF0gPSAobWFjMCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s1XSA9IG1hYzAgJiAweGZmO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2QyaChtYWNbMF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMV0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMl0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbM10pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNV0pKTtcbiAgICB9XG4gICAgZ2V0RXJhc2VTaXplKG9mZnNldCwgc2l6ZSkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32c6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32c61.js":
/*!*********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32c61.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32C61ROM: () => (/* binding */ ESP32C61ROM)\n/* harmony export */ });\n/* harmony import */ var _esp32c6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esp32c6 */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32c6.js\");\n\nclass ESP32C61ROM extends _esp32c6__WEBPACK_IMPORTED_MODULE_0__.ESP32C6ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-C61\";\n        this.IMAGE_CHIP_ID = 20;\n        this.CHIP_DETECT_MAGIC_VALUE = [0x33f0206f, 0x2421606f];\n        this.UART_DATE_REG_ADDR = 0x60000000 + 0x7c;\n        this.EFUSE_BASE = 0x600b4800;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.EFUSE_RD_REG_BASE = this.EFUSE_BASE + 0x030; // BLOCK0 read base address\n        this.EFUSE_PURPOSE_KEY0_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY0_SHIFT = 0;\n        this.EFUSE_PURPOSE_KEY1_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY1_SHIFT = 4;\n        this.EFUSE_PURPOSE_KEY2_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY2_SHIFT = 8;\n        this.EFUSE_PURPOSE_KEY3_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY3_SHIFT = 12;\n        this.EFUSE_PURPOSE_KEY4_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY4_SHIFT = 16;\n        this.EFUSE_PURPOSE_KEY5_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY5_SHIFT = 20;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = this.EFUSE_RD_REG_BASE;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 20;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_REG = this.EFUSE_BASE + 0x030;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 23;\n        this.EFUSE_SECURE_BOOT_EN_REG = this.EFUSE_BASE + 0x034;\n        this.EFUSE_SECURE_BOOT_EN_MASK = 1 << 26;\n        this.FLASH_FREQUENCY = {\n            \"80m\": 0xf,\n            \"40m\": 0x0,\n            \"20m\": 0x2,\n        };\n        this.MEMORY_MAP = [\n            [0x00000000, 0x00010000, \"PADDING\"],\n            [0x41800000, 0x42000000, \"DROM\"],\n            [0x40800000, 0x40860000, \"DRAM\"],\n            [0x40800000, 0x40860000, \"BYTE_ACCESSIBLE\"],\n            [0x4004ac00, 0x40050000, \"DROM_MASK\"],\n            [0x40000000, 0x4004ac00, \"IROM_MASK\"],\n            [0x41000000, 0x41800000, \"IROM\"],\n            [0x40800000, 0x40860000, \"IRAM\"],\n            [0x50000000, 0x50004000, \"RTC_IRAM\"],\n            [0x50000000, 0x50004000, \"RTC_DRAM\"],\n            [0x600fe000, 0x60100000, \"MEM_INTERNAL2\"],\n        ];\n        this.UF2_FAMILY_ID = 0x77d850c4;\n        this.EFUSE_MAX_KEY = 5;\n        this.KEY_PURPOSES = {\n            0: \"USER/EMPTY\",\n            1: \"ECDSA_KEY\",\n            2: \"XTS_AES_256_KEY_1\",\n            3: \"XTS_AES_256_KEY_2\",\n            4: \"XTS_AES_128_KEY\",\n            5: \"HMAC_DOWN_ALL\",\n            6: \"HMAC_DOWN_JTAG\",\n            7: \"HMAC_DOWN_DIGITAL_SIGNATURE\",\n            8: \"HMAC_UP\",\n            9: \"SECURE_BOOT_DIGEST0\",\n            10: \"SECURE_BOOT_DIGEST1\",\n            11: \"SECURE_BOOT_DIGEST2\",\n            12: \"KM_INIT_KEY\",\n            13: \"XTS_AES_256_KEY_1_PSRAM\",\n            14: \"XTS_AES_256_KEY_2_PSRAM\",\n            15: \"XTS_AES_128_KEY_PSRAM\",\n        };\n    }\n    async getPkgVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 26) & 0x07;\n    }\n    async getMinorChipVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 0) & 0x0f;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 2;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 4) & 0x03;\n    }\n    async getChipDescription(loader) {\n        const pkgVer = await this.getPkgVersion(loader);\n        let desc;\n        if (pkgVer === 0) {\n            desc = \"ESP32-C61\";\n        }\n        else {\n            desc = \"unknown ESP32-C61\";\n        }\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${desc} (revision v${majorRev}.${minorRev})`;\n    }\n    async getChipFeatures(loader) {\n        return [\"WiFi 6\", \"BT 5\"];\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmM2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUNoQywwQkFBMEIsZ0RBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSxhQUFhLFNBQVMsR0FBRyxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmM2MS5qcz8yN2E4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVTUDMyQzZST00gfSBmcm9tIFwiLi9lc3AzMmM2XCI7XG5leHBvcnQgY2xhc3MgRVNQMzJDNjFST00gZXh0ZW5kcyBFU1AzMkM2Uk9NIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5DSElQX05BTUUgPSBcIkVTUDMyLUM2MVwiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSAyMDtcbiAgICAgICAgdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRSA9IFsweDMzZjAyMDZmLCAweDI0MjE2MDZmXTtcbiAgICAgICAgdGhpcy5VQVJUX0RBVEVfUkVHX0FERFIgPSAweDYwMDAwMDAwICsgMHg3YztcbiAgICAgICAgdGhpcy5FRlVTRV9CQVNFID0gMHg2MDBiNDgwMDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzFfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5FRlVTRV9SRF9SRUdfQkFTRSA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDMwOyAvLyBCTE9DSzAgcmVhZCBiYXNlIGFkZHJlc3NcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfU0hJRlQgPSAwO1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9TSElGVCA9IDQ7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MzQ7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1NISUZUID0gODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfU0hJRlQgPSAxMjtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlQgPSAxNjtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfU0hJRlQgPSAyMDtcbiAgICAgICAgdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFRfUkVHID0gdGhpcy5FRlVTRV9SRF9SRUdfQkFTRTtcbiAgICAgICAgdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFQgPSAxIDw8IDIwO1xuICAgICAgICB0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDAzMDtcbiAgICAgICAgdGhpcy5FRlVTRV9TUElfQk9PVF9DUllQVF9DTlRfTUFTSyA9IDB4NyA8PCAyMztcbiAgICAgICAgdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDAzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9NQVNLID0gMSA8PCAyNjtcbiAgICAgICAgdGhpcy5GTEFTSF9GUkVRVUVOQ1kgPSB7XG4gICAgICAgICAgICBcIjgwbVwiOiAweGYsXG4gICAgICAgICAgICBcIjQwbVwiOiAweDAsXG4gICAgICAgICAgICBcIjIwbVwiOiAweDIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuTUVNT1JZX01BUCA9IFtcbiAgICAgICAgICAgIFsweDAwMDAwMDAwLCAweDAwMDEwMDAwLCBcIlBBRERJTkdcIl0sXG4gICAgICAgICAgICBbMHg0MTgwMDAwMCwgMHg0MjAwMDAwMCwgXCJEUk9NXCJdLFxuICAgICAgICAgICAgWzB4NDA4MDAwMDAsIDB4NDA4NjAwMDAsIFwiRFJBTVwiXSxcbiAgICAgICAgICAgIFsweDQwODAwMDAwLCAweDQwODYwMDAwLCBcIkJZVEVfQUNDRVNTSUJMRVwiXSxcbiAgICAgICAgICAgIFsweDQwMDRhYzAwLCAweDQwMDUwMDAwLCBcIkRST01fTUFTS1wiXSxcbiAgICAgICAgICAgIFsweDQwMDAwMDAwLCAweDQwMDRhYzAwLCBcIklST01fTUFTS1wiXSxcbiAgICAgICAgICAgIFsweDQxMDAwMDAwLCAweDQxODAwMDAwLCBcIklST01cIl0sXG4gICAgICAgICAgICBbMHg0MDgwMDAwMCwgMHg0MDg2MDAwMCwgXCJJUkFNXCJdLFxuICAgICAgICAgICAgWzB4NTAwMDAwMDAsIDB4NTAwMDQwMDAsIFwiUlRDX0lSQU1cIl0sXG4gICAgICAgICAgICBbMHg1MDAwMDAwMCwgMHg1MDAwNDAwMCwgXCJSVENfRFJBTVwiXSxcbiAgICAgICAgICAgIFsweDYwMGZlMDAwLCAweDYwMTAwMDAwLCBcIk1FTV9JTlRFUk5BTDJcIl0sXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuVUYyX0ZBTUlMWV9JRCA9IDB4NzdkODUwYzQ7XG4gICAgICAgIHRoaXMuRUZVU0VfTUFYX0tFWSA9IDU7XG4gICAgICAgIHRoaXMuS0VZX1BVUlBPU0VTID0ge1xuICAgICAgICAgICAgMDogXCJVU0VSL0VNUFRZXCIsXG4gICAgICAgICAgICAxOiBcIkVDRFNBX0tFWVwiLFxuICAgICAgICAgICAgMjogXCJYVFNfQUVTXzI1Nl9LRVlfMVwiLFxuICAgICAgICAgICAgMzogXCJYVFNfQUVTXzI1Nl9LRVlfMlwiLFxuICAgICAgICAgICAgNDogXCJYVFNfQUVTXzEyOF9LRVlcIixcbiAgICAgICAgICAgIDU6IFwiSE1BQ19ET1dOX0FMTFwiLFxuICAgICAgICAgICAgNjogXCJITUFDX0RPV05fSlRBR1wiLFxuICAgICAgICAgICAgNzogXCJITUFDX0RPV05fRElHSVRBTF9TSUdOQVRVUkVcIixcbiAgICAgICAgICAgIDg6IFwiSE1BQ19VUFwiLFxuICAgICAgICAgICAgOTogXCJTRUNVUkVfQk9PVF9ESUdFU1QwXCIsXG4gICAgICAgICAgICAxMDogXCJTRUNVUkVfQk9PVF9ESUdFU1QxXCIsXG4gICAgICAgICAgICAxMTogXCJTRUNVUkVfQk9PVF9ESUdFU1QyXCIsXG4gICAgICAgICAgICAxMjogXCJLTV9JTklUX0tFWVwiLFxuICAgICAgICAgICAgMTM6IFwiWFRTX0FFU18yNTZfS0VZXzFfUFNSQU1cIixcbiAgICAgICAgICAgIDE0OiBcIlhUU19BRVNfMjU2X0tFWV8yX1BTUkFNXCIsXG4gICAgICAgICAgICAxNTogXCJYVFNfQUVTXzEyOF9LRVlfUFNSQU1cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UGtnVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDI7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDI2KSAmIDB4MDc7XG4gICAgfVxuICAgIGFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAyO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAwKSAmIDB4MGY7XG4gICAgfVxuICAgIGFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAyO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiA0KSAmIDB4MDM7XG4gICAgfVxuICAgIGFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgcGtnVmVyID0gYXdhaXQgdGhpcy5nZXRQa2dWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBpZiAocGtnVmVyID09PSAwKSB7XG4gICAgICAgICAgICBkZXNjID0gXCJFU1AzMi1DNjFcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc2MgPSBcInVua25vd24gRVNQMzItQzYxXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2Rlc2N9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGxvYWRlcikge1xuICAgICAgICByZXR1cm4gW1wiV2lGaSA2XCIsIFwiQlQgNVwiXTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZE1hYyhsb2FkZXIpIHtcbiAgICAgICAgbGV0IG1hYzAgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO1xuICAgICAgICBtYWMwID0gbWFjMCA+Pj4gMDtcbiAgICAgICAgbGV0IG1hYzEgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcgKyA0KTtcbiAgICAgICAgbWFjMSA9IChtYWMxID4+PiAwKSAmIDB4MDAwMGZmZmY7XG4gICAgICAgIGNvbnN0IG1hYyA9IG5ldyBVaW50OEFycmF5KDYpO1xuICAgICAgICBtYWNbMF0gPSAobWFjMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1sxXSA9IG1hYzEgJiAweGZmO1xuICAgICAgICBtYWNbMl0gPSAobWFjMCA+PiAyNCkgJiAweGZmO1xuICAgICAgICBtYWNbM10gPSAobWFjMCA+PiAxNikgJiAweGZmO1xuICAgICAgICBtYWNbNF0gPSAobWFjMCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s1XSA9IG1hYzAgJiAweGZmO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2QyaChtYWNbMF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMV0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbMl0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbM10pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNF0pICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIHRoaXMuX2QyaChtYWNbNV0pKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32c61.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32h2.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32h2.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32H2ROM: () => (/* binding */ ESP32H2ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32H2ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-H2\";\n        this.IMAGE_CHIP_ID = 16;\n        this.EFUSE_BASE = 0x600b0800;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.UART_CLKDIV_REG = 0x3ff40014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x6000007c;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0x0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n        this.USB_RAM_BLOCK = 0x800;\n        this.UARTDEV_BUF_NO_USB = 3;\n        this.UARTDEV_BUF_NO = 0x3fcef14c;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 4;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 0) & 0x07;\n    }\n    async getMinorChipVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 18) & 0x07;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 21) & 0x03;\n    }\n    async getChipDescription(loader) {\n        const pkgVer = await this.getPkgVersion(loader);\n        let desc;\n        if (pkgVer === 0) {\n            desc = \"ESP32-H2\";\n        }\n        else {\n            desc = \"unknown ESP32-H2\";\n        }\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${desc} (revision v${majorRev}.${minorRev})`;\n    }\n    async getChipFeatures(loader) {\n        return [\"BT 5 (LE)\", \"IEEE802.15.4\", \"Single Core\", \"96MHz\"];\n    }\n    async getCrystalFreq(loader) {\n        // ESP32H2 XTAL is fixed to 32MHz\n        return 32;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async postConnect(loader) {\n        const bufNo = (await loader.readReg(this.UARTDEV_BUF_NO)) & 0xff;\n        loader.debug(\"In _post_connect \" + bufNo);\n        if (bufNo == this.UARTDEV_BUF_NO_USB) {\n            loader.ESP_RAM_BLOCK = this.USB_RAM_BLOCK;\n        }\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMmgyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sYUFBYSxTQUFTLEdBQUcsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwMzJoMi5qcz9iM2NiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJPTSB9IGZyb20gXCIuL3JvbS5qc1wiO1xuZXhwb3J0IGNsYXNzIEVTUDMySDJST00gZXh0ZW5kcyBST00ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLkNISVBfTkFNRSA9IFwiRVNQMzItSDJcIjtcbiAgICAgICAgdGhpcy5JTUFHRV9DSElQX0lEID0gMTY7XG4gICAgICAgIHRoaXMuRUZVU0VfQkFTRSA9IDB4NjAwYjA4MDA7XG4gICAgICAgIHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5NQUNfRUZVU0VfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfUkVHID0gMHgzZmY0MDAxNDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9NQVNLID0gMHhmZmZmZjtcbiAgICAgICAgdGhpcy5VQVJUX0RBVEVfUkVHX0FERFIgPSAweDYwMDAwMDdjO1xuICAgICAgICB0aGlzLkZMQVNIX1dSSVRFX1NJWkUgPSAweDQwMDtcbiAgICAgICAgdGhpcy5CT09UTE9BREVSX0ZMQVNIX09GRlNFVCA9IDB4MDtcbiAgICAgICAgdGhpcy5GTEFTSF9TSVpFUyA9IHtcbiAgICAgICAgICAgIFwiMU1CXCI6IDB4MDAsXG4gICAgICAgICAgICBcIjJNQlwiOiAweDEwLFxuICAgICAgICAgICAgXCI0TUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiOE1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjE2TUJcIjogMHg0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDYwMDAyMDAwO1xuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICAgICAgdGhpcy5VU0JfUkFNX0JMT0NLID0gMHg4MDA7XG4gICAgICAgIHRoaXMuVUFSVERFVl9CVUZfTk9fVVNCID0gMztcbiAgICAgICAgdGhpcy5VQVJUREVWX0JVRl9OTyA9IDB4M2ZjZWYxNGM7XG4gICAgfVxuICAgIGFzeW5jIGdldFBrZ1ZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAwKSAmIDB4MDc7XG4gICAgfVxuICAgIGFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAxOCkgJiAweDA3O1xuICAgIH1cbiAgICBhc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMztcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkKSkgPj4gMjEpICYgMHgwMztcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBwa2dWZXIgPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGlmIChwa2dWZXIgPT09IDApIHtcbiAgICAgICAgICAgIGRlc2MgPSBcIkVTUDMyLUgyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXNjID0gXCJ1bmtub3duIEVTUDMyLUgyXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2Rlc2N9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGxvYWRlcikge1xuICAgICAgICByZXR1cm4gW1wiQlQgNSAoTEUpXCIsIFwiSUVFRTgwMi4xNS40XCIsIFwiU2luZ2xlIENvcmVcIiwgXCI5Nk1IelwiXTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3J5c3RhbEZyZXEobG9hZGVyKSB7XG4gICAgICAgIC8vIEVTUDMySDIgWFRBTCBpcyBmaXhlZCB0byAzMk1IelxuICAgICAgICByZXR1cm4gMzI7XG4gICAgfVxuICAgIF9kMmgoZCkge1xuICAgICAgICBjb25zdCBoID0gKCtkKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBoLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaCA6IGg7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RDb25uZWN0KGxvYWRlcikge1xuICAgICAgICBjb25zdCBidWZObyA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRERVZfQlVGX05PKSkgJiAweGZmO1xuICAgICAgICBsb2FkZXIuZGVidWcoXCJJbiBfcG9zdF9jb25uZWN0IFwiICsgYnVmTm8pO1xuICAgICAgICBpZiAoYnVmTm8gPT0gdGhpcy5VQVJUREVWX0JVRl9OT19VU0IpIHtcbiAgICAgICAgICAgIGxvYWRlci5FU1BfUkFNX0JMT0NLID0gdGhpcy5VU0JfUkFNX0JMT0NLO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRNYWMobG9hZGVyKSB7XG4gICAgICAgIGxldCBtYWMwID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtcbiAgICAgICAgbWFjMCA9IG1hYzAgPj4+IDA7XG4gICAgICAgIGxldCBtYWMxID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHICsgNCk7XG4gICAgICAgIG1hYzEgPSAobWFjMSA+Pj4gMCkgJiAweDAwMDBmZmZmO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgbWFjWzBdID0gKG1hYzEgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbMV0gPSBtYWMxICYgMHhmZjtcbiAgICAgICAgbWFjWzJdID0gKG1hYzAgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgbWFjWzNdID0gKG1hYzAgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gKG1hYzAgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbNV0gPSBtYWMwICYgMHhmZjtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kMmgobWFjWzBdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzFdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzJdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzNdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzRdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzVdKSk7XG4gICAgfVxuICAgIGdldEVyYXNlU2l6ZShvZmZzZXQsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32h2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32p4.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32p4.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32P4ROM: () => (/* binding */ ESP32P4ROM)\n/* harmony export */ });\n/* harmony import */ var _esp32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./esp32.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/esp32.js\");\n\nclass ESP32P4ROM extends _esp32_js__WEBPACK_IMPORTED_MODULE_0__.ESP32ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-P4\";\n        this.IMAGE_CHIP_ID = 18;\n        this.IROM_MAP_START = 0x40000000;\n        this.IROM_MAP_END = 0x4c000000;\n        this.DROM_MAP_START = 0x40000000;\n        this.DROM_MAP_END = 0x4c000000;\n        this.BOOTLOADER_FLASH_OFFSET = 0x2000; // First 2 sectors are reserved for FE purposes\n        this.CHIP_DETECT_MAGIC_VALUE = [0x0, 0x0addbad0];\n        this.UART_DATE_REG_ADDR = 0x500ca000 + 0x8c;\n        this.EFUSE_BASE = 0x5012d000;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.SPI_REG_BASE = 0x5008d000; // SPIMEM1\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n        this.EFUSE_RD_REG_BASE = this.EFUSE_BASE + 0x030; // BLOCK0 read base address\n        this.EFUSE_PURPOSE_KEY0_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY0_SHIFT = 24;\n        this.EFUSE_PURPOSE_KEY1_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY1_SHIFT = 28;\n        this.EFUSE_PURPOSE_KEY2_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY2_SHIFT = 0;\n        this.EFUSE_PURPOSE_KEY3_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY3_SHIFT = 4;\n        this.EFUSE_PURPOSE_KEY4_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY4_SHIFT = 8;\n        this.EFUSE_PURPOSE_KEY5_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY5_SHIFT = 12;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = this.EFUSE_RD_REG_BASE;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 20;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_REG = this.EFUSE_BASE + 0x034;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18;\n        this.EFUSE_SECURE_BOOT_EN_REG = this.EFUSE_BASE + 0x038;\n        this.EFUSE_SECURE_BOOT_EN_MASK = 1 << 20;\n        this.PURPOSE_VAL_XTS_AES256_KEY_1 = 2;\n        this.PURPOSE_VAL_XTS_AES256_KEY_2 = 3;\n        this.PURPOSE_VAL_XTS_AES128_KEY = 4;\n        this.SUPPORTS_ENCRYPTED_FLASH = true;\n        this.FLASH_ENCRYPTED_WRITE_ALIGN = 16;\n        this.MEMORY_MAP = [\n            [0x00000000, 0x00010000, \"PADDING\"],\n            [0x40000000, 0x4c000000, \"DROM\"],\n            [0x4ff00000, 0x4ffa0000, \"DRAM\"],\n            [0x4ff00000, 0x4ffa0000, \"BYTE_ACCESSIBLE\"],\n            [0x4fc00000, 0x4fc20000, \"DROM_MASK\"],\n            [0x4fc00000, 0x4fc20000, \"IROM_MASK\"],\n            [0x40000000, 0x4c000000, \"IROM\"],\n            [0x4ff00000, 0x4ffa0000, \"IRAM\"],\n            [0x50108000, 0x50110000, \"RTC_IRAM\"],\n            [0x50108000, 0x50110000, \"RTC_DRAM\"],\n            [0x600fe000, 0x60100000, \"MEM_INTERNAL2\"],\n        ];\n        this.UF2_FAMILY_ID = 0x3d308e94;\n        this.EFUSE_MAX_KEY = 5;\n        this.KEY_PURPOSES = {\n            0: \"USER/EMPTY\",\n            1: \"ECDSA_KEY\",\n            2: \"XTS_AES_256_KEY_1\",\n            3: \"XTS_AES_256_KEY_2\",\n            4: \"XTS_AES_128_KEY\",\n            5: \"HMAC_DOWN_ALL\",\n            6: \"HMAC_DOWN_JTAG\",\n            7: \"HMAC_DOWN_DIGITAL_SIGNATURE\",\n            8: \"HMAC_UP\",\n            9: \"SECURE_BOOT_DIGEST0\",\n            10: \"SECURE_BOOT_DIGEST1\",\n            11: \"SECURE_BOOT_DIGEST2\",\n            12: \"KM_INIT_KEY\",\n        };\n    }\n    async getPkgVersion(loader) {\n        const numWord = 2;\n        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        return (registerValue >> 27) & 0x07;\n    }\n    async getMinorChipVersion(loader) {\n        const numWord = 2;\n        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        return (registerValue >> 0) & 0x0f;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 2;\n        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        return (registerValue >> 4) & 0x03;\n    }\n    async getChipDescription(loader) {\n        const pkgVersion = await this.getPkgVersion(loader);\n        const chipName = pkgVersion === 0 ? \"ESP32-P4\" : \"unknown ESP32-P4\";\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${chipName} (revision v${majorRev}.${minorRev})`;\n    }\n    async getChipFeatures(loader) {\n        return [\"High-Performance MCU\"];\n    }\n    async getCrystalFreq(loader) {\n        return 40; // ESP32P4 XTAL is fixed to 40MHz\n    }\n    async getFlashVoltage(loader) {\n        return;\n    }\n    async overrideVddsdio(loader) {\n        loader.debug(\"VDD_SDIO overrides are not supported for ESP32-P4\");\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    async getFlashCryptConfig(loader) {\n        return; // doesn't exist on ESP32-P4\n    }\n    async getSecureBootEnabled(laoder) {\n        const registerValue = await laoder.readReg(this.EFUSE_SECURE_BOOT_EN_REG);\n        return registerValue & this.EFUSE_SECURE_BOOT_EN_MASK;\n    }\n    async getKeyBlockPurpose(loader, keyBlock) {\n        if (keyBlock < 0 || keyBlock > this.EFUSE_MAX_KEY) {\n            loader.debug(`Valid key block numbers must be in range 0-${this.EFUSE_MAX_KEY}`);\n            return;\n        }\n        const regShiftDictionary = [\n            [this.EFUSE_PURPOSE_KEY0_REG, this.EFUSE_PURPOSE_KEY0_SHIFT],\n            [this.EFUSE_PURPOSE_KEY1_REG, this.EFUSE_PURPOSE_KEY1_SHIFT],\n            [this.EFUSE_PURPOSE_KEY2_REG, this.EFUSE_PURPOSE_KEY2_SHIFT],\n            [this.EFUSE_PURPOSE_KEY3_REG, this.EFUSE_PURPOSE_KEY3_SHIFT],\n            [this.EFUSE_PURPOSE_KEY4_REG, this.EFUSE_PURPOSE_KEY4_SHIFT],\n            [this.EFUSE_PURPOSE_KEY5_REG, this.EFUSE_PURPOSE_KEY5_SHIFT],\n        ];\n        const [reg, shift] = regShiftDictionary[keyBlock];\n        const registerValue = await loader.readReg(reg);\n        return (registerValue >> shift) & 0xf;\n    }\n    async isFlashEncryptionKeyValid(loader) {\n        const purposes = [];\n        for (let i = 0; i <= this.EFUSE_MAX_KEY; i++) {\n            const purpose = await this.getKeyBlockPurpose(loader, i);\n            purposes.push(purpose);\n        }\n        const isXtsAes128Key = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES128_KEY);\n        if (typeof isXtsAes128Key !== undefined) {\n            return true;\n        }\n        const isXtsAes256Key1 = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES256_KEY_1);\n        const isXtsAes256Key2 = purposes.find((p) => p === this.PURPOSE_VAL_XTS_AES256_KEY_2);\n        if (typeof isXtsAes256Key1 !== undefined && typeof isXtsAes256Key2 !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMnA0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDO0FBQy9CLHlCQUF5QiwrQ0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxhQUFhLFNBQVMsR0FBRyxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpb25ib2FyZC11cGxvYWRlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90YXJnZXRzL2VzcDMycDQuanM/MTlmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFU1AzMlJPTSB9IGZyb20gXCIuL2VzcDMyLmpzXCI7XG5leHBvcnQgY2xhc3MgRVNQMzJQNFJPTSBleHRlbmRzIEVTUDMyUk9NIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5DSElQX05BTUUgPSBcIkVTUDMyLVA0XCI7XG4gICAgICAgIHRoaXMuSU1BR0VfQ0hJUF9JRCA9IDE4O1xuICAgICAgICB0aGlzLklST01fTUFQX1NUQVJUID0gMHg0MDAwMDAwMDtcbiAgICAgICAgdGhpcy5JUk9NX01BUF9FTkQgPSAweDRjMDAwMDAwO1xuICAgICAgICB0aGlzLkRST01fTUFQX1NUQVJUID0gMHg0MDAwMDAwMDtcbiAgICAgICAgdGhpcy5EUk9NX01BUF9FTkQgPSAweDRjMDAwMDAwO1xuICAgICAgICB0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUID0gMHgyMDAwOyAvLyBGaXJzdCAyIHNlY3RvcnMgYXJlIHJlc2VydmVkIGZvciBGRSBwdXJwb3Nlc1xuICAgICAgICB0aGlzLkNISVBfREVURUNUX01BR0lDX1ZBTFVFID0gWzB4MCwgMHgwYWRkYmFkMF07XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg1MDBjYTAwMCArIDB4OGM7XG4gICAgICAgIHRoaXMuRUZVU0VfQkFTRSA9IDB4NTAxMmQwMDA7XG4gICAgICAgIHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5NQUNfRUZVU0VfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIHRoaXMuU1BJX1JFR19CQVNFID0gMHg1MDA4ZDAwMDsgLy8gU1BJTUVNMVxuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICAgICAgdGhpcy5FRlVTRV9SRF9SRUdfQkFTRSA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDMwOyAvLyBCTE9DSzAgcmVhZCBiYXNlIGFkZHJlc3NcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfU0hJRlQgPSAyNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfU0hJRlQgPSAyODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfU0hJRlQgPSAwO1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZM19SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZM19TSElGVCA9IDQ7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4Mzg7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1NISUZUID0gODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfU0hJRlQgPSAxMjtcbiAgICAgICAgdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFRfUkVHID0gdGhpcy5FRlVTRV9SRF9SRUdfQkFTRTtcbiAgICAgICAgdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFQgPSAxIDw8IDIwO1xuICAgICAgICB0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDAzNDtcbiAgICAgICAgdGhpcy5FRlVTRV9TUElfQk9PVF9DUllQVF9DTlRfTUFTSyA9IDB4NyA8PCAxODtcbiAgICAgICAgdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDAzODtcbiAgICAgICAgdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9NQVNLID0gMSA8PCAyMDtcbiAgICAgICAgdGhpcy5QVVJQT1NFX1ZBTF9YVFNfQUVTMjU2X0tFWV8xID0gMjtcbiAgICAgICAgdGhpcy5QVVJQT1NFX1ZBTF9YVFNfQUVTMjU2X0tFWV8yID0gMztcbiAgICAgICAgdGhpcy5QVVJQT1NFX1ZBTF9YVFNfQUVTMTI4X0tFWSA9IDQ7XG4gICAgICAgIHRoaXMuU1VQUE9SVFNfRU5DUllQVEVEX0ZMQVNIID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5GTEFTSF9FTkNSWVBURURfV1JJVEVfQUxJR04gPSAxNjtcbiAgICAgICAgdGhpcy5NRU1PUllfTUFQID0gW1xuICAgICAgICAgICAgWzB4MDAwMDAwMDAsIDB4MDAwMTAwMDAsIFwiUEFERElOR1wiXSxcbiAgICAgICAgICAgIFsweDQwMDAwMDAwLCAweDRjMDAwMDAwLCBcIkRST01cIl0sXG4gICAgICAgICAgICBbMHg0ZmYwMDAwMCwgMHg0ZmZhMDAwMCwgXCJEUkFNXCJdLFxuICAgICAgICAgICAgWzB4NGZmMDAwMDAsIDB4NGZmYTAwMDAsIFwiQllURV9BQ0NFU1NJQkxFXCJdLFxuICAgICAgICAgICAgWzB4NGZjMDAwMDAsIDB4NGZjMjAwMDAsIFwiRFJPTV9NQVNLXCJdLFxuICAgICAgICAgICAgWzB4NGZjMDAwMDAsIDB4NGZjMjAwMDAsIFwiSVJPTV9NQVNLXCJdLFxuICAgICAgICAgICAgWzB4NDAwMDAwMDAsIDB4NGMwMDAwMDAsIFwiSVJPTVwiXSxcbiAgICAgICAgICAgIFsweDRmZjAwMDAwLCAweDRmZmEwMDAwLCBcIklSQU1cIl0sXG4gICAgICAgICAgICBbMHg1MDEwODAwMCwgMHg1MDExMDAwMCwgXCJSVENfSVJBTVwiXSxcbiAgICAgICAgICAgIFsweDUwMTA4MDAwLCAweDUwMTEwMDAwLCBcIlJUQ19EUkFNXCJdLFxuICAgICAgICAgICAgWzB4NjAwZmUwMDAsIDB4NjAxMDAwMDAsIFwiTUVNX0lOVEVSTkFMMlwiXSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5VRjJfRkFNSUxZX0lEID0gMHgzZDMwOGU5NDtcbiAgICAgICAgdGhpcy5FRlVTRV9NQVhfS0VZID0gNTtcbiAgICAgICAgdGhpcy5LRVlfUFVSUE9TRVMgPSB7XG4gICAgICAgICAgICAwOiBcIlVTRVIvRU1QVFlcIixcbiAgICAgICAgICAgIDE6IFwiRUNEU0FfS0VZXCIsXG4gICAgICAgICAgICAyOiBcIlhUU19BRVNfMjU2X0tFWV8xXCIsXG4gICAgICAgICAgICAzOiBcIlhUU19BRVNfMjU2X0tFWV8yXCIsXG4gICAgICAgICAgICA0OiBcIlhUU19BRVNfMTI4X0tFWVwiLFxuICAgICAgICAgICAgNTogXCJITUFDX0RPV05fQUxMXCIsXG4gICAgICAgICAgICA2OiBcIkhNQUNfRE9XTl9KVEFHXCIsXG4gICAgICAgICAgICA3OiBcIkhNQUNfRE9XTl9ESUdJVEFMX1NJR05BVFVSRVwiLFxuICAgICAgICAgICAgODogXCJITUFDX1VQXCIsXG4gICAgICAgICAgICA5OiBcIlNFQ1VSRV9CT09UX0RJR0VTVDBcIixcbiAgICAgICAgICAgIDEwOiBcIlNFQ1VSRV9CT09UX0RJR0VTVDFcIixcbiAgICAgICAgICAgIDExOiBcIlNFQ1VSRV9CT09UX0RJR0VTVDJcIixcbiAgICAgICAgICAgIDEyOiBcIktNX0lOSVRfS0VZXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFBrZ1ZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAyO1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIHJldHVybiAocmVnaXN0ZXJWYWx1ZSA+PiAyNykgJiAweDA3O1xuICAgIH1cbiAgICBhc3luYyBnZXRNaW5vckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMjtcbiAgICAgICAgY29uc3QgYWRkciA9IHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgICAgICByZXR1cm4gKHJlZ2lzdGVyVmFsdWUgPj4gMCkgJiAweDBmO1xuICAgIH1cbiAgICBhc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gMjtcbiAgICAgICAgY29uc3QgYWRkciA9IHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgICAgICByZXR1cm4gKHJlZ2lzdGVyVmFsdWUgPj4gNCkgJiAweDAzO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgY2hpcE5hbWUgPSBwa2dWZXJzaW9uID09PSAwID8gXCJFU1AzMi1QNFwiIDogXCJ1bmtub3duIEVTUDMyLVA0XCI7XG4gICAgICAgIGNvbnN0IG1ham9yUmV2ID0gYXdhaXQgdGhpcy5nZXRNYWpvckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IG1pbm9yUmV2ID0gYXdhaXQgdGhpcy5nZXRNaW5vckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIHJldHVybiBgJHtjaGlwTmFtZX0gKHJldmlzaW9uIHYke21ham9yUmV2fS4ke21pbm9yUmV2fSlgO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRmVhdHVyZXMobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBbXCJIaWdoLVBlcmZvcm1hbmNlIE1DVVwiXTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3J5c3RhbEZyZXEobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiA0MDsgLy8gRVNQMzJQNCBYVEFMIGlzIGZpeGVkIHRvIDQwTUh6XG4gICAgfVxuICAgIGFzeW5jIGdldEZsYXNoVm9sdGFnZShsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBvdmVycmlkZVZkZHNkaW8obG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZWJ1ZyhcIlZERF9TRElPIG92ZXJyaWRlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgRVNQMzItUDRcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRNYWMobG9hZGVyKSB7XG4gICAgICAgIGxldCBtYWMwID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtcbiAgICAgICAgbWFjMCA9IG1hYzAgPj4+IDA7XG4gICAgICAgIGxldCBtYWMxID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHICsgNCk7XG4gICAgICAgIG1hYzEgPSAobWFjMSA+Pj4gMCkgJiAweDAwMDBmZmZmO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgbWFjWzBdID0gKG1hYzEgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbMV0gPSBtYWMxICYgMHhmZjtcbiAgICAgICAgbWFjWzJdID0gKG1hYzAgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgbWFjWzNdID0gKG1hYzAgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gKG1hYzAgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbNV0gPSBtYWMwICYgMHhmZjtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kMmgobWFjWzBdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzFdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzJdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzNdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzRdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzVdKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZsYXNoQ3J5cHRDb25maWcobG9hZGVyKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG9lc24ndCBleGlzdCBvbiBFU1AzMi1QNFxuICAgIH1cbiAgICBhc3luYyBnZXRTZWN1cmVCb290RW5hYmxlZChsYW9kZXIpIHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxhb2Rlci5yZWFkUmVnKHRoaXMuRUZVU0VfU0VDVVJFX0JPT1RfRU5fUkVHKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyVmFsdWUgJiB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX01BU0s7XG4gICAgfVxuICAgIGFzeW5jIGdldEtleUJsb2NrUHVycG9zZShsb2FkZXIsIGtleUJsb2NrKSB7XG4gICAgICAgIGlmIChrZXlCbG9jayA8IDAgfHwga2V5QmxvY2sgPiB0aGlzLkVGVVNFX01BWF9LRVkpIHtcbiAgICAgICAgICAgIGxvYWRlci5kZWJ1ZyhgVmFsaWQga2V5IGJsb2NrIG51bWJlcnMgbXVzdCBiZSBpbiByYW5nZSAwLSR7dGhpcy5FRlVTRV9NQVhfS0VZfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZ1NoaWZ0RGljdGlvbmFyeSA9IFtcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1NISUZUXSxcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1NISUZUXSxcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1NISUZUXSxcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZM19SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUXSxcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNF9SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1NISUZUXSxcbiAgICAgICAgICAgIFt0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUcsIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1NISUZUXSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgW3JlZywgc2hpZnRdID0gcmVnU2hpZnREaWN0aW9uYXJ5W2tleUJsb2NrXTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKHJlZyk7XG4gICAgICAgIHJldHVybiAocmVnaXN0ZXJWYWx1ZSA+PiBzaGlmdCkgJiAweGY7XG4gICAgfVxuICAgIGFzeW5jIGlzRmxhc2hFbmNyeXB0aW9uS2V5VmFsaWQobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHB1cnBvc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuRUZVU0VfTUFYX0tFWTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwdXJwb3NlID0gYXdhaXQgdGhpcy5nZXRLZXlCbG9ja1B1cnBvc2UobG9hZGVyLCBpKTtcbiAgICAgICAgICAgIHB1cnBvc2VzLnB1c2gocHVycG9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNYdHNBZXMxMjhLZXkgPSBwdXJwb3Nlcy5maW5kKChwKSA9PiBwID09PSB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMxMjhfS0VZKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpc1h0c0FlczEyOEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1h0c0FlczI1NktleTEgPSBwdXJwb3Nlcy5maW5kKChwKSA9PiBwID09PSB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzEpO1xuICAgICAgICBjb25zdCBpc1h0c0FlczI1NktleTIgPSBwdXJwb3Nlcy5maW5kKChwKSA9PiBwID09PSB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzIpO1xuICAgICAgICBpZiAodHlwZW9mIGlzWHRzQWVzMjU2S2V5MSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpc1h0c0FlczI1NktleTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32p4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32s2.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32s2.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32S2ROM: () => (/* binding */ ESP32S2ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32S2ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-S2\";\n        this.IMAGE_CHIP_ID = 2;\n        this.IROM_MAP_START = 0x40080000;\n        this.IROM_MAP_END = 0x40b80000;\n        this.DROM_MAP_START = 0x3f000000;\n        this.DROM_MAP_END = 0x3f3f0000;\n        this.CHIP_DETECT_MAGIC_VALUE = [0x000007c6];\n        this.SPI_REG_BASE = 0x3f402000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n        this.SPI_ADDR_REG_MSB = false;\n        this.MAC_EFUSE_REG = 0x3f41a044; // ESP32-S2 has special block for MAC efuses\n        this.UART_CLKDIV_REG = 0x3f400014;\n        this.SUPPORTS_ENCRYPTED_FLASH = true;\n        this.FLASH_ENCRYPTED_WRITE_ALIGN = 16;\n        // todo: use espefuse APIs to get this info\n        this.EFUSE_BASE = 0x3f41a000;\n        this.EFUSE_RD_REG_BASE = this.EFUSE_BASE + 0x030; // BLOCK0 read base address\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x044;\n        this.EFUSE_BLOCK2_ADDR = this.EFUSE_BASE + 0x05c;\n        this.EFUSE_PURPOSE_KEY0_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY0_SHIFT = 24;\n        this.EFUSE_PURPOSE_KEY1_REG = this.EFUSE_BASE + 0x34;\n        this.EFUSE_PURPOSE_KEY1_SHIFT = 28;\n        this.EFUSE_PURPOSE_KEY2_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY2_SHIFT = 0;\n        this.EFUSE_PURPOSE_KEY3_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY3_SHIFT = 4;\n        this.EFUSE_PURPOSE_KEY4_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY4_SHIFT = 8;\n        this.EFUSE_PURPOSE_KEY5_REG = this.EFUSE_BASE + 0x38;\n        this.EFUSE_PURPOSE_KEY5_SHIFT = 12;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = this.EFUSE_RD_REG_BASE;\n        this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 19;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_REG = this.EFUSE_BASE + 0x034;\n        this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18;\n        this.EFUSE_SECURE_BOOT_EN_REG = this.EFUSE_BASE + 0x038;\n        this.EFUSE_SECURE_BOOT_EN_MASK = 1 << 20;\n        this.EFUSE_RD_REPEAT_DATA3_REG = this.EFUSE_BASE + 0x3c;\n        this.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK = 1 << 9;\n        this.PURPOSE_VAL_XTS_AES256_KEY_1 = 2;\n        this.PURPOSE_VAL_XTS_AES256_KEY_2 = 3;\n        this.PURPOSE_VAL_XTS_AES128_KEY = 4;\n        this.UARTDEV_BUF_NO = 0x3ffffd14; // Variable in ROM .bss which indicates the port in use\n        this.UARTDEV_BUF_NO_USB_OTG = 2; // Value of the above indicating that USB-OTG is in use\n        this.USB_RAM_BLOCK = 0x800; // Max block size USB-OTG is used\n        this.GPIO_STRAP_REG = 0x3f404038;\n        this.GPIO_STRAP_SPI_BOOT_MASK = 1 << 3; // Not download mode\n        this.GPIO_STRAP_VDDSPI_MASK = 1 << 4;\n        this.RTC_CNTL_OPTION1_REG = 0x3f408128;\n        this.RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK = 0x1; // Is download mode forced over USB?\n        this.RTCCNTL_BASE_REG = 0x3f408000;\n        this.RTC_CNTL_WDTCONFIG0_REG = this.RTCCNTL_BASE_REG + 0x0094;\n        this.RTC_CNTL_WDTCONFIG1_REG = this.RTCCNTL_BASE_REG + 0x0098;\n        this.RTC_CNTL_WDTWPROTECT_REG = this.RTCCNTL_BASE_REG + 0x00ac;\n        this.RTC_CNTL_WDT_WKEY = 0x50d83aa1;\n        this.MEMORY_MAP = [\n            [0x00000000, 0x00010000, \"PADDING\"],\n            [0x3f000000, 0x3ff80000, \"DROM\"],\n            [0x3f500000, 0x3ff80000, \"EXTRAM_DATA\"],\n            [0x3ff9e000, 0x3ffa0000, \"RTC_DRAM\"],\n            [0x3ff9e000, 0x40000000, \"BYTE_ACCESSIBLE\"],\n            [0x3ff9e000, 0x40072000, \"MEM_INTERNAL\"],\n            [0x3ffb0000, 0x40000000, \"DRAM\"],\n            [0x40000000, 0x4001a100, \"IROM_MASK\"],\n            [0x40020000, 0x40070000, \"IRAM\"],\n            [0x40070000, 0x40072000, \"RTC_IRAM\"],\n            [0x40080000, 0x40800000, \"IROM\"],\n            [0x50000000, 0x50002000, \"RTC_DATA\"],\n        ];\n        this.EFUSE_VDD_SPI_REG = this.EFUSE_BASE + 0x34;\n        this.VDD_SPI_XPD = 1 << 4;\n        this.VDD_SPI_TIEH = 1 << 5;\n        this.VDD_SPI_FORCE = 1 << 6;\n        this.UF2_FAMILY_ID = 0xbfdd4eee;\n        this.EFUSE_MAX_KEY = 5;\n        this.KEY_PURPOSES = {\n            0: \"USER/EMPTY\",\n            1: \"RESERVED\",\n            2: \"XTS_AES_256_KEY_1\",\n            3: \"XTS_AES_256_KEY_2\",\n            4: \"XTS_AES_128_KEY\",\n            5: \"HMAC_DOWN_ALL\",\n            6: \"HMAC_DOWN_JTAG\",\n            7: \"HMAC_DOWN_DIGITAL_SIGNATURE\",\n            8: \"HMAC_UP\",\n            9: \"SECURE_BOOT_DIGEST0\",\n            10: \"SECURE_BOOT_DIGEST1\",\n            11: \"SECURE_BOOT_DIGEST2\",\n        };\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x60000078;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0x1000;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n    }\n    async getPkgVersion(loader) {\n        const numWord = 4;\n        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;\n        const word = await loader.readReg(addr);\n        const pkgVersion = (word >> 0) & 0x0f;\n        return pkgVersion;\n    }\n    async getMinorChipVersion(loader) {\n        const hiNumWord = 3;\n        const hi = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * hiNumWord)) >> 20) & 0x01;\n        const lowNumWord = 4;\n        const low = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * lowNumWord)) >> 4) & 0x07;\n        return (hi << 3) + low;\n    }\n    async getMajorChipVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 18) & 0x03;\n    }\n    async getFlashVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 21) & 0x0f;\n    }\n    async getChipDescription(loader) {\n        const chipDesc = {\n            0: \"ESP32-S2\",\n            1: \"ESP32-S2FH2\",\n            2: \"ESP32-S2FH4\",\n            102: \"ESP32-S2FNR2\",\n            100: \"ESP32-S2R2\",\n        };\n        const chipIndex = (await this.getFlashCap(loader)) + (await this.getPsramCap(loader)) * 100;\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        return `${chipDesc[chipIndex] || \"unknown ESP32-S2\"} (revision v${majorRev}.${minorRev})`;\n    }\n    async getFlashCap(loader) {\n        return await this.getFlashVersion(loader);\n    }\n    async getPsramVersion(loader) {\n        const numWord = 3;\n        const addr = this.EFUSE_BLOCK1_ADDR + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const psramCap = (registerValue >> 28) & 0x0f;\n        return psramCap;\n    }\n    async getPsramCap(loader) {\n        return await this.getPsramVersion(loader);\n    }\n    async getBlock2Version(loader) {\n        const numWord = 4;\n        const addr = this.EFUSE_BLOCK2_ADDR + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const block2Ver = (registerValue >> 4) & 0x07;\n        return block2Ver;\n    }\n    async getChipFeatures(loader) {\n        const features = [\"Wi-Fi\"];\n        const flashMap = {\n            0: \"No Embedded Flash\",\n            1: \"Embedded Flash 2MB\",\n            2: \"Embedded Flash 4MB\",\n        };\n        const flashCap = await this.getFlashCap(loader);\n        const flashDescription = flashMap[flashCap] || \"Unknown Embedded Flash\";\n        features.push(flashDescription);\n        const psramMap = {\n            0: \"No Embedded Flash\",\n            1: \"Embedded PSRAM 2MB\",\n            2: \"Embedded PSRAM 4MB\",\n        };\n        const psramCap = await this.getPsramCap(loader);\n        const psramDescription = psramMap[psramCap] || \"Unknown Embedded PSRAM\";\n        features.push(psramDescription);\n        const block2VersionMap = {\n            0: \"No calibration in BLK2 of efuse\",\n            1: \"ADC and temperature sensor calibration in BLK2 of efuse V1\",\n            2: \"ADC and temperature sensor calibration in BLK2 of efuse V2\",\n        };\n        const block2Ver = await this.getBlock2Version(loader);\n        const block2VersionDescription = block2VersionMap[block2Ver] || \"Unknown Calibration in BLK2\";\n        features.push(block2VersionDescription);\n        return features;\n    }\n    async getCrystalFreq(loader) {\n        return 40;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n    async usingUsbOtg(loader) {\n        const uartNo = (await loader.readReg(this.UARTDEV_BUF_NO)) & 0xff;\n        return uartNo === this.UARTDEV_BUF_NO_USB_OTG;\n    }\n    async postConnect(loader) {\n        const usingUsbOtg = await this.usingUsbOtg(loader);\n        loader.debug(\"In _post_connect using USB OTG ?\" + usingUsbOtg);\n        if (usingUsbOtg) {\n            loader.ESP_RAM_BLOCK = this.USB_RAM_BLOCK;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMnMyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLG9DQUFvQztBQUNwQztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkMsYUFBYSxTQUFTLEdBQUcsU0FBUztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwMzJzMi5qcz9mYThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJPTSB9IGZyb20gXCIuL3JvbS5qc1wiO1xuZXhwb3J0IGNsYXNzIEVTUDMyUzJST00gZXh0ZW5kcyBST00ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLkNISVBfTkFNRSA9IFwiRVNQMzItUzJcIjtcbiAgICAgICAgdGhpcy5JTUFHRV9DSElQX0lEID0gMjtcbiAgICAgICAgdGhpcy5JUk9NX01BUF9TVEFSVCA9IDB4NDAwODAwMDA7XG4gICAgICAgIHRoaXMuSVJPTV9NQVBfRU5EID0gMHg0MGI4MDAwMDtcbiAgICAgICAgdGhpcy5EUk9NX01BUF9TVEFSVCA9IDB4M2YwMDAwMDA7XG4gICAgICAgIHRoaXMuRFJPTV9NQVBfRU5EID0gMHgzZjNmMDAwMDtcbiAgICAgICAgdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRSA9IFsweDAwMDAwN2M2XTtcbiAgICAgICAgdGhpcy5TUElfUkVHX0JBU0UgPSAweDNmNDAyMDAwO1xuICAgICAgICB0aGlzLlNQSV9VU1JfT0ZGUyA9IDB4MTg7XG4gICAgICAgIHRoaXMuU1BJX1VTUjFfT0ZGUyA9IDB4MWM7XG4gICAgICAgIHRoaXMuU1BJX1VTUjJfT0ZGUyA9IDB4MjA7XG4gICAgICAgIHRoaXMuU1BJX01PU0lfRExFTl9PRkZTID0gMHgyNDtcbiAgICAgICAgdGhpcy5TUElfTUlTT19ETEVOX09GRlMgPSAweDI4O1xuICAgICAgICB0aGlzLlNQSV9XMF9PRkZTID0gMHg1ODtcbiAgICAgICAgdGhpcy5TUElfQUREUl9SRUdfTVNCID0gZmFsc2U7XG4gICAgICAgIHRoaXMuTUFDX0VGVVNFX1JFRyA9IDB4M2Y0MWEwNDQ7IC8vIEVTUDMyLVMyIGhhcyBzcGVjaWFsIGJsb2NrIGZvciBNQUMgZWZ1c2VzXG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfUkVHID0gMHgzZjQwMDAxNDtcbiAgICAgICAgdGhpcy5TVVBQT1JUU19FTkNSWVBURURfRkxBU0ggPSB0cnVlO1xuICAgICAgICB0aGlzLkZMQVNIX0VOQ1JZUFRFRF9XUklURV9BTElHTiA9IDE2O1xuICAgICAgICAvLyB0b2RvOiB1c2UgZXNwZWZ1c2UgQVBJcyB0byBnZXQgdGhpcyBpbmZvXG4gICAgICAgIHRoaXMuRUZVU0VfQkFTRSA9IDB4M2Y0MWEwMDA7XG4gICAgICAgIHRoaXMuRUZVU0VfUkRfUkVHX0JBU0UgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDAzMDsgLy8gQkxPQ0swIHJlYWQgYmFzZSBhZGRyZXNzXG4gICAgICAgIHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzJfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDVjO1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9TSElGVCA9IDI0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9TSElGVCA9IDI4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9TSElGVCA9IDA7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4Mzg7XG4gICAgICAgIHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUID0gNDtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHID0gdGhpcy5FRlVTRV9CQVNFICsgMHgzODtcbiAgICAgICAgdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlQgPSA4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9TSElGVCA9IDEyO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVF9SRUcgPSB0aGlzLkVGVVNFX1JEX1JFR19CQVNFO1xuICAgICAgICB0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVCA9IDEgPDwgMTk7XG4gICAgICAgIHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM0O1xuICAgICAgICB0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9NQVNLID0gMHg3IDw8IDE4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX1JFRyA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDM4O1xuICAgICAgICB0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX01BU0sgPSAxIDw8IDIwO1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFUEVBVF9EQVRBM19SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDNjO1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFUEVBVF9EQVRBM19SRUdfRkxBU0hfVFlQRV9NQVNLID0gMSA8PCA5O1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzEgPSAyO1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzIgPSAzO1xuICAgICAgICB0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMxMjhfS0VZID0gNDtcbiAgICAgICAgdGhpcy5VQVJUREVWX0JVRl9OTyA9IDB4M2ZmZmZkMTQ7IC8vIFZhcmlhYmxlIGluIFJPTSAuYnNzIHdoaWNoIGluZGljYXRlcyB0aGUgcG9ydCBpbiB1c2VcbiAgICAgICAgdGhpcy5VQVJUREVWX0JVRl9OT19VU0JfT1RHID0gMjsgLy8gVmFsdWUgb2YgdGhlIGFib3ZlIGluZGljYXRpbmcgdGhhdCBVU0ItT1RHIGlzIGluIHVzZVxuICAgICAgICB0aGlzLlVTQl9SQU1fQkxPQ0sgPSAweDgwMDsgLy8gTWF4IGJsb2NrIHNpemUgVVNCLU9URyBpcyB1c2VkXG4gICAgICAgIHRoaXMuR1BJT19TVFJBUF9SRUcgPSAweDNmNDA0MDM4O1xuICAgICAgICB0aGlzLkdQSU9fU1RSQVBfU1BJX0JPT1RfTUFTSyA9IDEgPDwgMzsgLy8gTm90IGRvd25sb2FkIG1vZGVcbiAgICAgICAgdGhpcy5HUElPX1NUUkFQX1ZERFNQSV9NQVNLID0gMSA8PCA0O1xuICAgICAgICB0aGlzLlJUQ19DTlRMX09QVElPTjFfUkVHID0gMHgzZjQwODEyODtcbiAgICAgICAgdGhpcy5SVENfQ05UTF9GT1JDRV9ET1dOTE9BRF9CT09UX01BU0sgPSAweDE7IC8vIElzIGRvd25sb2FkIG1vZGUgZm9yY2VkIG92ZXIgVVNCP1xuICAgICAgICB0aGlzLlJUQ0NOVExfQkFTRV9SRUcgPSAweDNmNDA4MDAwO1xuICAgICAgICB0aGlzLlJUQ19DTlRMX1dEVENPTkZJRzBfUkVHID0gdGhpcy5SVENDTlRMX0JBU0VfUkVHICsgMHgwMDk0O1xuICAgICAgICB0aGlzLlJUQ19DTlRMX1dEVENPTkZJRzFfUkVHID0gdGhpcy5SVENDTlRMX0JBU0VfUkVHICsgMHgwMDk4O1xuICAgICAgICB0aGlzLlJUQ19DTlRMX1dEVFdQUk9URUNUX1JFRyA9IHRoaXMuUlRDQ05UTF9CQVNFX1JFRyArIDB4MDBhYztcbiAgICAgICAgdGhpcy5SVENfQ05UTF9XRFRfV0tFWSA9IDB4NTBkODNhYTE7XG4gICAgICAgIHRoaXMuTUVNT1JZX01BUCA9IFtcbiAgICAgICAgICAgIFsweDAwMDAwMDAwLCAweDAwMDEwMDAwLCBcIlBBRERJTkdcIl0sXG4gICAgICAgICAgICBbMHgzZjAwMDAwMCwgMHgzZmY4MDAwMCwgXCJEUk9NXCJdLFxuICAgICAgICAgICAgWzB4M2Y1MDAwMDAsIDB4M2ZmODAwMDAsIFwiRVhUUkFNX0RBVEFcIl0sXG4gICAgICAgICAgICBbMHgzZmY5ZTAwMCwgMHgzZmZhMDAwMCwgXCJSVENfRFJBTVwiXSxcbiAgICAgICAgICAgIFsweDNmZjllMDAwLCAweDQwMDAwMDAwLCBcIkJZVEVfQUNDRVNTSUJMRVwiXSxcbiAgICAgICAgICAgIFsweDNmZjllMDAwLCAweDQwMDcyMDAwLCBcIk1FTV9JTlRFUk5BTFwiXSxcbiAgICAgICAgICAgIFsweDNmZmIwMDAwLCAweDQwMDAwMDAwLCBcIkRSQU1cIl0sXG4gICAgICAgICAgICBbMHg0MDAwMDAwMCwgMHg0MDAxYTEwMCwgXCJJUk9NX01BU0tcIl0sXG4gICAgICAgICAgICBbMHg0MDAyMDAwMCwgMHg0MDA3MDAwMCwgXCJJUkFNXCJdLFxuICAgICAgICAgICAgWzB4NDAwNzAwMDAsIDB4NDAwNzIwMDAsIFwiUlRDX0lSQU1cIl0sXG4gICAgICAgICAgICBbMHg0MDA4MDAwMCwgMHg0MDgwMDAwMCwgXCJJUk9NXCJdLFxuICAgICAgICAgICAgWzB4NTAwMDAwMDAsIDB4NTAwMDIwMDAsIFwiUlRDX0RBVEFcIl0sXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuRUZVU0VfVkREX1NQSV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDM0O1xuICAgICAgICB0aGlzLlZERF9TUElfWFBEID0gMSA8PCA0O1xuICAgICAgICB0aGlzLlZERF9TUElfVElFSCA9IDEgPDwgNTtcbiAgICAgICAgdGhpcy5WRERfU1BJX0ZPUkNFID0gMSA8PCA2O1xuICAgICAgICB0aGlzLlVGMl9GQU1JTFlfSUQgPSAweGJmZGQ0ZWVlO1xuICAgICAgICB0aGlzLkVGVVNFX01BWF9LRVkgPSA1O1xuICAgICAgICB0aGlzLktFWV9QVVJQT1NFUyA9IHtcbiAgICAgICAgICAgIDA6IFwiVVNFUi9FTVBUWVwiLFxuICAgICAgICAgICAgMTogXCJSRVNFUlZFRFwiLFxuICAgICAgICAgICAgMjogXCJYVFNfQUVTXzI1Nl9LRVlfMVwiLFxuICAgICAgICAgICAgMzogXCJYVFNfQUVTXzI1Nl9LRVlfMlwiLFxuICAgICAgICAgICAgNDogXCJYVFNfQUVTXzEyOF9LRVlcIixcbiAgICAgICAgICAgIDU6IFwiSE1BQ19ET1dOX0FMTFwiLFxuICAgICAgICAgICAgNjogXCJITUFDX0RPV05fSlRBR1wiLFxuICAgICAgICAgICAgNzogXCJITUFDX0RPV05fRElHSVRBTF9TSUdOQVRVUkVcIixcbiAgICAgICAgICAgIDg6IFwiSE1BQ19VUFwiLFxuICAgICAgICAgICAgOTogXCJTRUNVUkVfQk9PVF9ESUdFU1QwXCIsXG4gICAgICAgICAgICAxMDogXCJTRUNVUkVfQk9PVF9ESUdFU1QxXCIsXG4gICAgICAgICAgICAxMTogXCJTRUNVUkVfQk9PVF9ESUdFU1QyXCIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfTUFTSyA9IDB4ZmZmZmY7XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg2MDAwMDA3ODtcbiAgICAgICAgdGhpcy5GTEFTSF9XUklURV9TSVpFID0gMHg0MDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAweDEwMDA7XG4gICAgICAgIHRoaXMuRkxBU0hfU0laRVMgPSB7XG4gICAgICAgICAgICBcIjFNQlwiOiAweDAwLFxuICAgICAgICAgICAgXCIyTUJcIjogMHgxMCxcbiAgICAgICAgICAgIFwiNE1CXCI6IDB4MjAsXG4gICAgICAgICAgICBcIjhNQlwiOiAweDMwLFxuICAgICAgICAgICAgXCIxNk1CXCI6IDB4NDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFBrZ1ZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCB3b3JkID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSAod29yZCA+PiAwKSAmIDB4MGY7XG4gICAgICAgIHJldHVybiBwa2dWZXJzaW9uO1xuICAgIH1cbiAgICBhc3luYyBnZXRNaW5vckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBoaU51bVdvcmQgPSAzO1xuICAgICAgICBjb25zdCBoaSA9ICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBoaU51bVdvcmQpKSA+PiAyMCkgJiAweDAxO1xuICAgICAgICBjb25zdCBsb3dOdW1Xb3JkID0gNDtcbiAgICAgICAgY29uc3QgbG93ID0gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIGxvd051bVdvcmQpKSA+PiA0KSAmIDB4MDc7XG4gICAgICAgIHJldHVybiAoaGkgPDwgMykgKyBsb3c7XG4gICAgfVxuICAgIGFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAxOCkgJiAweDAzO1xuICAgIH1cbiAgICBhc3luYyBnZXRGbGFzaFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAyMSkgJiAweDBmO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGNoaXBEZXNjID0ge1xuICAgICAgICAgICAgMDogXCJFU1AzMi1TMlwiLFxuICAgICAgICAgICAgMTogXCJFU1AzMi1TMkZIMlwiLFxuICAgICAgICAgICAgMjogXCJFU1AzMi1TMkZINFwiLFxuICAgICAgICAgICAgMTAyOiBcIkVTUDMyLVMyRk5SMlwiLFxuICAgICAgICAgICAgMTAwOiBcIkVTUDMyLVMyUjJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hpcEluZGV4ID0gKGF3YWl0IHRoaXMuZ2V0Rmxhc2hDYXAobG9hZGVyKSkgKyAoYXdhaXQgdGhpcy5nZXRQc3JhbUNhcChsb2FkZXIpKSAqIDEwMDtcbiAgICAgICAgY29uc3QgbWFqb3JSZXYgPSBhd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgbWlub3JSZXYgPSBhd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIGAke2NoaXBEZXNjW2NoaXBJbmRleF0gfHwgXCJ1bmtub3duIEVTUDMyLVMyXCJ9IChyZXZpc2lvbiB2JHttYWpvclJldn0uJHttaW5vclJldn0pYDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hDYXAobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEZsYXNoVmVyc2lvbihsb2FkZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQc3JhbVZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IHBzcmFtQ2FwID0gKHJlZ2lzdGVyVmFsdWUgPj4gMjgpICYgMHgwZjtcbiAgICAgICAgcmV0dXJuIHBzcmFtQ2FwO1xuICAgIH1cbiAgICBhc3luYyBnZXRQc3JhbUNhcChsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHNyYW1WZXJzaW9uKGxvYWRlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldEJsb2NrMlZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9CTE9DSzJfQUREUiArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IGJsb2NrMlZlciA9IChyZWdpc3RlclZhbHVlID4+IDQpICYgMHgwNztcbiAgICAgICAgcmV0dXJuIGJsb2NrMlZlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGxvYWRlcikge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtcIldpLUZpXCJdO1xuICAgICAgICBjb25zdCBmbGFzaE1hcCA9IHtcbiAgICAgICAgICAgIDA6IFwiTm8gRW1iZWRkZWQgRmxhc2hcIixcbiAgICAgICAgICAgIDE6IFwiRW1iZWRkZWQgRmxhc2ggMk1CXCIsXG4gICAgICAgICAgICAyOiBcIkVtYmVkZGVkIEZsYXNoIDRNQlwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFzaENhcCA9IGF3YWl0IHRoaXMuZ2V0Rmxhc2hDYXAobG9hZGVyKTtcbiAgICAgICAgY29uc3QgZmxhc2hEZXNjcmlwdGlvbiA9IGZsYXNoTWFwW2ZsYXNoQ2FwXSB8fCBcIlVua25vd24gRW1iZWRkZWQgRmxhc2hcIjtcbiAgICAgICAgZmVhdHVyZXMucHVzaChmbGFzaERlc2NyaXB0aW9uKTtcbiAgICAgICAgY29uc3QgcHNyYW1NYXAgPSB7XG4gICAgICAgICAgICAwOiBcIk5vIEVtYmVkZGVkIEZsYXNoXCIsXG4gICAgICAgICAgICAxOiBcIkVtYmVkZGVkIFBTUkFNIDJNQlwiLFxuICAgICAgICAgICAgMjogXCJFbWJlZGRlZCBQU1JBTSA0TUJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHNyYW1DYXAgPSBhd2FpdCB0aGlzLmdldFBzcmFtQ2FwKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IHBzcmFtRGVzY3JpcHRpb24gPSBwc3JhbU1hcFtwc3JhbUNhcF0gfHwgXCJVbmtub3duIEVtYmVkZGVkIFBTUkFNXCI7XG4gICAgICAgIGZlYXR1cmVzLnB1c2gocHNyYW1EZXNjcmlwdGlvbik7XG4gICAgICAgIGNvbnN0IGJsb2NrMlZlcnNpb25NYXAgPSB7XG4gICAgICAgICAgICAwOiBcIk5vIGNhbGlicmF0aW9uIGluIEJMSzIgb2YgZWZ1c2VcIixcbiAgICAgICAgICAgIDE6IFwiQURDIGFuZCB0ZW1wZXJhdHVyZSBzZW5zb3IgY2FsaWJyYXRpb24gaW4gQkxLMiBvZiBlZnVzZSBWMVwiLFxuICAgICAgICAgICAgMjogXCJBREMgYW5kIHRlbXBlcmF0dXJlIHNlbnNvciBjYWxpYnJhdGlvbiBpbiBCTEsyIG9mIGVmdXNlIFYyXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJsb2NrMlZlciA9IGF3YWl0IHRoaXMuZ2V0QmxvY2syVmVyc2lvbihsb2FkZXIpO1xuICAgICAgICBjb25zdCBibG9jazJWZXJzaW9uRGVzY3JpcHRpb24gPSBibG9jazJWZXJzaW9uTWFwW2Jsb2NrMlZlcl0gfHwgXCJVbmtub3duIENhbGlicmF0aW9uIGluIEJMSzJcIjtcbiAgICAgICAgZmVhdHVyZXMucHVzaChibG9jazJWZXJzaW9uRGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuICAgIGFzeW5jIGdldENyeXN0YWxGcmVxKGxvYWRlcikge1xuICAgICAgICByZXR1cm4gNDA7XG4gICAgfVxuICAgIF9kMmgoZCkge1xuICAgICAgICBjb25zdCBoID0gKCtkKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBoLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaCA6IGg7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRNYWMobG9hZGVyKSB7XG4gICAgICAgIGxldCBtYWMwID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtcbiAgICAgICAgbWFjMCA9IG1hYzAgPj4+IDA7XG4gICAgICAgIGxldCBtYWMxID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHICsgNCk7XG4gICAgICAgIG1hYzEgPSAobWFjMSA+Pj4gMCkgJiAweDAwMDBmZmZmO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgbWFjWzBdID0gKG1hYzEgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbMV0gPSBtYWMxICYgMHhmZjtcbiAgICAgICAgbWFjWzJdID0gKG1hYzAgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgbWFjWzNdID0gKG1hYzAgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gKG1hYzAgPj4gOCkgJiAweGZmO1xuICAgICAgICBtYWNbNV0gPSBtYWMwICYgMHhmZjtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kMmgobWFjWzBdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzFdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzJdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzNdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzRdKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICB0aGlzLl9kMmgobWFjWzVdKSk7XG4gICAgfVxuICAgIGdldEVyYXNlU2l6ZShvZmZzZXQsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGFzeW5jIHVzaW5nVXNiT3RnKGxvYWRlcikge1xuICAgICAgICBjb25zdCB1YXJ0Tm8gPSAoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5VQVJUREVWX0JVRl9OTykpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIHVhcnRObyA9PT0gdGhpcy5VQVJUREVWX0JVRl9OT19VU0JfT1RHO1xuICAgIH1cbiAgICBhc3luYyBwb3N0Q29ubmVjdChsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgdXNpbmdVc2JPdGcgPSBhd2FpdCB0aGlzLnVzaW5nVXNiT3RnKGxvYWRlcik7XG4gICAgICAgIGxvYWRlci5kZWJ1ZyhcIkluIF9wb3N0X2Nvbm5lY3QgdXNpbmcgVVNCIE9URyA/XCIgKyB1c2luZ1VzYk90Zyk7XG4gICAgICAgIGlmICh1c2luZ1VzYk90Zykge1xuICAgICAgICAgICAgbG9hZGVyLkVTUF9SQU1fQkxPQ0sgPSB0aGlzLlVTQl9SQU1fQkxPQ0s7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32s2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp32s3.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp32s3.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP32S3ROM: () => (/* binding */ ESP32S3ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP32S3ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-S3\";\n        this.IMAGE_CHIP_ID = 9;\n        this.EFUSE_BASE = 0x60007000;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x44;\n        this.EFUSE_BLOCK2_ADDR = this.EFUSE_BASE + 0x5c;\n        this.UART_CLKDIV_REG = 0x60000014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x60000080;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0x0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n        this.USB_RAM_BLOCK = 0x800;\n        this.UARTDEV_BUF_NO_USB = 3;\n        this.UARTDEV_BUF_NO = 0x3fcef14c;\n    }\n    async getChipDescription(loader) {\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        const pkgVersion = await this.getPkgVersion(loader);\n        const chipName = {\n            0: \"ESP32-S3 (QFN56)\",\n            1: \"ESP32-S3-PICO-1 (LGA56)\",\n        };\n        return `${chipName[pkgVersion] || \"unknown ESP32-S3\"} (revision v${majorRev}.${minorRev})`;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 21) & 0x07;\n    }\n    async getRawMinorChipVersion(loader) {\n        const hiNumWord = 5;\n        const hi = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * hiNumWord)) >> 23) & 0x01;\n        const lowNumWord = 3;\n        const low = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * lowNumWord)) >> 18) & 0x07;\n        return (hi << 3) + low;\n    }\n    async getMinorChipVersion(loader) {\n        const minorRaw = await this.getRawMinorChipVersion(loader);\n        if (await this.isEco0(loader, minorRaw)) {\n            return 0;\n        }\n        return this.getRawMinorChipVersion(loader);\n    }\n    async getRawMajorChipVersion(loader) {\n        const numWord = 5;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x03;\n    }\n    async getMajorChipVersion(loader) {\n        const minorRaw = await this.getRawMinorChipVersion(loader);\n        if (await this.isEco0(loader, minorRaw)) {\n            return 0;\n        }\n        return this.getRawMajorChipVersion(loader);\n    }\n    async getBlkVersionMajor(loader) {\n        const numWord = 4;\n        return ((await loader.readReg(this.EFUSE_BLOCK2_ADDR + 4 * numWord)) >> 0) & 0x03;\n    }\n    async getBlkVersionMinor(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x07;\n    }\n    async isEco0(loader, minorRaw) {\n        // Workaround: The major version field was allocated to other purposes\n        // when block version is v1.1.\n        // Luckily only chip v0.0 have this kind of block version and efuse usage.\n        return ((minorRaw & 0x7) === 0 &&\n            (await this.getBlkVersionMajor(loader)) === 1 &&\n            (await this.getBlkVersionMinor(loader)) === 1);\n    }\n    async getFlashCap(loader) {\n        const numWord = 3;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const flashCap = (registerValue >> 27) & 0x07;\n        return flashCap;\n    }\n    async getFlashVendor(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const vendorId = (registerValue >> 0) & 0x07;\n        const vendorMap = {\n            1: \"XMC\",\n            2: \"GD\",\n            3: \"FM\",\n            4: \"TT\",\n            5: \"BY\",\n        };\n        return vendorMap[vendorId] || \"\";\n    }\n    async getPsramCap(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const psramCap = (registerValue >> 3) & 0x03;\n        return psramCap;\n    }\n    async getPsramVendor(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const vendorId = (registerValue >> 7) & 0x03;\n        const vendorMap = {\n            1: \"AP_3v3\",\n            2: \"AP_1v8\",\n        };\n        return vendorMap[vendorId] || \"\";\n    }\n    async getChipFeatures(loader) {\n        const features = [\"Wi-Fi\", \"BLE\"];\n        const flashMap = {\n            0: null,\n            1: \"Embedded Flash 8MB\",\n            2: \"Embedded Flash 4MB\",\n        };\n        const flashCap = await this.getFlashCap(loader);\n        const flashVendor = await this.getFlashVendor(loader);\n        const flash = flashMap[flashCap];\n        const flashDescription = flash !== undefined ? flash : \"Unknown Embedded Flash\";\n        if (flash !== null) {\n            features.push(`${flashDescription} (${flashVendor})`);\n        }\n        const psramMap = {\n            0: null,\n            1: \"Embedded PSRAM 8MB\",\n            2: \"Embedded PSRAM 2MB\",\n        };\n        const psramCap = await this.getPsramCap(loader);\n        const psramVendor = await this.getPsramVendor(loader);\n        const psram = psramMap[psramCap];\n        const psramDescription = psram !== undefined ? psram : \"Unknown Embedded PSRAM\";\n        if (psram !== null) {\n            features.push(`${psramDescription} (${psramVendor})`);\n        }\n        return features;\n    }\n    async getCrystalFreq(loader) {\n        return 40;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async postConnect(loader) {\n        const bufNo = (await loader.readReg(this.UARTDEV_BUF_NO)) & 0xff;\n        loader.debug(\"In _post_connect \" + bufNo);\n        if (bufNo == this.UARTDEV_BUF_NO_USB) {\n            loader.ESP_RAM_BLOCK = this.USB_RAM_BLOCK;\n        }\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMnMzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDLGFBQWEsU0FBUyxHQUFHLFNBQVM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0IsR0FBRyxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCLEdBQUcsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3AzMnMzLmpzPzM4M2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUk9NIH0gZnJvbSBcIi4vcm9tLmpzXCI7XG5leHBvcnQgY2xhc3MgRVNQMzJTM1JPTSBleHRlbmRzIFJPTSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuQ0hJUF9OQU1FID0gXCJFU1AzMi1TM1wiO1xuICAgICAgICB0aGlzLklNQUdFX0NISVBfSUQgPSA5O1xuICAgICAgICB0aGlzLkVGVVNFX0JBU0UgPSAweDYwMDA3MDAwO1xuICAgICAgICB0aGlzLk1BQ19FRlVTRV9SRUcgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgdGhpcy5FRlVTRV9CTE9DSzFfQUREUiA9IHRoaXMuRUZVU0VfQkFTRSArIDB4NDQ7XG4gICAgICAgIHRoaXMuRUZVU0VfQkxPQ0syX0FERFIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDVjO1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX1JFRyA9IDB4NjAwMDAwMTQ7XG4gICAgICAgIHRoaXMuVUFSVF9DTEtESVZfTUFTSyA9IDB4ZmZmZmY7XG4gICAgICAgIHRoaXMuVUFSVF9EQVRFX1JFR19BRERSID0gMHg2MDAwMDA4MDtcbiAgICAgICAgdGhpcy5GTEFTSF9XUklURV9TSVpFID0gMHg0MDA7XG4gICAgICAgIHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQgPSAweDA7XG4gICAgICAgIHRoaXMuRkxBU0hfU0laRVMgPSB7XG4gICAgICAgICAgICBcIjFNQlwiOiAweDAwLFxuICAgICAgICAgICAgXCIyTUJcIjogMHgxMCxcbiAgICAgICAgICAgIFwiNE1CXCI6IDB4MjAsXG4gICAgICAgICAgICBcIjhNQlwiOiAweDMwLFxuICAgICAgICAgICAgXCIxNk1CXCI6IDB4NDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuU1BJX1JFR19CQVNFID0gMHg2MDAwMjAwMDtcbiAgICAgICAgdGhpcy5TUElfVVNSX09GRlMgPSAweDE4O1xuICAgICAgICB0aGlzLlNQSV9VU1IxX09GRlMgPSAweDFjO1xuICAgICAgICB0aGlzLlNQSV9VU1IyX09GRlMgPSAweDIwO1xuICAgICAgICB0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUyA9IDB4MjQ7XG4gICAgICAgIHRoaXMuU1BJX01JU09fRExFTl9PRkZTID0gMHgyODtcbiAgICAgICAgdGhpcy5TUElfVzBfT0ZGUyA9IDB4NTg7XG4gICAgICAgIHRoaXMuVVNCX1JBTV9CTE9DSyA9IDB4ODAwO1xuICAgICAgICB0aGlzLlVBUlRERVZfQlVGX05PX1VTQiA9IDM7XG4gICAgICAgIHRoaXMuVUFSVERFVl9CVUZfTk8gPSAweDNmY2VmMTRjO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG1ham9yUmV2ID0gYXdhaXQgdGhpcy5nZXRNYWpvckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IG1pbm9yUmV2ID0gYXdhaXQgdGhpcy5nZXRNaW5vckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IHBrZ1ZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24obG9hZGVyKTtcbiAgICAgICAgY29uc3QgY2hpcE5hbWUgPSB7XG4gICAgICAgICAgICAwOiBcIkVTUDMyLVMzIChRRk41NilcIixcbiAgICAgICAgICAgIDE6IFwiRVNQMzItUzMtUElDTy0xIChMR0E1NilcIixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGAke2NoaXBOYW1lW3BrZ1ZlcnNpb25dIHx8IFwidW5rbm93biBFU1AzMi1TM1wifSAocmV2aXNpb24gdiR7bWFqb3JSZXZ9LiR7bWlub3JSZXZ9KWA7XG4gICAgfVxuICAgIGFzeW5jIGdldFBrZ1ZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSAzO1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAyMSkgJiAweDA3O1xuICAgIH1cbiAgICBhc3luYyBnZXRSYXdNaW5vckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBoaU51bVdvcmQgPSA1O1xuICAgICAgICBjb25zdCBoaSA9ICgoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUiArIDQgKiBoaU51bVdvcmQpKSA+PiAyMykgJiAweDAxO1xuICAgICAgICBjb25zdCBsb3dOdW1Xb3JkID0gMztcbiAgICAgICAgY29uc3QgbG93ID0gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSICsgNCAqIGxvd051bVdvcmQpKSA+PiAxOCkgJiAweDA3O1xuICAgICAgICByZXR1cm4gKGhpIDw8IDMpICsgbG93O1xuICAgIH1cbiAgICBhc3luYyBnZXRNaW5vckNoaXBWZXJzaW9uKGxvYWRlcikge1xuICAgICAgICBjb25zdCBtaW5vclJhdyA9IGF3YWl0IHRoaXMuZ2V0UmF3TWlub3JDaGlwVmVyc2lvbihsb2FkZXIpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc0VjbzAobG9hZGVyLCBtaW5vclJhdykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJhd01pbm9yQ2hpcFZlcnNpb24obG9hZGVyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmF3TWFqb3JDaGlwVmVyc2lvbihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDU7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDI0KSAmIDB4MDM7XG4gICAgfVxuICAgIGFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG1pbm9yUmF3ID0gYXdhaXQgdGhpcy5nZXRSYXdNaW5vckNoaXBWZXJzaW9uKGxvYWRlcik7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRWNvMChsb2FkZXIsIG1pbm9yUmF3KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3TWFqb3JDaGlwVmVyc2lvbihsb2FkZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCbGtWZXJzaW9uTWFqb3IobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICByZXR1cm4gKChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMl9BRERSICsgNCAqIG51bVdvcmQpKSA+PiAwKSAmIDB4MDM7XG4gICAgfVxuICAgIGFzeW5jIGdldEJsa1ZlcnNpb25NaW5vcihsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDM7XG4gICAgICAgIHJldHVybiAoKGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIgKyA0ICogbnVtV29yZCkpID4+IDI0KSAmIDB4MDc7XG4gICAgfVxuICAgIGFzeW5jIGlzRWNvMChsb2FkZXIsIG1pbm9yUmF3KSB7XG4gICAgICAgIC8vIFdvcmthcm91bmQ6IFRoZSBtYWpvciB2ZXJzaW9uIGZpZWxkIHdhcyBhbGxvY2F0ZWQgdG8gb3RoZXIgcHVycG9zZXNcbiAgICAgICAgLy8gd2hlbiBibG9jayB2ZXJzaW9uIGlzIHYxLjEuXG4gICAgICAgIC8vIEx1Y2tpbHkgb25seSBjaGlwIHYwLjAgaGF2ZSB0aGlzIGtpbmQgb2YgYmxvY2sgdmVyc2lvbiBhbmQgZWZ1c2UgdXNhZ2UuXG4gICAgICAgIHJldHVybiAoKG1pbm9yUmF3ICYgMHg3KSA9PT0gMCAmJlxuICAgICAgICAgICAgKGF3YWl0IHRoaXMuZ2V0QmxrVmVyc2lvbk1ham9yKGxvYWRlcikpID09PSAxICYmXG4gICAgICAgICAgICAoYXdhaXQgdGhpcy5nZXRCbGtWZXJzaW9uTWlub3IobG9hZGVyKSkgPT09IDEpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGbGFzaENhcChsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgbnVtV29yZCA9IDM7XG4gICAgICAgIGNvbnN0IGJsb2NrMUFkZHIgPSB0aGlzLkVGVVNFX0JBU0UgKyAweDA0NDtcbiAgICAgICAgY29uc3QgYWRkciA9IGJsb2NrMUFkZHIgKyA0ICogbnVtV29yZDtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJWYWx1ZSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgICAgICBjb25zdCBmbGFzaENhcCA9IChyZWdpc3RlclZhbHVlID4+IDI3KSAmIDB4MDc7XG4gICAgICAgIHJldHVybiBmbGFzaENhcDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmxhc2hWZW5kb3IobG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IG51bVdvcmQgPSA0O1xuICAgICAgICBjb25zdCBibG9jazFBZGRyID0gdGhpcy5FRlVTRV9CQVNFICsgMHgwNDQ7XG4gICAgICAgIGNvbnN0IGFkZHIgPSBibG9jazFBZGRyICsgNCAqIG51bVdvcmQ7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVmFsdWUgPSBhd2FpdCBsb2FkZXIucmVhZFJlZyhhZGRyKTtcbiAgICAgICAgY29uc3QgdmVuZG9ySWQgPSAocmVnaXN0ZXJWYWx1ZSA+PiAwKSAmIDB4MDc7XG4gICAgICAgIGNvbnN0IHZlbmRvck1hcCA9IHtcbiAgICAgICAgICAgIDE6IFwiWE1DXCIsXG4gICAgICAgICAgICAyOiBcIkdEXCIsXG4gICAgICAgICAgICAzOiBcIkZNXCIsXG4gICAgICAgICAgICA0OiBcIlRUXCIsXG4gICAgICAgICAgICA1OiBcIkJZXCIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2ZW5kb3JNYXBbdmVuZG9ySWRdIHx8IFwiXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldFBzcmFtQ2FwKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gNDtcbiAgICAgICAgY29uc3QgYmxvY2sxQWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IHBzcmFtQ2FwID0gKHJlZ2lzdGVyVmFsdWUgPj4gMykgJiAweDAzO1xuICAgICAgICByZXR1cm4gcHNyYW1DYXA7XG4gICAgfVxuICAgIGFzeW5jIGdldFBzcmFtVmVuZG9yKGxvYWRlcikge1xuICAgICAgICBjb25zdCBudW1Xb3JkID0gNDtcbiAgICAgICAgY29uc3QgYmxvY2sxQWRkciA9IHRoaXMuRUZVU0VfQkFTRSArIDB4MDQ0O1xuICAgICAgICBjb25zdCBhZGRyID0gYmxvY2sxQWRkciArIDQgKiBudW1Xb3JkO1xuICAgICAgICBjb25zdCByZWdpc3RlclZhbHVlID0gYXdhaXQgbG9hZGVyLnJlYWRSZWcoYWRkcik7XG4gICAgICAgIGNvbnN0IHZlbmRvcklkID0gKHJlZ2lzdGVyVmFsdWUgPj4gNykgJiAweDAzO1xuICAgICAgICBjb25zdCB2ZW5kb3JNYXAgPSB7XG4gICAgICAgICAgICAxOiBcIkFQXzN2M1wiLFxuICAgICAgICAgICAgMjogXCJBUF8xdjhcIixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZlbmRvck1hcFt2ZW5kb3JJZF0gfHwgXCJcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGxvYWRlcikge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtcIldpLUZpXCIsIFwiQkxFXCJdO1xuICAgICAgICBjb25zdCBmbGFzaE1hcCA9IHtcbiAgICAgICAgICAgIDA6IG51bGwsXG4gICAgICAgICAgICAxOiBcIkVtYmVkZGVkIEZsYXNoIDhNQlwiLFxuICAgICAgICAgICAgMjogXCJFbWJlZGRlZCBGbGFzaCA0TUJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhc2hDYXAgPSBhd2FpdCB0aGlzLmdldEZsYXNoQ2FwKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IGZsYXNoVmVuZG9yID0gYXdhaXQgdGhpcy5nZXRGbGFzaFZlbmRvcihsb2FkZXIpO1xuICAgICAgICBjb25zdCBmbGFzaCA9IGZsYXNoTWFwW2ZsYXNoQ2FwXTtcbiAgICAgICAgY29uc3QgZmxhc2hEZXNjcmlwdGlvbiA9IGZsYXNoICE9PSB1bmRlZmluZWQgPyBmbGFzaCA6IFwiVW5rbm93biBFbWJlZGRlZCBGbGFzaFwiO1xuICAgICAgICBpZiAoZmxhc2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goYCR7Zmxhc2hEZXNjcmlwdGlvbn0gKCR7Zmxhc2hWZW5kb3J9KWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBzcmFtTWFwID0ge1xuICAgICAgICAgICAgMDogbnVsbCxcbiAgICAgICAgICAgIDE6IFwiRW1iZWRkZWQgUFNSQU0gOE1CXCIsXG4gICAgICAgICAgICAyOiBcIkVtYmVkZGVkIFBTUkFNIDJNQlwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwc3JhbUNhcCA9IGF3YWl0IHRoaXMuZ2V0UHNyYW1DYXAobG9hZGVyKTtcbiAgICAgICAgY29uc3QgcHNyYW1WZW5kb3IgPSBhd2FpdCB0aGlzLmdldFBzcmFtVmVuZG9yKGxvYWRlcik7XG4gICAgICAgIGNvbnN0IHBzcmFtID0gcHNyYW1NYXBbcHNyYW1DYXBdO1xuICAgICAgICBjb25zdCBwc3JhbURlc2NyaXB0aW9uID0gcHNyYW0gIT09IHVuZGVmaW5lZCA/IHBzcmFtIDogXCJVbmtub3duIEVtYmVkZGVkIFBTUkFNXCI7XG4gICAgICAgIGlmIChwc3JhbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChgJHtwc3JhbURlc2NyaXB0aW9ufSAoJHtwc3JhbVZlbmRvcn0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIDQwO1xuICAgIH1cbiAgICBfZDJoKGQpIHtcbiAgICAgICAgY29uc3QgaCA9ICgrZCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGggOiBoO1xuICAgIH1cbiAgICBhc3luYyBwb3N0Q29ubmVjdChsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgYnVmTm8gPSAoYXdhaXQgbG9hZGVyLnJlYWRSZWcodGhpcy5VQVJUREVWX0JVRl9OTykpICYgMHhmZjtcbiAgICAgICAgbG9hZGVyLmRlYnVnKFwiSW4gX3Bvc3RfY29ubmVjdCBcIiArIGJ1Zk5vKTtcbiAgICAgICAgaWYgKGJ1Zk5vID09IHRoaXMuVUFSVERFVl9CVUZfTk9fVVNCKSB7XG4gICAgICAgICAgICBsb2FkZXIuRVNQX1JBTV9CTE9DSyA9IHRoaXMuVVNCX1JBTV9CTE9DSztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkTWFjKGxvYWRlcikge1xuICAgICAgICBsZXQgbWFjMCA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRyk7XG4gICAgICAgIG1hYzAgPSBtYWMwID4+PiAwO1xuICAgICAgICBsZXQgbWFjMSA9IGF3YWl0IGxvYWRlci5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRyArIDQpO1xuICAgICAgICBtYWMxID0gKG1hYzEgPj4+IDApICYgMHgwMDAwZmZmZjtcbiAgICAgICAgY29uc3QgbWFjID0gbmV3IFVpbnQ4QXJyYXkoNik7XG4gICAgICAgIG1hY1swXSA9IChtYWMxID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzFdID0gbWFjMSAmIDB4ZmY7XG4gICAgICAgIG1hY1syXSA9IChtYWMwID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIG1hY1szXSA9IChtYWMwID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIG1hY1s0XSA9IChtYWMwID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzVdID0gbWFjMCAmIDB4ZmY7XG4gICAgICAgIHJldHVybiAodGhpcy5fZDJoKG1hY1swXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1sxXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1syXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1szXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s0XSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s1XSkpO1xuICAgIH1cbiAgICBnZXRFcmFzZVNpemUob2Zmc2V0LCBzaXplKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp32s3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/esp8266.js":
/*!********************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/esp8266.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESP8266ROM: () => (/* binding */ ESP8266ROM)\n/* harmony export */ });\n/* harmony import */ var _rom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rom.js */ \"(ssr)/./node_modules/esptool-js/lib/targets/rom.js\");\n\nclass ESP8266ROM extends _rom_js__WEBPACK_IMPORTED_MODULE_0__.ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP8266\";\n        this.CHIP_DETECT_MAGIC_VALUE = [0xfff0c101];\n        this.EFUSE_RD_REG_BASE = 0x3ff00050;\n        this.UART_CLKDIV_REG = 0x60000014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.XTAL_CLK_DIVIDER = 2;\n        this.FLASH_WRITE_SIZE = 0x4000;\n        // NOT IMPLEMENTED, SETTING EMPTY VALUE\n        this.BOOTLOADER_FLASH_OFFSET = 0;\n        this.UART_DATE_REG_ADDR = 0;\n        this.FLASH_SIZES = {\n            \"512KB\": 0x00,\n            \"256KB\": 0x10,\n            \"1MB\": 0x20,\n            \"2MB\": 0x30,\n            \"4MB\": 0x40,\n            \"2MB-c1\": 0x50,\n            \"4MB-c1\": 0x60,\n            \"8MB\": 0x80,\n            \"16MB\": 0x90,\n        };\n        this.SPI_REG_BASE = 0x60000200;\n        this.SPI_USR_OFFS = 0x1c;\n        this.SPI_USR1_OFFS = 0x20;\n        this.SPI_USR2_OFFS = 0x24;\n        this.SPI_MOSI_DLEN_OFFS = 0; // not in esp8266\n        this.SPI_MISO_DLEN_OFFS = 0; // not in esp8266\n        this.SPI_W0_OFFS = 0x40;\n        this.getChipFeatures = async (loader) => {\n            const features = [\"WiFi\"];\n            if ((await this.getChipDescription(loader)) == \"ESP8285\")\n                features.push(\"Embedded Flash\");\n            return features;\n        };\n    }\n    async readEfuse(loader, offset) {\n        const addr = this.EFUSE_RD_REG_BASE + 4 * offset;\n        loader.debug(\"Read efuse \" + addr);\n        return await loader.readReg(addr);\n    }\n    async getChipDescription(loader) {\n        const efuse3 = await this.readEfuse(loader, 2);\n        const efuse0 = await this.readEfuse(loader, 0);\n        const is8285 = ((efuse0 & (1 << 4)) | (efuse3 & (1 << 16))) != 0; // One or the other efuse bit is set for ESP8285\n        return is8285 ? \"ESP8285\" : \"ESP8266EX\";\n    }\n    async getCrystalFreq(loader) {\n        const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;\n        const etsXtal = (loader.transport.baudrate * uartDiv) / 1000000 / this.XTAL_CLK_DIVIDER;\n        let normXtal;\n        if (etsXtal > 33) {\n            normXtal = 40;\n        }\n        else {\n            normXtal = 26;\n        }\n        if (Math.abs(normXtal - etsXtal) > 1) {\n            loader.info(\"WARNING: Detected crystal freq \" +\n                etsXtal +\n                \"MHz is quite different to normalized freq \" +\n                normXtal +\n                \"MHz. Unsupported crystal in use?\");\n        }\n        return normXtal;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async readMac(loader) {\n        let mac0 = await this.readEfuse(loader, 0);\n        mac0 = mac0 >>> 0;\n        let mac1 = await this.readEfuse(loader, 1);\n        mac1 = mac1 >>> 0;\n        let mac3 = await this.readEfuse(loader, 3);\n        mac3 = mac3 >>> 0;\n        const mac = new Uint8Array(6);\n        if (mac3 != 0) {\n            mac[0] = (mac3 >> 16) & 0xff;\n            mac[1] = (mac3 >> 8) & 0xff;\n            mac[2] = mac3 & 0xff;\n        }\n        else if (((mac1 >> 16) & 0xff) == 0) {\n            mac[0] = 0x18;\n            mac[1] = 0xfe;\n            mac[2] = 0x34;\n        }\n        else if (((mac1 >> 16) & 0xff) == 1) {\n            mac[0] = 0xac;\n            mac[1] = 0xd0;\n            mac[2] = 0x74;\n        }\n        else {\n            loader.error(\"Unknown OUI\");\n        }\n        mac[3] = (mac1 >> 8) & 0xff;\n        mac[4] = mac1 & 0xff;\n        mac[5] = (mac0 >> 24) & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9lc3A4MjY2LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQ3hCLHlCQUF5Qix3Q0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhdGlvbmJvYXJkLXVwbG9hZGVyLy4vbm9kZV9tb2R1bGVzL2VzcHRvb2wtanMvbGliL3RhcmdldHMvZXNwODI2Ni5qcz83ZWQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJPTSB9IGZyb20gXCIuL3JvbS5qc1wiO1xuZXhwb3J0IGNsYXNzIEVTUDgyNjZST00gZXh0ZW5kcyBST00ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLkNISVBfTkFNRSA9IFwiRVNQODI2NlwiO1xuICAgICAgICB0aGlzLkNISVBfREVURUNUX01BR0lDX1ZBTFVFID0gWzB4ZmZmMGMxMDFdO1xuICAgICAgICB0aGlzLkVGVVNFX1JEX1JFR19CQVNFID0gMHgzZmYwMDA1MDtcbiAgICAgICAgdGhpcy5VQVJUX0NMS0RJVl9SRUcgPSAweDYwMDAwMDE0O1xuICAgICAgICB0aGlzLlVBUlRfQ0xLRElWX01BU0sgPSAweGZmZmZmO1xuICAgICAgICB0aGlzLlhUQUxfQ0xLX0RJVklERVIgPSAyO1xuICAgICAgICB0aGlzLkZMQVNIX1dSSVRFX1NJWkUgPSAweDQwMDA7XG4gICAgICAgIC8vIE5PVCBJTVBMRU1FTlRFRCwgU0VUVElORyBFTVBUWSBWQUxVRVxuICAgICAgICB0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUID0gMDtcbiAgICAgICAgdGhpcy5VQVJUX0RBVEVfUkVHX0FERFIgPSAwO1xuICAgICAgICB0aGlzLkZMQVNIX1NJWkVTID0ge1xuICAgICAgICAgICAgXCI1MTJLQlwiOiAweDAwLFxuICAgICAgICAgICAgXCIyNTZLQlwiOiAweDEwLFxuICAgICAgICAgICAgXCIxTUJcIjogMHgyMCxcbiAgICAgICAgICAgIFwiMk1CXCI6IDB4MzAsXG4gICAgICAgICAgICBcIjRNQlwiOiAweDQwLFxuICAgICAgICAgICAgXCIyTUItYzFcIjogMHg1MCxcbiAgICAgICAgICAgIFwiNE1CLWMxXCI6IDB4NjAsXG4gICAgICAgICAgICBcIjhNQlwiOiAweDgwLFxuICAgICAgICAgICAgXCIxNk1CXCI6IDB4OTAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuU1BJX1JFR19CQVNFID0gMHg2MDAwMDIwMDtcbiAgICAgICAgdGhpcy5TUElfVVNSX09GRlMgPSAweDFjO1xuICAgICAgICB0aGlzLlNQSV9VU1IxX09GRlMgPSAweDIwO1xuICAgICAgICB0aGlzLlNQSV9VU1IyX09GRlMgPSAweDI0O1xuICAgICAgICB0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUyA9IDA7IC8vIG5vdCBpbiBlc3A4MjY2XG4gICAgICAgIHRoaXMuU1BJX01JU09fRExFTl9PRkZTID0gMDsgLy8gbm90IGluIGVzcDgyNjZcbiAgICAgICAgdGhpcy5TUElfVzBfT0ZGUyA9IDB4NDA7XG4gICAgICAgIHRoaXMuZ2V0Q2hpcEZlYXR1cmVzID0gYXN5bmMgKGxvYWRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbXCJXaUZpXCJdO1xuICAgICAgICAgICAgaWYgKChhd2FpdCB0aGlzLmdldENoaXBEZXNjcmlwdGlvbihsb2FkZXIpKSA9PSBcIkVTUDgyODVcIilcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiRW1iZWRkZWQgRmxhc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlYWRFZnVzZShsb2FkZXIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5FRlVTRV9SRF9SRUdfQkFTRSArIDQgKiBvZmZzZXQ7XG4gICAgICAgIGxvYWRlci5kZWJ1ZyhcIlJlYWQgZWZ1c2UgXCIgKyBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRlci5yZWFkUmVnKGFkZHIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGlwRGVzY3JpcHRpb24obG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IGVmdXNlMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMik7XG4gICAgICAgIGNvbnN0IGVmdXNlMCA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMCk7XG4gICAgICAgIGNvbnN0IGlzODI4NSA9ICgoZWZ1c2UwICYgKDEgPDwgNCkpIHwgKGVmdXNlMyAmICgxIDw8IDE2KSkpICE9IDA7IC8vIE9uZSBvciB0aGUgb3RoZXIgZWZ1c2UgYml0IGlzIHNldCBmb3IgRVNQODI4NVxuICAgICAgICByZXR1cm4gaXM4Mjg1ID8gXCJFU1A4Mjg1XCIgOiBcIkVTUDgyNjZFWFwiO1xuICAgIH1cbiAgICBhc3luYyBnZXRDcnlzdGFsRnJlcShsb2FkZXIpIHtcbiAgICAgICAgY29uc3QgdWFydERpdiA9IChhd2FpdCBsb2FkZXIucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykpICYgdGhpcy5VQVJUX0NMS0RJVl9NQVNLO1xuICAgICAgICBjb25zdCBldHNYdGFsID0gKGxvYWRlci50cmFuc3BvcnQuYmF1ZHJhdGUgKiB1YXJ0RGl2KSAvIDEwMDAwMDAgLyB0aGlzLlhUQUxfQ0xLX0RJVklERVI7XG4gICAgICAgIGxldCBub3JtWHRhbDtcbiAgICAgICAgaWYgKGV0c1h0YWwgPiAzMykge1xuICAgICAgICAgICAgbm9ybVh0YWwgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1YdGFsID0gMjY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG5vcm1YdGFsIC0gZXRzWHRhbCkgPiAxKSB7XG4gICAgICAgICAgICBsb2FkZXIuaW5mbyhcIldBUk5JTkc6IERldGVjdGVkIGNyeXN0YWwgZnJlcSBcIiArXG4gICAgICAgICAgICAgICAgZXRzWHRhbCArXG4gICAgICAgICAgICAgICAgXCJNSHogaXMgcXVpdGUgZGlmZmVyZW50IHRvIG5vcm1hbGl6ZWQgZnJlcSBcIiArXG4gICAgICAgICAgICAgICAgbm9ybVh0YWwgK1xuICAgICAgICAgICAgICAgIFwiTUh6LiBVbnN1cHBvcnRlZCBjcnlzdGFsIGluIHVzZT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1YdGFsO1xuICAgIH1cbiAgICBfZDJoKGQpIHtcbiAgICAgICAgY29uc3QgaCA9ICgrZCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGggOiBoO1xuICAgIH1cbiAgICBhc3luYyByZWFkTWFjKGxvYWRlcikge1xuICAgICAgICBsZXQgbWFjMCA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMCk7XG4gICAgICAgIG1hYzAgPSBtYWMwID4+PiAwO1xuICAgICAgICBsZXQgbWFjMSA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMSk7XG4gICAgICAgIG1hYzEgPSBtYWMxID4+PiAwO1xuICAgICAgICBsZXQgbWFjMyA9IGF3YWl0IHRoaXMucmVhZEVmdXNlKGxvYWRlciwgMyk7XG4gICAgICAgIG1hYzMgPSBtYWMzID4+PiAwO1xuICAgICAgICBjb25zdCBtYWMgPSBuZXcgVWludDhBcnJheSg2KTtcbiAgICAgICAgaWYgKG1hYzMgIT0gMCkge1xuICAgICAgICAgICAgbWFjWzBdID0gKG1hYzMgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIG1hY1sxXSA9IChtYWMzID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIG1hY1syXSA9IG1hYzMgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgobWFjMSA+PiAxNikgJiAweGZmKSA9PSAwKSB7XG4gICAgICAgICAgICBtYWNbMF0gPSAweDE4O1xuICAgICAgICAgICAgbWFjWzFdID0gMHhmZTtcbiAgICAgICAgICAgIG1hY1syXSA9IDB4MzQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChtYWMxID4+IDE2KSAmIDB4ZmYpID09IDEpIHtcbiAgICAgICAgICAgIG1hY1swXSA9IDB4YWM7XG4gICAgICAgICAgICBtYWNbMV0gPSAweGQwO1xuICAgICAgICAgICAgbWFjWzJdID0gMHg3NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRlci5lcnJvcihcIlVua25vd24gT1VJXCIpO1xuICAgICAgICB9XG4gICAgICAgIG1hY1szXSA9IChtYWMxID4+IDgpICYgMHhmZjtcbiAgICAgICAgbWFjWzRdID0gbWFjMSAmIDB4ZmY7XG4gICAgICAgIG1hY1s1XSA9IChtYWMwID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiAodGhpcy5fZDJoKG1hY1swXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1sxXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1syXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1szXSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s0XSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgdGhpcy5fZDJoKG1hY1s1XSkpO1xuICAgIH1cbiAgICBnZXRFcmFzZVNpemUob2Zmc2V0LCBzaXplKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/esp8266.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/rom.js":
/*!****************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/rom.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ROM: () => (/* binding */ ROM)\n/* harmony export */ });\n/**\n * Represents a chip ROM with basic registers field and abstract functions.\n */\nclass ROM {\n    /**\n     * Get the chip erase size.\n     * @param {number} offset - Offset to start erase.\n     * @param {number} size - Size to erase.\n     * @returns {number} The erase size of the chip as number.\n     */\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdGFyZ2V0cy9yb20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpb25ib2FyZC11cGxvYWRlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90YXJnZXRzL3JvbS5qcz8yZGFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBhIGNoaXAgUk9NIHdpdGggYmFzaWMgcmVnaXN0ZXJzIGZpZWxkIGFuZCBhYnN0cmFjdCBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBST00ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hpcCBlcmFzZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgZXJhc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBTaXplIHRvIGVyYXNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlcmFzZSBzaXplIG9mIHRoZSBjaGlwIGFzIG51bWJlci5cbiAgICAgKi9cbiAgICBnZXRFcmFzZVNpemUob2Zmc2V0LCBzaXplKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/targets/rom.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/types/error.js":
/*!****************************************************!*\
  !*** ./node_modules/esptool-js/lib/types/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESPError: () => (/* binding */ ESPError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError)\n/* harmony export */ });\n/**\n * Represents a Espressif chip error.\n */\nclass ESPError extends Error {\n}\n/**\n * Represents a Espressif timeout chip error.\n */\nclass TimeoutError extends ESPError {\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdHlwZXMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpb25ib2FyZC11cGxvYWRlci8uL25vZGVfbW9kdWxlcy9lc3B0b29sLWpzL2xpYi90eXBlcy9lcnJvci5qcz9hOTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBhIEVzcHJlc3NpZiBjaGlwIGVycm9yLlxuICovXG5jbGFzcyBFU1BFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIEVzcHJlc3NpZiB0aW1lb3V0IGNoaXAgZXJyb3IuXG4gKi9cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVTUEVycm9yIHtcbn1cbmV4cG9ydCB7IEVTUEVycm9yLCBUaW1lb3V0RXJyb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/types/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/esptool-js/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   padTo: () => (/* binding */ padTo)\n/* harmony export */ });\n/**\n * Pad to the next alignment boundary\n * @param {Uint8Array} data Uint8Array data to pad\n * @param {number} alignment Alignment boundary to fulfill\n * @param {number} padCharacter Character to fill with\n * @returns {Uint8Array} Padded UInt8Array image\n */\nfunction padTo(data, alignment, padCharacter = 0xff) {\n    const padMod = data.length % alignment;\n    if (padMod !== 0) {\n        const padding = new Uint8Array(alignment - padMod).fill(padCharacter);\n        const paddedData = new Uint8Array(data.length + padding.length);\n        paddedData.set(data);\n        paddedData.set(padding, data.length);\n        return paddedData;\n    }\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvdXRpbC5qcz82YjgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFkIHRvIHRoZSBuZXh0IGFsaWdubWVudCBib3VuZGFyeVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIFVpbnQ4QXJyYXkgZGF0YSB0byBwYWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGlnbm1lbnQgQWxpZ25tZW50IGJvdW5kYXJ5IHRvIGZ1bGZpbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRDaGFyYWN0ZXIgQ2hhcmFjdGVyIHRvIGZpbGwgd2l0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFBhZGRlZCBVSW50OEFycmF5IGltYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRUbyhkYXRhLCBhbGlnbm1lbnQsIHBhZENoYXJhY3RlciA9IDB4ZmYpIHtcbiAgICBjb25zdCBwYWRNb2QgPSBkYXRhLmxlbmd0aCAlIGFsaWdubWVudDtcbiAgICBpZiAocGFkTW9kICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheShhbGlnbm1lbnQgLSBwYWRNb2QpLmZpbGwocGFkQ2hhcmFjdGVyKTtcbiAgICAgICAgY29uc3QgcGFkZGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGluZy5sZW5ndGgpO1xuICAgICAgICBwYWRkZWREYXRhLnNldChkYXRhKTtcbiAgICAgICAgcGFkZGVkRGF0YS5zZXQocGFkZGluZywgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcGFkZGVkRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/webserial.js":
/*!**************************************************!*\
  !*** ./node_modules/esptool-js/lib/webserial.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transport: () => (/* binding */ Transport)\n/* harmony export */ });\n/* global SerialPort, ParityType, FlowControlType */\n/**\n * Wrapper class around Webserial API to communicate with the serial device.\n * @param {typeof import(\"w3c-web-serial\").SerialPort} device - Requested device prompted by the browser.\n *\n * ```\n * const port = await navigator.serial.requestPort();\n * ```\n */\nclass Transport {\n    constructor(device, tracing = false, enableSlipReader = true) {\n        this.device = device;\n        this.tracing = tracing;\n        this.slipReaderEnabled = false;\n        this.baudrate = 0;\n        this.traceLog = \"\";\n        this.lastTraceTime = Date.now();\n        this.buffer = new Uint8Array(0);\n        this.SLIP_END = 0xc0;\n        this.SLIP_ESC = 0xdb;\n        this.SLIP_ESC_END = 0xdc;\n        this.SLIP_ESC_ESC = 0xdd;\n        this._DTR_state = false;\n        this.slipReaderEnabled = enableSlipReader;\n    }\n    /**\n     * Request the serial device vendor ID and Product ID as string.\n     * @returns {string} Return the device VendorID and ProductID from SerialPortInfo as formatted string.\n     */\n    getInfo() {\n        const info = this.device.getInfo();\n        return info.usbVendorId && info.usbProductId\n            ? `WebSerial VendorID 0x${info.usbVendorId.toString(16)} ProductID 0x${info.usbProductId.toString(16)}`\n            : \"\";\n    }\n    /**\n     * Request the serial device product id from SerialPortInfo.\n     * @returns {number | undefined} Return the product ID.\n     */\n    getPid() {\n        return this.device.getInfo().usbProductId;\n    }\n    /**\n     * Format received or sent data for tracing output.\n     * @param {string} message Message to format as trace line.\n     */\n    trace(message) {\n        const delta = Date.now() - this.lastTraceTime;\n        const prefix = `TRACE ${delta.toFixed(3)}`;\n        const traceMessage = `${prefix} ${message}`;\n        console.log(traceMessage);\n        this.traceLog += traceMessage + \"\\n\";\n    }\n    async returnTrace() {\n        try {\n            await navigator.clipboard.writeText(this.traceLog);\n            console.log(\"Text copied to clipboard!\");\n        }\n        catch (err) {\n            console.error(\"Failed to copy text:\", err);\n        }\n    }\n    hexify(s) {\n        return Array.from(s)\n            .map((byte) => byte.toString(16).padStart(2, \"0\"))\n            .join(\"\")\n            .padEnd(16, \" \");\n    }\n    hexConvert(uint8Array, autoSplit = true) {\n        if (autoSplit && uint8Array.length > 16) {\n            let result = \"\";\n            let s = uint8Array;\n            while (s.length > 0) {\n                const line = s.slice(0, 16);\n                const asciiLine = String.fromCharCode(...line)\n                    .split(\"\")\n                    .map((c) => (c === \" \" || (c >= \" \" && c <= \"~\" && c !== \"  \") ? c : \".\"))\n                    .join(\"\");\n                s = s.slice(16);\n                result += `\\n    ${this.hexify(line.slice(0, 8))} ${this.hexify(line.slice(8))} | ${asciiLine}`;\n            }\n            return result;\n        }\n        else {\n            return this.hexify(uint8Array);\n        }\n    }\n    /**\n     * Format data packet using the Serial Line Internet Protocol (SLIP).\n     * @param {Uint8Array} data Binary unsigned 8 bit array data to format.\n     * @returns {Uint8Array} Formatted unsigned 8 bit data array.\n     */\n    slipWriter(data) {\n        const outData = [];\n        outData.push(0xc0);\n        for (let i = 0; i < data.length; i++) {\n            if (data[i] === 0xdb) {\n                outData.push(0xdb, 0xdd);\n            }\n            else if (data[i] === 0xc0) {\n                outData.push(0xdb, 0xdc);\n            }\n            else {\n                outData.push(data[i]);\n            }\n        }\n        outData.push(0xc0);\n        return new Uint8Array(outData);\n    }\n    /**\n     * Write binary data to device using the WebSerial device writable stream.\n     * @param {Uint8Array} data 8 bit unsigned data array to write to device.\n     */\n    async write(data) {\n        const outData = this.slipWriter(data);\n        if (this.device.writable) {\n            const writer = this.device.writable.getWriter();\n            if (this.tracing) {\n                console.log(\"Write bytes\");\n                this.trace(`Write ${outData.length} bytes: ${this.hexConvert(outData)}`);\n            }\n            await writer.write(outData);\n            writer.releaseLock();\n        }\n    }\n    /**\n     * Append a buffer array after another buffer array\n     * @param {Uint8Array} arr1 - First array buffer.\n     * @param {Uint8Array} arr2 - magic hex number to select ROM.\n     * @returns {Uint8Array} Return a 8 bit unsigned array.\n     */\n    appendArray(arr1, arr2) {\n        const combined = new Uint8Array(arr1.length + arr2.length);\n        combined.set(arr1);\n        combined.set(arr2, arr1.length);\n        return combined;\n    }\n    // Asynchronous generator to yield incoming data chunks\n    async *readLoop(timeout) {\n        if (!this.reader)\n            return;\n        try {\n            while (true) {\n                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error(\"Read timeout exceeded\")), timeout));\n                // Await the race between the timeout and the reader read\n                const result = await Promise.race([this.reader.read(), timeoutPromise]);\n                // If a timeout occurs, result will be null; otherwise, it will have { value, done }\n                if (result === null)\n                    break;\n                const { value, done } = result;\n                if (done || !value)\n                    break;\n                yield value; // Yield each data chunk\n            }\n        }\n        catch (error) {\n            console.error(\"Error reading from serial port:\", error);\n        }\n        finally {\n            this.buffer = new Uint8Array(0);\n        }\n    }\n    // Read a specific number of bytes\n    async newRead(numBytes, timeout) {\n        if (this.buffer.length >= numBytes) {\n            const output = this.buffer.slice(0, numBytes);\n            this.buffer = this.buffer.slice(numBytes); // Remove the returned data from buffer\n            return output;\n        }\n        while (this.buffer.length < numBytes) {\n            const readLoop = this.readLoop(timeout);\n            const { value, done } = await readLoop.next();\n            if (done || !value) {\n                break;\n            }\n            // Append the newly read data to the buffer\n            this.buffer = this.appendArray(this.buffer, value);\n        }\n        // Return as much data as possible\n        const output = this.buffer.slice(0, numBytes);\n        this.buffer = this.buffer.slice(numBytes);\n        return output;\n    }\n    async flushInput() {\n        var _a;\n        if (this.reader && !(await this.reader.closed)) {\n            await this.reader.cancel();\n            this.reader.releaseLock();\n            this.reader = (_a = this.device.readable) === null || _a === void 0 ? void 0 : _a.getReader();\n        }\n    }\n    async flushOutput() {\n        var _a, _b;\n        this.buffer = new Uint8Array(0);\n        await ((_a = this.device.writable) === null || _a === void 0 ? void 0 : _a.getWriter().close());\n        (_b = this.device.writable) === null || _b === void 0 ? void 0 : _b.getWriter().releaseLock();\n    }\n    // `inWaiting` returns the count of bytes in the buffer\n    inWaiting() {\n        return this.buffer.length;\n    }\n    /**\n     * Detect if the data read from device is a Fatal or Guru meditation error.\n     * @param {Uint8Array} input Data read from device\n     */\n    detectPanicHandler(input) {\n        const guruMeditationRegex = /G?uru Meditation Error: (?:Core \\d panic'ed \\(([a-zA-Z ]*)\\))?/;\n        const fatalExceptionRegex = /F?atal exception \\(\\d+\\): (?:([a-zA-Z ]*)?.*epc)?/;\n        const inputString = new TextDecoder(\"utf-8\").decode(input);\n        const match = inputString.match(guruMeditationRegex) || inputString.match(fatalExceptionRegex);\n        if (match) {\n            const cause = match[1] || match[2];\n            const msg = `Guru Meditation Error detected${cause ? ` (${cause})` : \"\"}`;\n            throw new Error(msg);\n        }\n    }\n    /**\n     * Take a data array and return the first well formed packet after\n     * replacing the escape sequence. Reads at least 8 bytes.\n     * @param {number} timeout Timeout read data.\n     * @yields {Uint8Array} Formatted packet using SLIP escape sequences.\n     */\n    async *read(timeout) {\n        var _a;\n        if (!this.reader) {\n            this.reader = (_a = this.device.readable) === null || _a === void 0 ? void 0 : _a.getReader();\n        }\n        let partialPacket = null;\n        let isEscaping = false;\n        let successfulSlip = false;\n        while (true) {\n            const waitingBytes = this.inWaiting();\n            const readBytes = await this.newRead(waitingBytes > 0 ? waitingBytes : 1, timeout);\n            if (!readBytes || readBytes.length === 0) {\n                const msg = partialPacket === null\n                    ? successfulSlip\n                        ? \"Serial data stream stopped: Possible serial noise or corruption.\"\n                        : \"No serial data received.\"\n                    : `Packet content transfer stopped`;\n                this.trace(msg);\n                throw new Error(msg);\n            }\n            this.trace(`Read ${readBytes.length} bytes: ${this.hexConvert(readBytes)}`);\n            let i = 0; // Track position in readBytes\n            while (i < readBytes.length) {\n                const byte = readBytes[i++];\n                if (partialPacket === null) {\n                    if (byte === this.SLIP_END) {\n                        partialPacket = new Uint8Array(0); // Start of a new packet\n                    }\n                    else {\n                        this.trace(`Read invalid data: ${this.hexConvert(readBytes)}`);\n                        const remainingData = await this.newRead(this.inWaiting(), timeout);\n                        this.trace(`Remaining data in serial buffer: ${this.hexConvert(remainingData)}`);\n                        this.detectPanicHandler(new Uint8Array([...readBytes, ...(remainingData || [])]));\n                        throw new Error(`Invalid head of packet (0x${byte.toString(16)}): Possible serial noise or corruption.`);\n                    }\n                }\n                else if (isEscaping) {\n                    isEscaping = false;\n                    if (byte === this.SLIP_ESC_END) {\n                        partialPacket = this.appendArray(partialPacket, new Uint8Array([this.SLIP_END]));\n                    }\n                    else if (byte === this.SLIP_ESC_ESC) {\n                        partialPacket = this.appendArray(partialPacket, new Uint8Array([this.SLIP_ESC]));\n                    }\n                    else {\n                        this.trace(`Read invalid data: ${this.hexConvert(readBytes)}`);\n                        const remainingData = await this.newRead(this.inWaiting(), timeout);\n                        this.trace(`Remaining data in serial buffer: ${this.hexConvert(remainingData)}`);\n                        this.detectPanicHandler(new Uint8Array([...readBytes, ...(remainingData || [])]));\n                        throw new Error(`Invalid SLIP escape (0xdb, 0x${byte.toString(16)})`);\n                    }\n                }\n                else if (byte === this.SLIP_ESC) {\n                    isEscaping = true;\n                }\n                else if (byte === this.SLIP_END) {\n                    this.trace(`Received full packet: ${this.hexConvert(partialPacket)}`);\n                    this.buffer = this.appendArray(this.buffer, readBytes.slice(i));\n                    yield partialPacket;\n                    partialPacket = null;\n                    successfulSlip = true;\n                }\n                else {\n                    partialPacket = this.appendArray(partialPacket, new Uint8Array([byte]));\n                }\n            }\n        }\n    }\n    /**\n     * Read from serial device without slip formatting.\n     * @yields {Uint8Array} The next number in the Fibonacci sequence.\n     */\n    async *rawRead() {\n        if (!this.reader)\n            return;\n        try {\n            while (true) {\n                const { value, done } = await this.reader.read();\n                if (done || !value)\n                    break;\n                if (this.tracing) {\n                    console.log(\"Raw Read bytes\");\n                    this.trace(`Read ${value.length} bytes: ${this.hexConvert(value)}`);\n                }\n                yield value; // Yield each data chunk\n            }\n        }\n        catch (error) {\n            console.error(\"Error reading from serial port:\", error);\n        }\n        finally {\n            this.buffer = new Uint8Array(0);\n        }\n    }\n    /**\n     * Send the RequestToSend (RTS) signal to given state\n     * # True for EN=LOW, chip in reset and False EN=HIGH, chip out of reset\n     * @param {boolean} state Boolean state to set the signal\n     */\n    async setRTS(state) {\n        await this.device.setSignals({ requestToSend: state });\n        // # Work-around for adapters on Windows using the usbser.sys driver:\n        // # generate a dummy change to DTR so that the set-control-line-state\n        // # request is sent with the updated RTS state and the same DTR state\n        // Referenced to esptool.py\n        await this.setDTR(this._DTR_state);\n    }\n    /**\n     * Send the dataTerminalReady (DTS) signal to given state\n     * # True for IO0=LOW, chip in reset and False IO0=HIGH\n     * @param {boolean} state Boolean state to set the signal\n     */\n    async setDTR(state) {\n        this._DTR_state = state;\n        await this.device.setSignals({ dataTerminalReady: state });\n    }\n    /**\n     * Connect to serial device using the Webserial open method.\n     * @param {number} baud Number baud rate for serial connection. Default is 115200.\n     * @param {typeof import(\"w3c-web-serial\").SerialOptions} serialOptions Serial Options for WebUSB SerialPort class.\n     */\n    async connect(baud = 115200, serialOptions = {}) {\n        var _a;\n        await this.device.open({\n            baudRate: baud,\n            dataBits: serialOptions === null || serialOptions === void 0 ? void 0 : serialOptions.dataBits,\n            stopBits: serialOptions === null || serialOptions === void 0 ? void 0 : serialOptions.stopBits,\n            bufferSize: serialOptions === null || serialOptions === void 0 ? void 0 : serialOptions.bufferSize,\n            parity: serialOptions === null || serialOptions === void 0 ? void 0 : serialOptions.parity,\n            flowControl: serialOptions === null || serialOptions === void 0 ? void 0 : serialOptions.flowControl,\n        });\n        this.baudrate = baud;\n        this.reader = (_a = this.device.readable) === null || _a === void 0 ? void 0 : _a.getReader();\n    }\n    async sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /**\n     * Wait for a given timeout ms for serial device unlock.\n     * @param {number} timeout Timeout time in milliseconds (ms) to sleep\n     */\n    async waitForUnlock(timeout) {\n        while ((this.device.readable && this.device.readable.locked) ||\n            (this.device.writable && this.device.writable.locked)) {\n            await this.sleep(timeout);\n        }\n    }\n    /**\n     * Disconnect from serial device by running SerialPort.close() after streams unlock.\n     */\n    async disconnect() {\n        var _a, _b;\n        if ((_a = this.device.readable) === null || _a === void 0 ? void 0 : _a.locked) {\n            await ((_b = this.reader) === null || _b === void 0 ? void 0 : _b.cancel());\n        }\n        await this.waitForUnlock(400);\n        await this.device.close();\n        this.reader = undefined;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvd2Vic2VyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0JBQStCLGNBQWMsK0JBQStCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRCxnQ0FBZ0MsUUFBUSxFQUFFLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0IsRUFBRSw0QkFBNEIsSUFBSSxVQUFVO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdC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IjpbIndlYnBhY2s6Ly9zdGF0aW9uYm9hcmQtdXBsb2FkZXIvLi9ub2RlX21vZHVsZXMvZXNwdG9vbC1qcy9saWIvd2Vic2VyaWFsLmpzPzY1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIFNlcmlhbFBvcnQsIFBhcml0eVR5cGUsIEZsb3dDb250cm9sVHlwZSAqL1xuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGFyb3VuZCBXZWJzZXJpYWwgQVBJIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIHNlcmlhbCBkZXZpY2UuXG4gKiBAcGFyYW0ge3R5cGVvZiBpbXBvcnQoXCJ3M2Mtd2ViLXNlcmlhbFwiKS5TZXJpYWxQb3J0fSBkZXZpY2UgLSBSZXF1ZXN0ZWQgZGV2aWNlIHByb21wdGVkIGJ5IHRoZSBicm93c2VyLlxuICpcbiAqIGBgYFxuICogY29uc3QgcG9ydCA9IGF3YWl0IG5hdmlnYXRvci5zZXJpYWwucmVxdWVzdFBvcnQoKTtcbiAqIGBgYFxuICovXG5jbGFzcyBUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGRldmljZSwgdHJhY2luZyA9IGZhbHNlLCBlbmFibGVTbGlwUmVhZGVyID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgICAgdGhpcy50cmFjaW5nID0gdHJhY2luZztcbiAgICAgICAgdGhpcy5zbGlwUmVhZGVyRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhdWRyYXRlID0gMDtcbiAgICAgICAgdGhpcy50cmFjZUxvZyA9IFwiXCI7XG4gICAgICAgIHRoaXMubGFzdFRyYWNlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHRoaXMuU0xJUF9FTkQgPSAweGMwO1xuICAgICAgICB0aGlzLlNMSVBfRVNDID0gMHhkYjtcbiAgICAgICAgdGhpcy5TTElQX0VTQ19FTkQgPSAweGRjO1xuICAgICAgICB0aGlzLlNMSVBfRVNDX0VTQyA9IDB4ZGQ7XG4gICAgICAgIHRoaXMuX0RUUl9zdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNsaXBSZWFkZXJFbmFibGVkID0gZW5hYmxlU2xpcFJlYWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0aGUgc2VyaWFsIGRldmljZSB2ZW5kb3IgSUQgYW5kIFByb2R1Y3QgSUQgYXMgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybiB0aGUgZGV2aWNlIFZlbmRvcklEIGFuZCBQcm9kdWN0SUQgZnJvbSBTZXJpYWxQb3J0SW5mbyBhcyBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldEluZm8oKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmRldmljZS5nZXRJbmZvKCk7XG4gICAgICAgIHJldHVybiBpbmZvLnVzYlZlbmRvcklkICYmIGluZm8udXNiUHJvZHVjdElkXG4gICAgICAgICAgICA/IGBXZWJTZXJpYWwgVmVuZG9ySUQgMHgke2luZm8udXNiVmVuZG9ySWQudG9TdHJpbmcoMTYpfSBQcm9kdWN0SUQgMHgke2luZm8udXNiUHJvZHVjdElkLnRvU3RyaW5nKDE2KX1gXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdGhlIHNlcmlhbCBkZXZpY2UgcHJvZHVjdCBpZCBmcm9tIFNlcmlhbFBvcnRJbmZvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IFJldHVybiB0aGUgcHJvZHVjdCBJRC5cbiAgICAgKi9cbiAgICBnZXRQaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldmljZS5nZXRJbmZvKCkudXNiUHJvZHVjdElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgcmVjZWl2ZWQgb3Igc2VudCBkYXRhIGZvciB0cmFjaW5nIG91dHB1dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBNZXNzYWdlIHRvIGZvcm1hdCBhcyB0cmFjZSBsaW5lLlxuICAgICAqL1xuICAgIHRyYWNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VHJhY2VUaW1lO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBgVFJBQ0UgJHtkZWx0YS50b0ZpeGVkKDMpfWA7XG4gICAgICAgIGNvbnN0IHRyYWNlTWVzc2FnZSA9IGAke3ByZWZpeH0gJHttZXNzYWdlfWA7XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYWNlTWVzc2FnZSk7XG4gICAgICAgIHRoaXMudHJhY2VMb2cgKz0gdHJhY2VNZXNzYWdlICsgXCJcXG5cIjtcbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuVHJhY2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aGlzLnRyYWNlTG9nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGV4dCBjb3BpZWQgdG8gY2xpcGJvYXJkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvcHkgdGV4dDpcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoZXhpZnkocykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzKVxuICAgICAgICAgICAgLm1hcCgoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKVxuICAgICAgICAgICAgLmpvaW4oXCJcIilcbiAgICAgICAgICAgIC5wYWRFbmQoMTYsIFwiIFwiKTtcbiAgICB9XG4gICAgaGV4Q29udmVydCh1aW50OEFycmF5LCBhdXRvU3BsaXQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChhdXRvU3BsaXQgJiYgdWludDhBcnJheS5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgcyA9IHVpbnQ4QXJyYXk7XG4gICAgICAgICAgICB3aGlsZSAocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHMuc2xpY2UoMCwgMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzY2lpTGluZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubGluZSlcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IChjID09PSBcIiBcIiB8fCAoYyA+PSBcIiBcIiAmJiBjIDw9IFwiflwiICYmIGMgIT09IFwiICBcIikgPyBjIDogXCIuXCIpKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBzID0gcy5zbGljZSgxNik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGBcXG4gICAgJHt0aGlzLmhleGlmeShsaW5lLnNsaWNlKDAsIDgpKX0gJHt0aGlzLmhleGlmeShsaW5lLnNsaWNlKDgpKX0gfCAke2FzY2lpTGluZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhleGlmeSh1aW50OEFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZGF0YSBwYWNrZXQgdXNpbmcgdGhlIFNlcmlhbCBMaW5lIEludGVybmV0IFByb3RvY29sIChTTElQKS5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgQmluYXJ5IHVuc2lnbmVkIDggYml0IGFycmF5IGRhdGEgdG8gZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGb3JtYXR0ZWQgdW5zaWduZWQgOCBiaXQgZGF0YSBhcnJheS5cbiAgICAgKi9cbiAgICBzbGlwV3JpdGVyKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgb3V0RGF0YSA9IFtdO1xuICAgICAgICBvdXREYXRhLnB1c2goMHhjMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT09IDB4ZGIpIHtcbiAgICAgICAgICAgICAgICBvdXREYXRhLnB1c2goMHhkYiwgMHhkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhW2ldID09PSAweGMwKSB7XG4gICAgICAgICAgICAgICAgb3V0RGF0YS5wdXNoKDB4ZGIsIDB4ZGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0RGF0YS5wdXNoKGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dERhdGEucHVzaCgweGMwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBiaW5hcnkgZGF0YSB0byBkZXZpY2UgdXNpbmcgdGhlIFdlYlNlcmlhbCBkZXZpY2Ugd3JpdGFibGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSA4IGJpdCB1bnNpZ25lZCBkYXRhIGFycmF5IHRvIHdyaXRlIHRvIGRldmljZS5cbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IG91dERhdGEgPSB0aGlzLnNsaXBXcml0ZXIoZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRldmljZS53cml0YWJsZSkge1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gdGhpcy5kZXZpY2Uud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcml0ZSBieXRlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKGBXcml0ZSAke291dERhdGEubGVuZ3RofSBieXRlczogJHt0aGlzLmhleENvbnZlcnQob3V0RGF0YSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUob3V0RGF0YSk7XG4gICAgICAgICAgICB3cml0ZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBidWZmZXIgYXJyYXkgYWZ0ZXIgYW5vdGhlciBidWZmZXIgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycjEgLSBGaXJzdCBhcnJheSBidWZmZXIuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIyIC0gbWFnaWMgaGV4IG51bWJlciB0byBzZWxlY3QgUk9NLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBSZXR1cm4gYSA4IGJpdCB1bnNpZ25lZCBhcnJheS5cbiAgICAgKi9cbiAgICBhcHBlbmRBcnJheShhcnIxLCBhcnIyKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoYXJyMS5sZW5ndGggKyBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChhcnIxKTtcbiAgICAgICAgY29tYmluZWQuc2V0KGFycjIsIGFycjEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbiAgICAvLyBBc3luY2hyb25vdXMgZ2VuZXJhdG9yIHRvIHlpZWxkIGluY29taW5nIGRhdGEgY2h1bmtzXG4gICAgYXN5bmMgKnJlYWRMb29wKHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoXCJSZWFkIHRpbWVvdXQgZXhjZWVkZWRcIikpLCB0aW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgLy8gQXdhaXQgdGhlIHJhY2UgYmV0d2VlbiB0aGUgdGltZW91dCBhbmQgdGhlIHJlYWRlciByZWFkXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFt0aGlzLnJlYWRlci5yZWFkKCksIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSB0aW1lb3V0IG9jY3VycywgcmVzdWx0IHdpbGwgYmUgbnVsbDsgb3RoZXJ3aXNlLCBpdCB3aWxsIGhhdmUgeyB2YWx1ZSwgZG9uZSB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChkb25lIHx8ICF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7IC8vIFlpZWxkIGVhY2ggZGF0YSBjaHVua1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlYWRpbmcgZnJvbSBzZXJpYWwgcG9ydDpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWFkIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJ5dGVzXG4gICAgYXN5bmMgbmV3UmVhZChudW1CeXRlcywgdGltZW91dCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID49IG51bUJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmJ1ZmZlci5zbGljZSgwLCBudW1CeXRlcyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKG51bUJ5dGVzKTsgLy8gUmVtb3ZlIHRoZSByZXR1cm5lZCBkYXRhIGZyb20gYnVmZmVyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPCBudW1CeXRlcykge1xuICAgICAgICAgICAgY29uc3QgcmVhZExvb3AgPSB0aGlzLnJlYWRMb29wKHRpbWVvdXQpO1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZExvb3AubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUgfHwgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIG5ld2x5IHJlYWQgZGF0YSB0byB0aGUgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYXBwZW5kQXJyYXkodGhpcy5idWZmZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYXMgbXVjaCBkYXRhIGFzIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuYnVmZmVyLnNsaWNlKDAsIG51bUJ5dGVzKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShudW1CeXRlcyk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoSW5wdXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMucmVhZGVyICYmICEoYXdhaXQgdGhpcy5yZWFkZXIuY2xvc2VkKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSAoX2EgPSB0aGlzLmRldmljZS5yZWFkYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoT3V0cHV0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBhd2FpdCAoKF9hID0gdGhpcy5kZXZpY2Uud3JpdGFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRXcml0ZXIoKS5jbG9zZSgpKTtcbiAgICAgICAgKF9iID0gdGhpcy5kZXZpY2Uud3JpdGFibGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRXcml0ZXIoKS5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgICAvLyBgaW5XYWl0aW5nYCByZXR1cm5zIHRoZSBjb3VudCBvZiBieXRlcyBpbiB0aGUgYnVmZmVyXG4gICAgaW5XYWl0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIGRhdGEgcmVhZCBmcm9tIGRldmljZSBpcyBhIEZhdGFsIG9yIEd1cnUgbWVkaXRhdGlvbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0IERhdGEgcmVhZCBmcm9tIGRldmljZVxuICAgICAqL1xuICAgIGRldGVjdFBhbmljSGFuZGxlcihpbnB1dCkge1xuICAgICAgICBjb25zdCBndXJ1TWVkaXRhdGlvblJlZ2V4ID0gL0c/dXJ1IE1lZGl0YXRpb24gRXJyb3I6ICg/OkNvcmUgXFxkIHBhbmljJ2VkIFxcKChbYS16QS1aIF0qKVxcKSk/LztcbiAgICAgICAgY29uc3QgZmF0YWxFeGNlcHRpb25SZWdleCA9IC9GP2F0YWwgZXhjZXB0aW9uIFxcKFxcZCtcXCk6ICg/OihbYS16QS1aIF0qKT8uKmVwYyk/LztcbiAgICAgICAgY29uc3QgaW5wdXRTdHJpbmcgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoaW5wdXQpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGlucHV0U3RyaW5nLm1hdGNoKGd1cnVNZWRpdGF0aW9uUmVnZXgpIHx8IGlucHV0U3RyaW5nLm1hdGNoKGZhdGFsRXhjZXB0aW9uUmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdXNlID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgR3VydSBNZWRpdGF0aW9uIEVycm9yIGRldGVjdGVkJHtjYXVzZSA/IGAgKCR7Y2F1c2V9KWAgOiBcIlwifWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIGEgZGF0YSBhcnJheSBhbmQgcmV0dXJuIHRoZSBmaXJzdCB3ZWxsIGZvcm1lZCBwYWNrZXQgYWZ0ZXJcbiAgICAgKiByZXBsYWNpbmcgdGhlIGVzY2FwZSBzZXF1ZW5jZS4gUmVhZHMgYXQgbGVhc3QgOCBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaW1lb3V0IHJlYWQgZGF0YS5cbiAgICAgKiBAeWllbGRzIHtVaW50OEFycmF5fSBGb3JtYXR0ZWQgcGFja2V0IHVzaW5nIFNMSVAgZXNjYXBlIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBhc3luYyAqcmVhZCh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSAoX2EgPSB0aGlzLmRldmljZS5yZWFkYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsUGFja2V0ID0gbnVsbDtcbiAgICAgICAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxTbGlwID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB3YWl0aW5nQnl0ZXMgPSB0aGlzLmluV2FpdGluZygpO1xuICAgICAgICAgICAgY29uc3QgcmVhZEJ5dGVzID0gYXdhaXQgdGhpcy5uZXdSZWFkKHdhaXRpbmdCeXRlcyA+IDAgPyB3YWl0aW5nQnl0ZXMgOiAxLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICghcmVhZEJ5dGVzIHx8IHJlYWRCeXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBwYXJ0aWFsUGFja2V0ID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gc3VjY2Vzc2Z1bFNsaXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJTZXJpYWwgZGF0YSBzdHJlYW0gc3RvcHBlZDogUG9zc2libGUgc2VyaWFsIG5vaXNlIG9yIGNvcnJ1cHRpb24uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJObyBzZXJpYWwgZGF0YSByZWNlaXZlZC5cIlxuICAgICAgICAgICAgICAgICAgICA6IGBQYWNrZXQgY29udGVudCB0cmFuc2ZlciBzdG9wcGVkYDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGBSZWFkICR7cmVhZEJ5dGVzLmxlbmd0aH0gYnl0ZXM6ICR7dGhpcy5oZXhDb252ZXJ0KHJlYWRCeXRlcyl9YCk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7IC8vIFRyYWNrIHBvc2l0aW9uIGluIHJlYWRCeXRlc1xuICAgICAgICAgICAgd2hpbGUgKGkgPCByZWFkQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHJlYWRCeXRlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsUGFja2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlID09PSB0aGlzLlNMSVBfRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUGFja2V0ID0gbmV3IFVpbnQ4QXJyYXkoMCk7IC8vIFN0YXJ0IG9mIGEgbmV3IHBhY2tldFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZShgUmVhZCBpbnZhbGlkIGRhdGE6ICR7dGhpcy5oZXhDb252ZXJ0KHJlYWRCeXRlcyl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdEYXRhID0gYXdhaXQgdGhpcy5uZXdSZWFkKHRoaXMuaW5XYWl0aW5nKCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZShgUmVtYWluaW5nIGRhdGEgaW4gc2VyaWFsIGJ1ZmZlcjogJHt0aGlzLmhleENvbnZlcnQocmVtYWluaW5nRGF0YSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGVjdFBhbmljSGFuZGxlcihuZXcgVWludDhBcnJheShbLi4ucmVhZEJ5dGVzLCAuLi4ocmVtYWluaW5nRGF0YSB8fCBbXSldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGVhZCBvZiBwYWNrZXQgKDB4JHtieXRlLnRvU3RyaW5nKDE2KX0pOiBQb3NzaWJsZSBzZXJpYWwgbm9pc2Ugb3IgY29ycnVwdGlvbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGUgPT09IHRoaXMuU0xJUF9FU0NfRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUGFja2V0ID0gdGhpcy5hcHBlbmRBcnJheShwYXJ0aWFsUGFja2V0LCBuZXcgVWludDhBcnJheShbdGhpcy5TTElQX0VORF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChieXRlID09PSB0aGlzLlNMSVBfRVNDX0VTQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFBhY2tldCA9IHRoaXMuYXBwZW5kQXJyYXkocGFydGlhbFBhY2tldCwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuU0xJUF9FU0NdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKGBSZWFkIGludmFsaWQgZGF0YTogJHt0aGlzLmhleENvbnZlcnQocmVhZEJ5dGVzKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGEgPSBhd2FpdCB0aGlzLm5ld1JlYWQodGhpcy5pbldhaXRpbmcoKSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKGBSZW1haW5pbmcgZGF0YSBpbiBzZXJpYWwgYnVmZmVyOiAke3RoaXMuaGV4Q29udmVydChyZW1haW5pbmdEYXRhKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0UGFuaWNIYW5kbGVyKG5ldyBVaW50OEFycmF5KFsuLi5yZWFkQnl0ZXMsIC4uLihyZW1haW5pbmdEYXRhIHx8IFtdKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTTElQIGVzY2FwZSAoMHhkYiwgMHgke2J5dGUudG9TdHJpbmcoMTYpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieXRlID09PSB0aGlzLlNMSVBfRVNDKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieXRlID09PSB0aGlzLlNMSVBfRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoYFJlY2VpdmVkIGZ1bGwgcGFja2V0OiAke3RoaXMuaGV4Q29udmVydChwYXJ0aWFsUGFja2V0KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmFwcGVuZEFycmF5KHRoaXMuYnVmZmVyLCByZWFkQnl0ZXMuc2xpY2UoaSkpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwYXJ0aWFsUGFja2V0O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUGFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2Z1bFNsaXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFBhY2tldCA9IHRoaXMuYXBwZW5kQXJyYXkocGFydGlhbFBhY2tldCwgbmV3IFVpbnQ4QXJyYXkoW2J5dGVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzZXJpYWwgZGV2aWNlIHdpdGhvdXQgc2xpcCBmb3JtYXR0aW5nLlxuICAgICAqIEB5aWVsZHMge1VpbnQ4QXJyYXl9IFRoZSBuZXh0IG51bWJlciBpbiB0aGUgRmlib25hY2NpIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIGFzeW5jICpyYXdSZWFkKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUgfHwgIXZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmF3IFJlYWQgYnl0ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoYFJlYWQgJHt2YWx1ZS5sZW5ndGh9IGJ5dGVzOiAke3RoaXMuaGV4Q29udmVydCh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlOyAvLyBZaWVsZCBlYWNoIGRhdGEgY2h1bmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIGZyb20gc2VyaWFsIHBvcnQ6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgUmVxdWVzdFRvU2VuZCAoUlRTKSBzaWduYWwgdG8gZ2l2ZW4gc3RhdGVcbiAgICAgKiAjIFRydWUgZm9yIEVOPUxPVywgY2hpcCBpbiByZXNldCBhbmQgRmFsc2UgRU49SElHSCwgY2hpcCBvdXQgb2YgcmVzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIEJvb2xlYW4gc3RhdGUgdG8gc2V0IHRoZSBzaWduYWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRSVFMoc3RhdGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXZpY2Uuc2V0U2lnbmFscyh7IHJlcXVlc3RUb1NlbmQ6IHN0YXRlIH0pO1xuICAgICAgICAvLyAjIFdvcmstYXJvdW5kIGZvciBhZGFwdGVycyBvbiBXaW5kb3dzIHVzaW5nIHRoZSB1c2JzZXIuc3lzIGRyaXZlcjpcbiAgICAgICAgLy8gIyBnZW5lcmF0ZSBhIGR1bW15IGNoYW5nZSB0byBEVFIgc28gdGhhdCB0aGUgc2V0LWNvbnRyb2wtbGluZS1zdGF0ZVxuICAgICAgICAvLyAjIHJlcXVlc3QgaXMgc2VudCB3aXRoIHRoZSB1cGRhdGVkIFJUUyBzdGF0ZSBhbmQgdGhlIHNhbWUgRFRSIHN0YXRlXG4gICAgICAgIC8vIFJlZmVyZW5jZWQgdG8gZXNwdG9vbC5weVxuICAgICAgICBhd2FpdCB0aGlzLnNldERUUih0aGlzLl9EVFJfc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBkYXRhVGVybWluYWxSZWFkeSAoRFRTKSBzaWduYWwgdG8gZ2l2ZW4gc3RhdGVcbiAgICAgKiAjIFRydWUgZm9yIElPMD1MT1csIGNoaXAgaW4gcmVzZXQgYW5kIEZhbHNlIElPMD1ISUdIXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSBCb29sZWFuIHN0YXRlIHRvIHNldCB0aGUgc2lnbmFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0RFRSKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX0RUUl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBhd2FpdCB0aGlzLmRldmljZS5zZXRTaWduYWxzKHsgZGF0YVRlcm1pbmFsUmVhZHk6IHN0YXRlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHNlcmlhbCBkZXZpY2UgdXNpbmcgdGhlIFdlYnNlcmlhbCBvcGVuIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmF1ZCBOdW1iZXIgYmF1ZCByYXRlIGZvciBzZXJpYWwgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyAxMTUyMDAuXG4gICAgICogQHBhcmFtIHt0eXBlb2YgaW1wb3J0KFwidzNjLXdlYi1zZXJpYWxcIikuU2VyaWFsT3B0aW9uc30gc2VyaWFsT3B0aW9ucyBTZXJpYWwgT3B0aW9ucyBmb3IgV2ViVVNCIFNlcmlhbFBvcnQgY2xhc3MuXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdChiYXVkID0gMTE1MjAwLCBzZXJpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLmRldmljZS5vcGVuKHtcbiAgICAgICAgICAgIGJhdWRSYXRlOiBiYXVkLFxuICAgICAgICAgICAgZGF0YUJpdHM6IHNlcmlhbE9wdGlvbnMgPT09IG51bGwgfHwgc2VyaWFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VyaWFsT3B0aW9ucy5kYXRhQml0cyxcbiAgICAgICAgICAgIHN0b3BCaXRzOiBzZXJpYWxPcHRpb25zID09PSBudWxsIHx8IHNlcmlhbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcmlhbE9wdGlvbnMuc3RvcEJpdHMsXG4gICAgICAgICAgICBidWZmZXJTaXplOiBzZXJpYWxPcHRpb25zID09PSBudWxsIHx8IHNlcmlhbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcmlhbE9wdGlvbnMuYnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHBhcml0eTogc2VyaWFsT3B0aW9ucyA9PT0gbnVsbCB8fCBzZXJpYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpYWxPcHRpb25zLnBhcml0eSxcbiAgICAgICAgICAgIGZsb3dDb250cm9sOiBzZXJpYWxPcHRpb25zID09PSBudWxsIHx8IHNlcmlhbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcmlhbE9wdGlvbnMuZmxvd0NvbnRyb2wsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdWRyYXRlID0gYmF1ZDtcbiAgICAgICAgdGhpcy5yZWFkZXIgPSAoX2EgPSB0aGlzLmRldmljZS5yZWFkYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICAgIH1cbiAgICBhc3luYyBzbGVlcChtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYSBnaXZlbiB0aW1lb3V0IG1zIGZvciBzZXJpYWwgZGV2aWNlIHVubG9jay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaW1lb3V0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChtcykgdG8gc2xlZXBcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yVW5sb2NrKHRpbWVvdXQpIHtcbiAgICAgICAgd2hpbGUgKCh0aGlzLmRldmljZS5yZWFkYWJsZSAmJiB0aGlzLmRldmljZS5yZWFkYWJsZS5sb2NrZWQpIHx8XG4gICAgICAgICAgICAodGhpcy5kZXZpY2Uud3JpdGFibGUgJiYgdGhpcy5kZXZpY2Uud3JpdGFibGUubG9ja2VkKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zbGVlcCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gc2VyaWFsIGRldmljZSBieSBydW5uaW5nIFNlcmlhbFBvcnQuY2xvc2UoKSBhZnRlciBzdHJlYW1zIHVubG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5kZXZpY2UucmVhZGFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NrZWQpIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSB0aGlzLnJlYWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbmNlbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JVbmxvY2soNDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXZpY2UuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IHsgVHJhbnNwb3J0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/esptool-js/lib/webserial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32.json ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1074521580,"text":"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","text_start":1074520064,"data":"DMD8P+znC0B/6AtAZ+0LQAbpC0Cf6AtABukLQGXpC0CC6gtA9OoLQJ3qC0CV5wtAGuoLQHTqC0CI6QtAGOsLQLDpC0AY6wtAbegLQMroC0AG6QtAZekLQIXoC0DI6wtAKe0LQLjmC0BL7QtAuOYLQLjmC0C45gtAuOYLQLjmC0C45gtAuOYLQLjmC0Bv6wtAuOYLQEnsC0Ap7QtA","data_start":1073605544,"bss_start":1073528832}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c2.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c2.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1077413304,"text":"ARG3BwBgTsaDqYcASsg3Sco/JspSxAbOIsy3BABgfVoTCQkAwEwTdPQ/DeDyQGJEI6g0AUJJ0kSySSJKBWGCgIhAgycJABN19Q+Cl30U4xlE/8m/EwcADJRBqodjGOUAhUeFxiOgBQB5VYKABUdjh+YACUZjjcYAfVWCgEIFEwewDUGFY5XnAolHnMH1t5MGwA1jFtUAmMETBQAMgoCTBtANfVVjldcAmMETBbANgoC3dcs/QRGThQW6BsZhP2NFBQa3d8s/k4eHsQOnBwgD1kcIE3X1D5MGFgDCBsGCI5LXCDKXIwCnAAPXRwiRZ5OHBwRjHvcCN/fKPxMHh7GhZ7qXA6YHCLc2yz+3d8s/k4eHsZOGhrVjH+YAI6bHCCOg1wgjkgcIIaD5V+MG9fyyQEEBgoAjptcII6DnCN23NycAYHxLnYv1/zc3AGB8S52L9f+CgEERBsbdN7cnAGAjpgcCNwcACJjDmEN9/8hXskATRfX/BYlBAYKAQREGxtk/fd03BwBAtycAYJjDNycAYBxD/f+yQEEBgoBBESLEN8TKP5MHxABKwAOpBwEGxibCYwoJBEU3OcW9RxMExACBRGPWJwEERL2Ik7QUAH03hT8cRDcGgAATl8cAmeA3BgABt/b/AHWPtyYAYNjCkMKYQn3/QUeR4AVHMwnpQLqXIygkARzEskAiRJJEAklBAYKAQREGxhMHAAxjEOUCEwWwDZcAyP/ngIDjEwXADbJAQQEXA8j/ZwCD4hMHsA3jGOX+lwDI/+eAgOETBdANxbdBESLEJsIGxiqEswS1AGMXlACyQCJEkkRBAYKAA0UEAAUERTfttxMFAAwXA8j/ZwAD3nVxJsPO3v10hWn9cpOEhPqThwkHIsVKwdLc1tqmlwbHFpGzhCcAKokmhS6ElzDI/+eAgJOThwkHBWqKl7OKR0Ep5AVnfXUTBIX5kwcHB6KXM4QnABMFhfqTBwcHqpeihTOFJwCXMMj/54CAkCKFwUW5PwFFhWIWkbpAKkSaRApJ9llmWtZaSWGCgKKJY3OKAIVpTobWhUqFlwDI/+eAQOITdfUPAe1OhtaFJoWXMMj/54DAi06ZMwQ0QVm3EwUwBlW/cXH9ck7PUs1Wy17HBtci1SbTStFayWLFZsNqwe7eqokWkRMFAAIuirKKtosCwpcAyP/ngEBIhWdj7FcRhWR9dBMEhPqThwQHopczhCcAIoWXMMj/54AghX17Eww7+ZMMi/kThwQHk4cEB2KX5pcBSTMMJwCzjCcAEk1je00JY3GpA3mgfTWmhYgYSTVdNSaGjBgihZcwyP/ngCCBppkmmWN1SQOzB6lBY/F3A7MEKkFj85oA1oQmhowYToWXAMj/54Dg0xN19Q9V3QLEgUR5XY1NowEBAGKFlwDI/+eAYMR9+QNFMQDmhS0xY04FAOPinf6FZ5OHBweml4qX2pcjiqf4hQT5t+MWpf2RR+OG9PYFZ311kwcHBxMEhfmilzOEJwATBYX6kwcHB6qXM4UnAKKFlyDI/+eAgHflOyKFwUXxM8U7EwUAApcAyP/ngOA2hWIWkbpQKlSaVApZ+klqStpKSku6SypMmkwKTfZdTWGCgAERBs4izFExNwTOP2wAEwVE/5cAyP/ngKDKqocFRZXnskeT9wcgPsZ5OTcnAGAcR7cGQAATBUT/1Y8cx7JFlwDI/+eAIMgzNaAA8kBiRAVhgoBBEbfHyj8GxpOHxwAFRyOA5wAT18UAmMcFZ30XzMPIx/mNOpWqlbGBjMsjqgcAQTcZwRMFUAyyQEEBgoABESLMN8TKP5MHxAAmysRHTsYGzkrIqokTBMQAY/OVAK6EqcADKUQAJpkTWckAHEhjVfAAHERjXvkC4T593UhAJobOhZcAyP/ngCC7E3X1DwHFkwdADFzIXECml1zAXESFj1zE8kBiRNJEQkmySQVhgoDdNm2/t1dBSRlxk4f3hAFFPs6G3qLcptrK2M7W0tTW0trQ3s7izObK6sjuxpcAyP/ngICtt0fKPzd3yz+ThwcAEweHumPg5xSlOZFFaAixMYU5t/fKP5OHh7EhZz6XIyD3CLcFOEC3BzhAAUaThwcLk4UFADdJyj8VRSMg+QCXAMj/54DgGzcHAGBcRxMFAAK3xMo/k+cXEFzHlwDI/+eAoBq3RwBgiF+BRbd5yz9xiWEVEzUVAJcAyP/ngOCwwWf9FxMHABCFZkFmtwUAAQFFk4TEALdKyj8NapcAyP/ngOCrk4mJsRMJCQATi8oAJpqDp8kI9d+Dq8kIhUcjpgkIIwLxAoPHGwAJRyMT4QKjAvECAtRNR2OL5wZRR2OJ5wYpR2Of5wCDxzsAA8crAKIH2Y8RR2OW5wCDp4sAnEM+1EE2oUVIEJE+g8c7AAPHKwCiB9mPEWdBB2N+9wITBbANlwDI/+eAQJQTBcANlwDI/+eAgJMTBeAOlwDI/+eAwJKBNr23I6AHAJEHbb3JRyMT8QJ9twPHGwDRRmPn5gKFRmPm5gABTBME8A+dqHkXE3f3D8lG4+jm/rd2yz8KB5OGxro2lxhDAoeTBgcDk/b2DxFG42nW/BMH9wITd/cPjUZj7uYIt3bLPwoHk4aGvzaXGEMChxMHQAJjmucQAtQdRAFFlwDI/+eAIIoBRYE8TTxFPKFFSBB9FEk0ffABTAFEE3X0DyU8E3X8Dw08UTzjEQTsg8cbAElHY2X3MAlH43n36vUXk/f3Dz1H42P36jd3yz+KBxMHh8C6l5xDgocFRJ3rcBCBRQFFlwDI/+eAQIkd4dFFaBAVNAFEMagFRIHvlwDI/+eAwI0zNKAAKaAhR2OF5wAFRAFMYbcDrIsAA6TLALNnjADSB/X3mTll9cFsIpz9HH19MwWMQF3cs3eVAZXjwWwzBYxAY+aMAv18MwWMQF3QMYGXAMj/54Bgil35ZpT1tzGBlwDI/+eAYIld8WqU0bdBgZcAyP/ngKCIWfkzBJRBwbchR+OK5/ABTBMEAAw5t0FHzb9BRwVE453n9oOlywADpYsAVTK5v0FHBUTjk+f2A6cLAZFnY+jnHoOlSwEDpYsAMTGBt0FHBUTjlOf0g6cLARFnY2n3HAOnywCDpUsBA6WLADOE5wLdNiOsBAAjJIqwCb8DxwQAYwMHFAOniwDBFxMEAAxjE/cAwEgBR5MG8A5jRvcCg8dbAAPHSwABTKIH2Y8Dx2sAQgddj4PHewDiB9mP44T25hMEEAyFtTOG6wADRoYBBQexjuG3g8cEAP3H3ERjnQcUwEgjgAQAVb1hR2OW5wKDp8sBA6eLAYOmSwEDpgsBg6XLAAOliwCX8Mf/54BgeSqMMzSgAAG9AUwFRCm1EUcFROOd5+a3lwBgtENld30XBWb5jtGOA6WLALTDtEeBRfmO0Y60x/RD+Y7RjvTD1F91j1GP2N+X8Mf/54BAdwW1E/f3AOMXB+qT3EcAE4SLAAFMfV3jd5zbSESX8Mf/54DAYRhEVEAQQPmOYwenARxCE0f3/32P2Y4UwgUMQQTZvxFHtbVBRwVE45rn3oOniwADp0sBIyT5ACMi6QDJs4MlSQDBF5Hlic8BTBMEYAyhuwMniQBjZvcGE/c3AOMbB+IDKIkAAUYBRzMF6ECzhuUAY2n3AOMHBtIjJKkAIyLZAA2zM4brABBOEQeQwgVG6b8hRwVE45Tn2AMkiQAZwBMEgAwjJAkAIyIJADM0gAC9swFMEwQgDMW5AUwTBIAM5bEBTBMEkAzFsRMHIA1jg+cMEwdADeOR57oDxDsAg8crACIEXYyX8Mf/54BgXwOsxABBFGNzhAEijOMPDLbAQGKUMYCcSGNV8ACcRGNa9Arv8I/hdd3IQGKGk4WLAZfwx//ngGBbAcWTB0AM3MjcQOKX3MDcRLOHh0HcxJfwx//ngEBaFb4JZRMFBXEDrMsAA6SLAJfwx//ngEBMtwcAYNhLtwYAAcEWk1dHARIHdY+9i9mPs4eHAwFFs9WHApfwx//ngOBMEwWAPpfwx//ngOBI3bSDpksBA6YLAYOlywADpYsA7/Av98G8g8U7AIPHKwAThYsBogXdjcEVqTptvO/w79qBtwPEOwCDxysAE4yLASIEXYzcREEUxeORR4VLY/6HCJMHkAzcyHm0A6cNACLQBUizh+xAPtaDJ4qwY3P0AA1IQsY6xO/wb9YiRzJIN8XKP+KFfBCThsoAEBATBUUCl/DH/+eA4Ek398o/kwjHAIJXA6eIsIOlDQAdjB2PPpyyVyOk6LCqi76VI6C9AJOHygCdjQHFoWdjlvUAWoVdOCOgbQEJxNxEmcPjQHD5Y98LAJMHcAyFv4VLt33LP7fMyj+TjY26k4zMAOm/45ULntxE44IHnpMHgAyxt4OniwDjmwecAUWX8Mf/54DAOQllEwUFcZfwx//ngCA2l/DH/+eA4DlNugOkywDjBgSaAUWX8Mf/54AgNxMFgD6X8Mf/54CgMwKUQbr2UGZU1lRGWbZZJlqWWgZb9ktmTNZMRk22TQlhgoA=","text_start":1077411840,"data":"DEDKP+AIOEAsCThAhAk4QFIKOEC+CjhAbAo4QKgHOEAOCjhATgo4QJgJOEBYBzhAzAk4QFgHOEC6CDhA/gg4QCwJOECECThAzAg4QBIIOEBCCDhAyAg4QBYNOEAsCThA1gs4QMoMOECkBjhA9Aw4QKQGOECkBjhApAY4QKQGOECkBjhApAY4QKQGOECkBjhAcgs4QKQGOEDyCzhAygw4QA==","data_start":1070295976,"bss_start":1070219264}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c3.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c3.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1077413584,"text":"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","text_start":1077411840,"data":"GEDIP8AKOEAQCzhAaAs4QDYMOECiDDhAUAw4QHIJOEDyCzhAMgw4QHwLOEAiCThAsAs4QCIJOECaCjhA4Ao4QBALOEBoCzhArAo4QNYJOEAgCjhAqAo4QPoOOEAQCzhAug04QLIOOEBiCDhA2g44QGIIOEBiCDhAYgg4QGIIOEBiCDhAYgg4QGIIOEBiCDhAVg04QGIIOEDYDThAsg44QA==","data_start":1070164916,"bss_start":1070088192}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c5.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c5.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1082132164,"text":"QREixCbCBsa39wBgEUc3BIRA2Mu39ABgEwQEANxAkYuR57JAIkSSREEBgoCIQBxAE3X1D4KX3bcBEbcHAGBOxoOphwBKyDcJhEAmylLEBs4izLcEAGB9WhMJCQDATBN09D8N4PJAYkQjqDQBQknSRLJJIkoFYYKAiECDJwkAE3X1D4KXfRTjGUT/yb8TBwAMlEGqh2MY5QCFR4XGI6AFAHlVgoAFR2OH5gAJRmONxgB9VYKAQgUTB7ANQYVjlecCiUecwfW3kwbADWMW1QCYwRMFAAyCgJMG0A19VWOV1wCYwRMFsA2CgLc1hUBBEZOFhboGxmE/Y0UFBrc3hUCThweyA6cHCAPWRwgTdfUPkwYWAMIGwYIjktcIMpcjAKcAA9dHCJFnk4cHBGMe9wI3t4RAEwcHsqFnupcDpgcIt/aEQLc3hUCThweyk4YGtmMf5gAjpscII6DXCCOSBwghoPlX4wb1/LJAQQGCgCOm1wgjoOcI3bc3NwBgfEudi/X/NycAYHxLnYv1/4KAQREGxt03tzcAYCOmBwI3BwAImMOYQ33/yFeyQBNF9f8FiUEBgoBBEQbG2T993TcHAEC3NwBgmMM3NwBgHEP9/7JAQQGCgEERIsQ3hIRAkwdEAUrAA6kHAQbGJsJjCgkERTc5xb1HEwREAYFEY9YnAQREvYiTtBQAfTeFPxxENwaAABOXxwCZ4DcGAAG39v8AdY+3NgBg2MKQwphCff9BR5HgBUczCelAupcjKCQBHMSyQCJEkkQCSUEBgoABEQbOIswlNzcEhkBsABMFBP+XAID/54Cg86qHBUWV57JHk/cHID7GiTc3NwBgHEe3BkAAEwUE/9WPHMeyRZcAgP/ngCDxMzWgAPJAYkQFYYKAQRG3h4RABsaTh0cBBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgYzLI6oHAEE3GcETBVAMskBBAYKAAREizDeEhECTB0QBJsrER07GBs5KyKqJEwREAWPzlQCuhKnAAylEACaZE1nJABxIY1XwABxEY175ArU9fd1IQCaGzoWXAID/54Ag5BN19Q8BxZMHQAxcyFxAppdcwFxEhY9cxPJAYkTSREJJskkFYYKAaTVtv0ERBsaXAID/54CA1gNFhQGyQHUVEzUVAEEBgoBBEQbGxTcNxbcHhECThwcA1EOZzjdnCWATB8cQHEM3Bv3/fRbxjzcGAwDxjtWPHMOyQEEBgoBBEQbGbTcRwQ1FskBBARcDgP9nAIPMQREGxibCIsSqhJcAgP/ngKDJWTcNyTcHhECTBgcAg9eGABMEBwCFB8IHwYMjlPYAkwYADGOG1AATB+ADY3X3AG03IxQEALJAIkSSREEBgoBBEQbGEwcADGMa5QATBbANRTcTBcANskBBAVm/EwewDeMb5f5xNxMF0A31t0ERIsQmwgbGKoSzBLUAYxeUALJAIkSSREEBgoADRQQABQRNP+23NXEmy07H/XKFaf10Is1KyVLFVsMGz5OEhPoWkZOHCQemlxgIs4TnACqJJoUuhJcAgP/ngEAxk4cJBxgIBWq6l7OKR0Ex5AVnfXWTBYX6kwcHBxMFhfkUCKqXM4XXAJMHBweul7OF1wAqxpcAgP/ngAAuMkXBRZU3AUWFYhaR+kBqRNpESkm6SSpKmkoNYYKAooljc4oAhWlOhtaFSoWXAID/54DAxhN19Q8B7U6G1oUmhZcAgP/ngEApTpkzBDRBUbcTBTAGVb8TBQAMSb0xcf1yBWdO11LVVtNezwbfIt0m20rZWtFizWbLaslux/13FpETBwcHPpccCLqXPsYjqgf4qokuirKKtov1M5MHAAIZwbcHAgA+hZcAgP/ngCAghWdj5VcTBWR9eRMJifqTBwQHypcYCDOJ5wBKhZcAgP/ngGAgfXsTDDv5kwyL+RMHBAeTBwQHFAhil+aXgUQzDNcAs4zXAFJNY3xNCWPxpANBqJk/ooUIAY01uTcihgwBSoWXAID/54BAHKKZopRj9UQDs4ekQWPxdwMzBJpAY/OKAFaEIoYMAU6FlwCA/+eAALYTdfUPVd0CzAFEeV2NTaMJAQBihZcAgP/ngECkffkDRTEB5oWFNGNPBQDj4o3+hWeThwcHopcYCLqX2pcjiqf4BQTxt+MVpf2RR+MF9PYFZ311kwcHB5MFhfoTBYX5FAiqlzOF1wCTBwcHrpezhdcAKsaXAID/54BgEnE9MkXBRWUzUT3BMbcHAgAZ4ZMHAAI+hZcAgP/ngKANhWIWkfpQalTaVEpZulkqWppaClv6S2pM2kxKTbpNKWGCgLdXQUkZcZOH94QBRYbeotym2srYztbS1NbS2tDezuLM5srqyO7GPs6XAID/54DAnaE5Ec23Zwlgk4fHEJhDtwaEQCOi5gC3BgMAVY+Ywy05Bc23JwtgN0fYUJOGh8ETBxeqmMIThgfAIyAGACOgBgCThgfCmMKTh8fBmEM3BgQAUY+YwyOgBgC3B4RANzeFQJOHBwATBwe7IaAjoAcAkQfj7ef+XTuRRWgIyTF9M7e3hECThweyIWc+lyMg9wi3B4BANwmEQJOHhw4jIPkAtzmFQF0+EwkJAJOJCbJjBgUQtwcBYBMHEAIjqOcMhUVFRZcAgP/ngAD5twWAQAFGk4UFAEVFlwCA/+eAQPq39wBgEUeYyzcFAgCXAID/54CA+bcXCWCIX4FFt4SEQHGJYRUTNRUAlwCA/+eAgJ/BZ/0XEwcAEIVmQWa3BQABAUWThEQBtwqEQA1qlwCA/+eAQJUTi0oBJpqDp8kI9d+Dq8kIhUcjpgkIIwLxAoPHGwAJRyMT4QKjAvECAtRNR2OB5whRR2OP5wYpR2Of5wCDxzsAA8crAKIH2Y8RR2OW5wCDp4sAnEM+1FUxoUVIEEU+g8c7AAPHKwCiB9mPEWdBB2N09wQTBbANKT4TBcANET4TBeAOOTadOUG3twWAQAFGk4WFAxVFlwCA/+eAQOs3BwBgXEcTBQACk+cXEFzHMbfJRyMT8QJNtwPHGwDRRmPn5gKFRmPm5gABTBME8A+FqHkXE3f3D8lG4+jm/rc2hUAKB5OGRrs2lxhDAoeTBgcDk/b2DxFG42nW/BMH9wITd/cPjUZj6+YItzaFQAoHk4YGwDaXGEMChxMHQAJjmOcQAtQdRAFFtTQBRWU8wT75NqFFSBB9FOE8dfQBTAFEE3X0D0U0E3X8D2k8TT7jHgTqg8cbAElHY2j3MAlH43b36vUXk/f3Dz1H42D36jc3hUCKBxMHB8G6l5xDgocFRJ3rcBCBRQFFl/B//+eAgHEd4dFFaBCtPAFEMagFRIHvl/B//+eAQHczNKAAKaAhR2OF5wAFRAFMYbcDrIsAA6TLALNnjADSB/X37/D/hX3xwWwinP0cfX0zBYxAVdyzd5UBlePBbDMFjEBj5owC/XwzBYxAVdAxgZfwf//ngMBzVflmlPW3MYGX8H//54DAclXxapTRt0GBl/B//+eAAHJR+TMElEHBtyFH44nn8AFMEwQADDG3QUfNv0FHBUTjnOf2g6XLAAOliwD1MrG/QUcFROOS5/YDpwsBkWdj6uceg6VLAQOliwDv8D+BNb9BRwVE45Ln9IOnCwERZ2Nq9xwDp8sAg6VLAQOliwAzhOcC7/Cv/iOsBAAjJIqwMbcDxwQAYwMHFAOniwDBFxMEAAxjE/cAwEgBR5MG8A5jRvcCg8dbAAPHSwABTKIH2Y8Dx2sAQgddj4PHewDiB9mP44H25hMEEAypvTOG6wADRoYBBQexjuG3g8cEAP3H3ERjnQcUwEgjgAQAfbVhR2OW5wKDp8sBA6eLAYOmSwEDpgsBg6XLAAOliwCX8H//54CAYiqMMzSgACm1AUwFRBG1EUcFROOa5+a3lwBgtF9ld30XBWb5jtGOA6WLALTftFeBRfmO0Y601/Rf+Y7RjvTf9FN1j1GP+NOX8H//54CgZSm9E/f3AOMVB+qT3EcAE4SLAAFMfV3jdJzbSESX8H//54AgSBhEVEAQQPmOYwenARxCE0f3/32P2Y4UwgUMQQTZvxFHpbVBRwVE45fn3oOniwADp0sBIyj5ACMm6QB1u4MlyQDBF5Hlic8BTBMEYAyJuwMnCQFjZvcGE/c3AOMZB+IDKAkBAUYBRzMF6ECzhuUAY2n3AOMEBtIjKKkAIybZADG7M4brABBOEQeQwgVG6b8hRwVE45Hn2AMkCQEZwBMEgAwjKAkAIyYJADM0gAClswFMEwQgDO2xAUwTBIAMzbEBTBMEkAzpuRMHIA1jg+cMEwdADeOb57gDxDsAg8crACIEXYyX8H//54CASAOsxABBFGNzhAEijOMJDLbAQGKUMYCcSGNV8ACcRGNb9Arv8O/Ldd3IQGKGk4WLAZfwf//ngIBEAcWTB0AM3MjcQOKX3MDcRLOHh0HcxJfwf//ngGBDJbYJZRMFBXEDrMsAA6SLAJfwf//ngKAytwcAYNhLtwYAAcEWk1dHARIHdY+9i9mPs4eHAwFFs9WHApfwf//ngAA0EwWAPpfwf//ngEAv6byDpksBA6YLAYOlywADpYsA7/Av/NG0g8U7AIPHKwAThYsBogXdjcEV7/DP1XW07/AvxT2/A8Q7AIPHKwATjIsBIgRdjNxEQRTN45FHhUtj/4cIkweQDNzIQbQDpw0AItAFSLOH7EA+1oMnirBjc/QADUhCxjrE7/CvwCJHMkg3hYRA4oV8EJOGSgEQEBMFxQKX8H//54CgMTe3hECTCEcBglcDp4iwg6UNAB2MHY8+nLJXI6TosKqLvpUjoL0Ak4dKAZ2NAcWhZ2OX9QBahe/wb8sjoG0BCcTcRJnD409w92PfCwCTB3AMvbeFS7c9hUC3jIRAk40Nu5OMTAHpv+OdC5zcROOKB5yTB4AMqbeDp4sA45MHnO/wb9MJZRMFBXGX8H//54CgHO/w786X8H//54BgIVWyA6TLAOMPBJjv8O/QEwWAPpfwf//ngEAa7/CPzAKUUbLv8A/M9lBmVNZURlm2WSZalloGW/ZLZkzWTEZNtk0JYYKAAAA=","text_start":1082130432,"data":"FACEQG4KgEC+CoBAFguAQOQLgEBQDIBA/guAQDoJgECgC4BA4AuAQCoLgEDqCIBAXguAQOoIgEBICoBAjgqAQL4KgEAWC4BAWgqAQJ4JgEDOCYBAVgqAQKgOgEC+CoBAaA2AQGAOgEAqCIBAiA6AQCoIgEAqCIBAKgiAQCoIgEAqCIBAKgiAQCoIgEAqCIBABA2AQCoIgECGDYBAYA6AQA==","data_start":1082469296,"bss_start":1082392576}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c6.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c6.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1082132164,"text":"QREixCbCBsa39wBgEUc3BIRA2Mu39ABgEwQEANxAkYuR57JAIkSSREEBgoCIQBxAE3X1D4KX3bcBEbcHAGBOxoOphwBKyDcJhEAmylLEBs4izLcEAGB9WhMJCQDATBN09A8N4PJAYkQjqDQBQknSRLJJIkoFYYKAiECDJwkAE3X1D4KXfRTjGUT/yb8TBwAMlEGqh2MY5QCFR4XGI6AFAHlVgoAFR2OH5gAJRmONxgB9VYKAQgUTB7ANQYVjlecCiUecwfW3kwbADWMW1QCYwRMFAAyCgJMG0A19VWOV1wCYwRMFsA2CgLc1hUBBEZOFhboGxmE/Y0UFBrc3hUCThweyA6cHCAPWRwgTdfUPkwYWAMIGwYIjktcIMpcjAKcAA9dHCJFnk4cHBGMe9wI3t4RAEwcHsqFnupcDpgcIt/aEQLc3hUCThweyk4YGtmMf5gAjpscII6DXCCOSBwghoPlX4wb1/LJAQQGCgCOm1wgjoOcI3bc3NwBgfEudi/X/NycAYHxLnYv1/4KAQREGxt03tzcAYCOmBwI3BwAImMOYQ33/yFeyQBNF9f8FiUEBgoBBEQbG2T993TcHAEC3NwBgmMM3NwBgHEP9/7JAQQGCgEERIsQ3hIRAkwdEAUrAA6kHAQbGJsJjCgkERTc5xb1HEwREAYFEY9YnAQREvYiTtBQAfTeFPxxENwaAABOXxwCZ4DcGAAG39v8AdY+3NgBg2MKQwphCff9BR5HgBUczCelAupcjKCQBHMSyQCJEkkQCSUEBgoABEQbOIswlNzcEzj9sABMFRP+XAID/54Cg8qqHBUWV57JHk/cHID7GiTc3NwBgHEe3BkAAEwVE/9WPHMeyRZcAgP/ngCDwMzWgAPJAYkQFYYKAQRG3h4RABsaTh0cBBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgYzLI6oHAEE3GcETBVAMskBBAYKAAREizDeEhECTB0QBJsrER07GBs5KyKqJEwREAWPzlQCuhKnAAylEACaZE1nJABxIY1XwABxEY175ArU9fd1IQCaGzoWXAID/54Ag4xN19Q8BxZMHQAxcyFxAppdcwFxEhY9cxPJAYkTSREJJskkFYYKAaTVtv0ERBsaXAID/54BA1gNFhQGyQHUVEzUVAEEBgoBBEQbGxTcNxbcHhECThwcA1EOZzjdnCWATBwcRHEM3Bv3/fRbxjzcGAwDxjtWPHMOyQEEBgoBBEQbGbTcRwQ1FskBBARcDgP9nAIPMQREGxibCIsSqhJcAgP/ngODJWTcNyTcHhECTBgcAg9eGABMEBwCFB8IHwYMjlPYAkwYADGOG1AATB+ADY3X3AG03IxQEALJAIkSSREEBgoBBEQbGEwcADGMa5QATBbANRTcTBcANskBBAVm/EwewDeMb5f5xNxMF0A31t0ERIsQmwgbGKoSzBLUAYxeUALJAIkSSREEBgoADRQQABQRNP+23NXEmy07H/XKFaf10Is1KyVLFVsMGz5OEhPoWkZOHCQemlxgIs4TnACqJJoUuhJcAgP/ngIAsk4cJBxgIBWq6l7OKR0Ex5AVnfXWTBYX6kwcHBxMFhfkUCKqXM4XXAJMHBweul7OF1wAqxpcAgP/ngEApMkXBRZU3AUWFYhaR+kBqRNpESkm6SSpKmkoNYYKAooljc4oAhWlOhtaFSoWXAID/54DAxRN19Q8B7U6G1oUmhZcAgP/ngIAkTpkzBDRBUbcTBTAGVb8TBQAMSb0xcf1yBWdO11LVVtNezwbfIt0m20rZWtFizWbLaslux/13FpETBwcHPpccCLqXPsYjqgf4qokuirKKtov1M5MHAAIZwbcHAgA+hZcAgP/ngCAdhWdj5VcTBWR9eRMJifqTBwQHypcYCDOJ5wBKhZcAgP/ngKAbfXsTDDv5kwyL+RMHBAeTBwQHFAhil+aXgUQzDNcAs4zXAFJNY3xNCWPxpANBqJk/ooUIAY01uTcihgwBSoWXAID/54CAF6KZopRj9UQDs4ekQWPxdwMzBJpAY/OKAFaEIoYMAU6FlwCA/+eAALUTdfUPVd0CzAFEeV2NTaMJAQBihZcAgP/ngECkffkDRTEB5oWFNGNPBQDj4o3+hWeThwcHopcYCLqX2pcjiqf4BQTxt+MVpf2RR+MF9PYFZ311kwcHB5MFhfoTBYX5FAiqlzOF1wCTBwcHrpezhdcAKsaXAID/54CgDXE9MkXBRWUzUT3BMbcHAgAZ4ZMHAAI+hZcAgP/ngKAKhWIWkfpQalTaVEpZulkqWppaClv6S2pM2kxKTbpNKWGCgLdXQUkZcZOH94QBRYbeotym2srYztbS1NbS2tDezuLM5srqyO7GPs6XAID/54CAnaE5DcE3ZwlgEwcHERxDtwaEQCOi9gC3Bv3//Rb1j8Fm1Y8cwxU5Bc23JwtgN0fYUJOGh8ETBxeqmMIThgfAIyAGACOgBgCThgfCmMKTh8fBmEM3BgQAUY+YwyOgBgC3B4RANzeFQJOHBwATBwe7IaAjoAcAkQfj7ef+RTuRRWgIdTllM7e3hECThweyIWc+lyMg9wi3B4BANwmEQJOHhw4jIPkAtzmFQEU+EwkJAJOJCbJjBQUQtwcBYEVHI6DnDIVFRUWXAID/54AA9rcFgEABRpOFBQBFRZcAgP/ngAD3t/cAYBFHmMs3BQIAlwCA/+eAQPa3FwlgiF+BRbeEhEBxiWEVEzUVAJcAgP/ngACewWf9FxMHABCFZkFmtwUAAQFFk4REAbcKhEANapcAgP/ngACUE4tKASaag6fJCPXfg6vJCIVHI6YJCCMC8QKDxxsACUcjE+ECowLxAgLUTUdjgecIUUdjj+cGKUdjn+cAg8c7AAPHKwCiB9mPEUdjlucAg6eLAJxDPtRFMaFFSBB1NoPHOwADxysAogfZjxFnQQdjdPcEEwWwDRk+EwXADQE+EwXgDik2jTlBt7cFgEABRpOFhQMVRZcAgP/ngADoNwcAYFxHEwUAApPnFxBcxzG3yUcjE/ECTbcDxxsA0UZj5+YChUZj5uYAAUwTBPAPhah5FxN39w/JRuPo5v63NoVACgeThka7NpcYQwKHkwYHA5P29g8RRuNp1vwTB/cCE3f3D41GY+vmCLc2hUAKB5OGBsA2lxhDAocTB0ACY5jnEALUHUQBRaU0AUVVPPE26TahRUgQfRTRPHX0AUwBRBN19A9xPBN1/A9ZPH024x4E6oPHGwBJR2No9zAJR+N29+r1F5P39w89R+Ng9+o3N4VAigcTBwfBupecQ4KHBUSd63AQgUUBRZfwf//ngABxHeHRRWgQnTwBRDGoBUSB75fwf//ngAB2MzSgACmgIUdjhecABUQBTGG3A6yLAAOkywCzZ4wA0gf19+/wv4V98cFsIpz9HH19MwWMQFXcs3eVAZXjwWwzBYxAY+aMAv18MwWMQFXQMYGX8H//54CAclX5ZpT1tzGBl/B//+eAgHFV8WqU0bdBgZfwf//ngMBwUfkzBJRBwbchR+OJ5/ABTBMEAAwxt0FHzb9BRwVE45zn9oOlywADpYsA5TKxv0FHBUTjkuf2A6cLAZFnY+rnHoOlSwEDpYsA7/D/gDW/QUcFROOS5/SDpwsBEWdjavccA6fLAIOlSwEDpYsAM4TnAu/wb/4jrAQAIySKsDG3A8cEAGMDBxQDp4sAwRcTBAAMYxP3AMBIAUeTBvAOY0b3AoPHWwADx0sAAUyiB9mPA8drAEIHXY+Dx3sA4gfZj+OB9uYTBBAMqb0zhusAA0aGAQUHsY7ht4PHBAD9x9xEY50HFMBII4AEAH21YUdjlucCg6fLAQOniwGDpksBA6YLAYOlywADpYsAl/B//+eAQGEqjDM0oAAptQFMBUQRtRFHBUTjmufmt5cAYLRfZXd9FwVm+Y7RjgOliwC037RXgUX5jtGOtNf0X/mO0Y703/RTdY9Rj/jTl/B//+eAIGQpvRP39wDjFQfqk9xHABOEiwABTH1d43Sc20hEl/B//+eAIEgYRFRAEED5jmMHpwEcQhNH9/99j9mOFMIFDEEE2b8RR6W1QUcFROOX596Dp4sAA6dLASMo+QAjJukAdbuDJckAwReR5YnPAUwTBGAMibsDJwkBY2b3BhP3NwDjGQfiAygJAQFGAUczBehAs4blAGNp9wDjBAbSIyipACMm2QAxuzOG6wAQThEHkMIFRum/IUcFROOR59gDJAkBGcATBIAMIygJACMmCQAzNIAApbMBTBMEIAztsQFMEwSADM2xAUwTBJAM6bkTByANY4PnDBMHQA3jm+e4A8Q7AIPHKwAiBF2Ml/B//+eAQEcDrMQAQRRjc4QBIozjCQy2wEBilDGAnEhjVfAAnERjW/QK7/Cvy3XdyEBihpOFiwGX8H//54BAQwHFkwdADNzI3EDil9zA3ESzh4dB3MSX8H//54AgQiW2CWUTBQVxA6zLAAOkiwCX8H//54CgMrcHAGDYS7cGAAHBFpNXRwESB3WPvYvZj7OHhwMBRbPVhwKX8H//54DAMxMFgD6X8H//54BAL+m8g6ZLAQOmCwGDpcsAA6WLAO/w7/vRtIPFOwCDxysAE4WLAaIF3Y3BFe/wj9V1tO/w78Q9vwPEOwCDxysAE4yLASIEXYzcREEUzeORR4VLY/+HCJMHkAzcyEG0A6cNACLQBUizh+xAPtaDJ4qwY3P0AA1IQsY6xO/wb8AiRzJIN4WEQOKFfBCThkoBEBATBcUCl/B//+eAIDE3t4RAkwhHAYJXA6eIsIOlDQAdjB2PPpyyVyOk6LCqi76VI6C9AJOHSgGdjQHFoWdjl/UAWoXv8C/LI6BtAQnE3ESZw+NPcPdj3wsAkwdwDL23hUu3PYVAt4yEQJONDbuTjEwB6b/jnQuc3ETjigeckweADKm3g6eLAOOTB5zv8C/TCWUTBQVxl/B//+eAoBzv8K/Ol/B//+eA4CBVsgOkywDjDwSY7/Cv0BMFgD6X8H//54BAGu/wT8wClFGy7/DPy/ZQZlTWVEZZtlkmWpZaBlv2S2ZM1kxGTbZNCWGCgAAA","text_start":1082130432,"data":"FACEQHIKgEDCCoBAGguAQOgLgEBUDIBAAgyAQD4JgECkC4BA5AuAQC4LgEDuCIBAYguAQO4IgEBMCoBAkgqAQMIKgEAaC4BAXgqAQKIJgEDSCYBAWgqAQKwOgEDCCoBAbA2AQGQOgEAuCIBAjA6AQC4IgEAuCIBALgiAQC4IgEAuCIBALgiAQC4IgEAuCIBACA2AQC4IgECKDYBAZA6AQA==","data_start":1082469296,"bss_start":1082392576}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c61.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32c61.json ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1082132164,"text":"QREixCbCBsa39wBgEUc3RIBA2Mu39ABgEwQEANxAkYuR57JAIkSSREEBgoCIQBxAE3X1D4KX3bcBEbcHAGBOxoOphwBKyDdJgEAmylLEBs4izLcEAGB9WhMJCQDATBN09A8N4PJAYkQjqDQBQknSRLJJIkoFYYKAiECDJwkAE3X1D4KXfRTjGUT/yb8TBwAMlEGqh2MY5QCFR4XGI6AFAHlVgoAFR2OH5gAJRmONxgB9VYKAQgUTB7ANQYVjlecCiUecwfW3kwbADWMW1QCYwRMFAAyCgJMG0A19VWOV1wCYwRMFsA2CgLd1gUBBEZOFhboGxmE/Y0UFBrd3gUCThweyA6cHCAPWRwgTdfUPkwYWAMIGwYIjktcIMpcjAKcAA9dHCJFnk4cHBGMe9wI394BAEwcHsqFnupcDpgcItzaBQLd3gUCThweyk4YGtmMf5gAjpscII6DXCCOSBwghoPlX4wb1/LJAQQGCgCOm1wgjoOcI3bc3NwBgfEudi/X/NycAYHxLnYv1/4KAQREGxt03tzcAYCOmBwI3BwAImMOYQ33/yFeyQBNF9f8FiUEBgoBBEQbG2T993TcHAEC3NwBgmMM3NwBgHEP9/7JAQQGCgEERIsQ3xIBAkwdEAUrAA6kHAQbGJsJjCgkERTc5xb1HEwREAYFEY9YnAQREvYiTtBQAfTeFPxxENwaAABOXxwCZ4DcGAAG39v8AdY+3NgBg2MKQwphCff9BR5HgBUczCelAupcjKCQBHMSyQCJEkkQCSUEBgoABEQbOIswlNzcEzj9sABMFRP+XAID/54Cg86qHBUWV57JHk/cHID7GiTc3NwBgHEe3BkAAEwVE/9WPHMeyRZcAgP/ngCDxMzWgAPJAYkQFYYKAQRG3x4BABsaTh0cBBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgYzLI6oHAEE3GcETBVAMskBBAYKAAREizDfEgECTB0QBJsrER07GBs5KyKqJEwREAWPzlQCuhKnAAylEACaZE1nJABxIY1XwABxEY175ArU9fd1IQCaGzoWXAID/54Ag5BN19Q8BxZMHQAxcyFxAppdcwFxEhY9cxPJAYkTSREJJskkFYYKAaTVtv0ERBsaXAID/54CA1gNFhQGyQHUVEzUVAEEBgoBBEQbGxTcNxbdHgECThwcA1EOZzjdnCWATB4cOHEM3Bv3/fRbxjzcGAwDxjtWPHMOyQEEBgoBBEQbGbTcRwQ1FskBBARcDgP9nAIPMQREGxibCIsSqhJcAgP/ngKDJWTcNyTdHgECTBgcAg9eGABMEBwCFB8IHwYMjlPYAkwYADGOG1AATB+ADY3X3AG03IxQEALJAIkSSREEBgoBBEQbGEwcADGMa5QATBbANRTcTBcANskBBAVm/EwewDeMb5f5xNxMF0A31t0ERIsQmwgbGKoSzBLUAYxeUALJAIkSSREEBgoADRQQABQRNP+23NXEmy07H/XKFaf10Is1KyVLFVsMGz5OEhPoWkZOHCQemlxgIs4TnACqJJoUuhJcAgP/ngIAvk4cJBxgIBWq6l7OKR0Ex5AVnfXWTBYX6kwcHBxMFhfkUCKqXM4XXAJMHBweul7OF1wAqxpcAgP/ngEAsMkXBRZU3AUWFYhaR+kBqRNpESkm6SSpKmkoNYYKAooljc4oAhWlOhtaFSoWXAID/54DAxhN19Q8B7U6G1oUmhZcAgP/ngIAnTpkzBDRBUbcTBTAGVb8TBQAMSb0xcf1yBWdO11LVVtNezwbfIt0m20rZWtFizWbLaslux/13FpETBwcHPpccCLqXPsYjqgf4qokuirKKtov1M5MHAAIZwbcHAgA+hZcAgP/ngGAehWdj5VcTBWR9eRMJifqTBwQHypcYCDOJ5wBKhZcAgP/ngKAefXsTDDv5kwyL+RMHBAeTBwQHFAhil+aXgUQzDNcAs4zXAFJNY3xNCWPxpANBqJk/ooUIAY01uTcihgwBSoWXAID/54CAGqKZopRj9UQDs4ekQWPxdwMzBJpAY/OKAFaEIoYMAU6FlwCA/+eAALYTdfUPVd0CzAFEeV2NTaMJAQBihZcAgP/ngECkffkDRTEB5oWFNGNPBQDj4o3+hWeThwcHopcYCLqX2pcjiqf4BQTxt+MVpf2RR+MF9PYFZ311kwcHB5MFhfoTBYX5FAiqlzOF1wCTBwcHrpezhdcAKsaXAID/54CgEHE9MkXBRWUzUT3BMbcHAgAZ4ZMHAAI+hZcAgP/ngOALhWIWkfpQalTaVEpZulkqWppaClv6S2pM2kxKTbpNKWGCgLdXQUkZcZOH94QBRYbeotym2srYztbS1NbS2tDezuLM5srqyO7GPs6XAID/54DAnaE5DcE3ZwlgEweHDhxDt0aAQCOi9gC3Bv3//Rb1j8Fm1Y8cwxU5Bc23JwtgN0fYUJOGh8ETBxeqmMIThgfAIyAGACOgBgCThgfCmMKTh8fBmEM3BgQAUY+YwyOgBgC3R4BAN3eBQJOHBwATBwe7IaAjoAcAkQfj7ef+RTuRRWgIdTllM7f3gECThweyIWc+lyMg9wi3B4BAN0mAQJOHhw4jIPkAt3mBQEU+EwkJAJOJCbJjBgUQtwcBYBMHEAIjpOcKhUVFRZcAgP/ngOD2twWAQAFGk4UFAEVFlwCA/+eAIPi39wBgEUeYyzcFAgCXAID/54Bg97cXCWCIX4FFt8SAQHGJYRUTNRUAlwCA/+eAIJ/BZ/0XEwcAEIVmQWa3BQABAUWThEQBt0qAQA1qlwCA/+eA4JQTi0oBJpqDp8kI9d+Dq8kIhUcjpgkIIwLxAoPHGwAJRyMT4QKjAvECAtRNR2OB5whRR2OP5wYpR2Of5wCDxzsAA8crAKIH2Y8RR2OW5wCDp4sAnEM+1Hk5oUVIEG02g8c7AAPHKwCiB9mPEWdBB2N09wQTBbANET4TBcANOTYTBeAOITaFOUG3twWAQAFGk4WFAxVFlwCA/+eAIOk3BwBgXEcTBQACk+cXEFzHMbfJRyMT8QJNtwPHGwDRRmPn5gKFRmPm5gABTBME8A+FqHkXE3f3D8lG4+jm/rd2gUAKB5OGRrs2lxhDAoeTBgcDk/b2DxFG42nW/BMH9wITd/cPjUZj6+YIt3aBQAoHk4YGwDaXGEMChxMHQAJjmOcQAtQdRAFFnTQBRU086TbhNqFFSBB9FMk8dfQBTAFEE3X0D2k8E3X8D1E8dTbjHgTqg8cbAElHY2j3MAlH43b36vUXk/f3Dz1H42D36jd3gUCKBxMHB8G6l5xDgocFRJ3rcBCBRQFFl/B//+eAIHEd4dFFaBCVPAFEMagFRIHvl/B//+eA4HYzNKAAKaAhR2OF5wAFRAFMYbcDrIsAA6TLALNnjADSB/X37/CfhX3xwWwinP0cfX0zBYxAVdyzd5UBlePBbDMFjEBj5owC/XwzBYxAVdAxgZfwf//ngGBzVflmlPW3MYGX8H//54BgclXxapTRt0GBl/B//+eAoHFR+TMElEHBtyFH44nn8AFMEwQADDG3QUfNv0FHBUTjnOf2g6XLAAOliwDdMrG/QUcFROOS5/YDpwsBkWdj6uceg6VLAQOliwDv8N+ANb9BRwVE45Ln9IOnCwERZ2Nq9xwDp8sAg6VLAQOliwAzhOcC7/BP/iOsBAAjJIqwMbcDxwQAYwMHFAOniwDBFxMEAAxjE/cAwEgBR5MG8A5jRvcCg8dbAAPHSwABTKIH2Y8Dx2sAQgddj4PHewDiB9mP44H25hMEEAypvTOG6wADRoYBBQexjuG3g8cEAP3H3ERjnQcUwEgjgAQAfbVhR2OW5wKDp8sBA6eLAYOmSwEDpgsBg6XLAAOliwCX8H//54AgYiqMMzSgACm1AUwFRBG1EUcFROOa5+a3lwBgtF9ld30XBWb5jtGOA6WLALTftFeBRfmO0Y601/Rf+Y7RjvTf9FN1j1GP+NOX8H//54BAZSm9E/f3AOMVB+qT3EcAE4SLAAFMfV3jdJzbSESX8H//54DARxhEVEAQQPmOYwenARxCE0f3/32P2Y4UwgUMQQTZvxFHpbVBRwVE45fn3oOniwADp0sBIyj5ACMm6QB1u4MlyQDBF5Hlic8BTBMEYAyJuwMnCQFjZvcGE/c3AOMZB+IDKAkBAUYBRzMF6ECzhuUAY2n3AOMEBtIjKKkAIybZADG7M4brABBOEQeQwgVG6b8hRwVE45Hn2AMkCQEZwBMEgAwjKAkAIyYJADM0gAClswFMEwQgDO2xAUwTBIAMzbEBTBMEkAzpuRMHIA1jg+cMEwdADeOb57gDxDsAg8crACIEXYyX8H//54AgSAOsxABBFGNzhAEijOMJDLbAQGKUMYCcSGNV8ACcRGNb9Arv8I/Ldd3IQGKGk4WLAZfwf//ngCBEAcWTB0AM3MjcQOKX3MDcRLOHh0HcxJfwf//ngABDJbYJZRMFBXEDrMsAA6SLAJfwf//ngEAytwcAYNhLtwYAAcEWk1dHARIHdY+9i9mPs4eHAwFFs9WHApfwf//ngKAzEwWAPpfwf//ngOAu6byDpksBA6YLAYOlywADpYsA7/DP+9G0g8U7AIPHKwAThYsBogXdjcEV7/Bv1XW07/DPxD2/A8Q7AIPHKwATjIsBIgRdjNxEQRTN45FHhUtj/4cIkweQDNzIQbQDpw0AItAFSLOH7EA+1oMnirBjc/QADUhCxjrE7/BPwCJHMkg3xYBA4oV8EJOGSgEQEBMFxQKX8H//54BAMTf3gECTCEcBglcDp4iwg6UNAB2MHY8+nLJXI6TosKqLvpUjoL0Ak4dKAZ2NAcWhZ2OX9QBahe/wD8sjoG0BCcTcRJnD409w92PfCwCTB3AMvbeFS7d9gUC3zIBAk40Nu5OMTAHpv+OdC5zcROOKB5yTB4AMqbeDp4sA45MHnO/wD9MJZRMFBXGX8H//54BAHO/wj86X8H//54AAIVWyA6TLAOMPBJjv8I/QEwWAPpfwf//ngOAZ7/AvzAKUUbLv8K/L9lBmVNZURlm2WSZalloGW/ZLZkzWTEZNtk0JYYKA","text_start":1082130432,"data":"FECAQHQKgEDECoBAHAuAQOoLgEBWDIBABAyAQEAJgECmC4BA5guAQDALgEDwCIBAZAuAQPAIgEBOCoBAlAqAQMQKgEAcC4BAYAqAQKQJgEDUCYBAXAqAQK4OgEDECoBAbg2AQGYOgEAwCIBAjg6AQDAIgEAwCIBAMAiAQDAIgEAwCIBAMAiAQDAIgEAwCIBACg2AQDAIgECMDYBAZg6AQA==","data_start":1082223536,"bss_start":1082146816}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32h2.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32h2.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1082132164,"text":"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","text_start":1082130432,"data":"FACDQHIKgEDCCoBAGguAQOgLgEBUDIBAAgyAQD4JgECkC4BA5AuAQC4LgEDuCIBAYguAQO4IgEBMCoBAkgqAQMIKgEAaC4BAXgqAQKIJgEDSCYBAWgqAQKwOgEDCCoBAbA2AQGQOgEAuCIBAjA6AQC4IgEAuCIBALgiAQC4IgEAuCIBALgiAQC4IgEAuCIBACA2AQC4IgECKDYBAZA6AQA==","data_start":1082403760,"bss_start":1082327040}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32p4.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32p4.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1341195918,"text":"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","text_start":1341194240,"data":"EAD1TwYK8U9WCvFPrgrxT4QL8U/wC/FPngvxT9QI8U9AC/FPgAvxT8IK8U+ECPFP9grxT4QI8U/gCfFPJgrxT1YK8U+uCvFP8gnxTzgJ8U9oCfFP7gnxT0AO8U9WCvFPCA3xTwAO8U/EB/FPJA7xT8QH8U/EB/FPxAfxT8QH8U/EB/FPxAfxT8QH8U/EB/FPpAzxT8QH8U8mDfFPAA7xTw==","data_start":1341533100,"bss_start":1341456384}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s2.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s2.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1073907716,"text":"CAAAYBwAAGBIAP0/EAAAYDZBACH7/8AgADgCQfr/wCAAKAQgIJSc4kH4/0YEAAw4MIgBwCAAqAiIBKCgdOAIAAsiZgLohvT/IfH/wCAAOQId8AAA7Cv+P2Sr/T+EgAAAQEAAAKTr/T/wK/4/NkEAsfn/IKB0EBEgJQgBlhoGgfb/kqEBkJkRmpjAIAC4CZHz/6CgdJqIwCAAkhgAkJD0G8nAwPTAIADCWACam8AgAKJJAMAgAJIYAIHq/5CQ9ICA9IeZR4Hl/5KhAZCZEZqYwCAAyAmh5f+x4/+HnBfGAQB86Ica3sYIAMAgAIkKwCAAuQlGAgDAIAC5CsAgAIkJkdf/mogMCcAgAJJYAB3wAABUIEA/VDBAPzZBAJH9/8AgAIgJgIAkVkj/kfr/wCAAiAmAgCRWSP8d8AAAACwgQD8AIEA/AAAACDZBABARIKX8/yH6/wwIwCAAgmIAkfr/gfj/wCAAkmgAwCAAmAhWef/AIACIAnzygCIwICAEHfAAAAAAQDZBABARIOX7/xZq/4Hs/5H7/8AgAJJoAMAgAJgIVnn/HfAAAFiA/T////8ABCBAPzZBACH8/zhCFoMGEBEgZfj/FvoFDPgMBDeoDZgigJkQgqABkEiDQEB0EBEgJfr/EBEgJfP/iCIMG0CYEZCrAcwUgKsBse3/sJkQsez/wCAAkmsAkc7/wCAAomkAwCAAqAlWev8cCQwaQJqDkDPAmog5QokiHfAAAHDi+j8IIEA/hGIBQKRiAUA2YQAQESBl7f8x+f+9Aa0Dgfr/4AgATQoMEuzqiAGSogCQiBCJARARIOXx/5Hy/6CiAcAgAIgJoIggwCAAiQm4Aa0Dge7/4AgAoCSDHfAAAP8PAAA2QQCBxf8MGZJIADCcQZkokfv/ORgpODAwtJoiKjMwPEEMAilYOUgQESAl+P8tCowaIqDFHfAAAMxxAUA2QQBBtv9YNFAzYxZjBFgUWlNQXEFGAQAQESDl7P+IRKYYBIgkh6XvEBEgJeX/Fmr/qBTNA70CgfH/4AgAoKB0jEpSoMRSZAVYFDpVWRRYNDBVwFk0HfAA+Pz/P0QA/T9MAP0/ADIBQOwxAUAwMwFANmEAfMitAoeTLTH3/8YFAKgDDBwQsSCB9//gCACBK/+iAQCICOAIAKgDgfP/4AgA5hrcxgoAAABmAyYMA80BDCsyYQCB7v/gCACYAYHo/zeZDagIZhoIMeb/wCAAokMAmQgd8EAA/T8AAP0/jDEBQDZBACH8/4Hc/8gCqAix+v+B+//gCAAMCIkCHfBgLwFANkEAgf7/4AgAggoYDAmCyP4MEoApkx3w+Cv+P/Qr/j8YAEw/jABMP//z//82QQAQESDl/P8WWgSh+P+ICrzYgff/mAi8abH2/3zMwCAAiAuQkBTAiBCQiCDAIACJC4gKsfH/DDpgqhHAIACYC6CIEKHu/6CZEJCIIMAgAIkLHfAoKwFANkEAEBEgZff/vBqR0f+ICRuoqQmR0P8MCoqZIkkAgsjBDBmAqYOggHTMiqKvQKoiIJiTjPkQESAl8v/GAQCtAoHv/+AIAB3wNkEAoqDAEBEg5fr/HfAAADZBAIKgwK0Ch5IRoqDbEBEgZfn/oqDcRgQAAAAAgqDbh5IIEBEgJfj/oqDdEBEgpff/HfA2QQA6MsYCAKICACLCARARIKX7/zeS8B3wAAAAbFIAQIxyAUCMUgBADFMAQDYhIaLREIH6/+AIAEYLAAAADBRARBFAQ2PNBL0BrQKB9f/gCACgoHT8Ws0EELEgotEQgfH/4AgASiJAM8BWA/0iogsQIrAgoiCy0RCB7P/gCACtAhwLEBEgpff/LQOGAAAioGMd8AAAQCsBQDZBABARICXl/4y6gYj/iAiMSBARICXi/wwKgfj/4AgAHfAAAIQyAUC08QBAkDIBQMDxAEA2QQAQESDl4f+smjFc/4ziqAOB9//gCACiogDGBgAAAKKiAIH0/+AIAKgDgfP/4AgARgUAAAAsCoyCgfD/4AgAhgEAAIHs/+AIAB3w8CsBQDZBIWKhB8BmERpmWQYMBWLREK0FUmYaEBEgZfn/DBhAiBFHuAJGRACtBoG1/+AIAIYzAACSpB1Qc8DgmREamUB3Y4kJzQe9ASCiIIGu/+AIAJKkHeCZERqZoKB0iAmMigwIgmYWfQiGFQCSpB3gmREamYkJEBEgpeL/vQetARARICXm/xARIKXh/80HELEgYKYggZ3/4AgAkqQd4JkRGpmICXAigHBVgDe1tJKhB8CZERqZmAmAdcCXtwJG3f+G5/8MCIJGbKKkGxCqoIHM/+AIAFYK/7KiC6IGbBC7sBARICWiAPfqEvZHD7KiDRC7sHq7oksAG3eG8f9867eawWZHCIImGje4Aoe1nCKiCxAisGC2IK0CgX3/4AgAEBEgJdj/rQIcCxARIKXb/xARICXX/wwaEBEgpef/HfAAAP0/T0hBSfwr/j9sgAJASDwBQDyDAkAIAAhgEIACQAwAAGA4QEA///8AACiBQD+MgAAAEEAAAAAs/j8QLP4/fJBAP/+P//+AkEA/hJBAP3iQQD9QAP0/VAD9P1ws/j8UAABg8P//APwr/j9YAP0/cID9P1zyAECI2ABA0PEAQKTxAEDUMgFAWDIBQKDkAEAEcAFAAHUBQIBJAUDoNQFA7DsBQIAAAUCYIAFA7HABQGxxAUAMcQFAhCkBQHh2AUDgdwFAlHYBQAAwAEBoAAFANsEAIcz/DAopoYHm/+AIABARIGW7/xbqBDHz/kHy/sAgACgDUfL+KQTAIAAoBWHs/qKgZCkGYe7+YCIQYqQAYCIgwCAAKQWB2P/gCABIBHzCQCIQDCRAIiDAIAApA4YBAEkCSyLGAQAhsv8xs/8MBDcy7RARIOXB/wxLosEoEBEgZcX/IqEBEBEgpcD/QfH9kCIRKiTAIABJAjGo/yHZ/TJiABARICWy/xY6BiGd/sGd/qgCDCuBn/7gCAAMnDwLDAqBuv/gCACxnv8MDAyagbj/4AgAoqIAgTL/4AgAsZn/qAJSoAGBs//gCACoAoEp/+AIAKgCgbD/4AgAMZP/wCAAKANQIiDAIAApAwYKAACxj//NCgxagab/4AgAMYz/UqEBwCAAKAMsClAiIMAgACkDgRv/4AgAgaH/4AgAIYX/wCAAKALMuhzDMCIQIsL4DBMgo4MMC4Ga/+AIAPF+/wwdDByyoAHioQBA3REAzBGAuwGioACBk//gCAAhef9RCf4qRGLVK8YWAAAAAMAgADIHADAwdBbzBKKiAMAgACJHAIH9/uAIAKKiccCqEYF+/+AIAIGF/+AIAHFo/3zowCAAOAeir/+AMxAQqgHAIAA5B4F+/+AIAIF+/+AIAK0CgX3/4AgAcVD+wCAAKAQWsvkMB8AgADgEDBLAIAB5BCJBHCIDAQwoeYEiQR2CUQ8cN3cSIxxHdxIkZpImIgMDcgMCgCIRcCIgZkIXKCPAIAAoAimBxgIAABwihgAAAAzCIlEPEBEg5aT/sqAIosEcEBEgZaj/cgMDIgMCgHcRIHcgIUD/ICD0d7IaoqDAEBEgJaP/oqDuEBEgpaL/EBEgZaH/Btj/IgMBHEgnODf2IhsG9wAiwi8gIHS2QgJGJgCBMv+AIqAoAqACAAAAIsL+ICB0HCgnuAJG7QCBLP+AIqAoAqACAILCMICAdLZYxIbnACxJDAgioMCXFwKG5QCJgQxyfQitBxARIKWb/60HEBEgJZv/EBEg5Zn/EBEgZZn/DIuiwRwLIhARIOWc/1Yy/YYvAAwSVhc1wsEQvQetB4Eu/+AIAFYaNLKgDKLBEBARIGWa/wauAAAADBJWtzKBJ//gCAAGKwAmhwYMEobGAAAAeCMoMyCHIICAtFa4/hARIGVt/yp3nBqG9/8AoKxBgRz/4AgAVhr9ItLwIKfAzCIGmwAAoID0Vhj+hgQAoKD1icGBFP/gCACIwVbK+oAiwAwYAIgRIKfAJzjhhgMAoKxBgQv/4AgAVvr4ItLwIKfAVqL+RooAAAwIIqDAJocChqgADAgtCMamACa39YZ8AAwSJrcChqAAuDOoI3KgABARICWR/6Ang8abAAwZZrddeEMgqREMCCKgwne6AkaZALhTqCOSYQ4QESAlZ/+Y4QwCoJKDhg0ADBlmtzF4QyCpEQwIIqDCd7oCRo4AKDO4U6gjIHeCmeEQESAlZP8hVv0MCJjhiWIi0it5IqCYgy0JxoEAkVD9DAiiCQAioMaHmgJGgACII3LH8CKgwHeYAShZDAiSoO9GAgCKo6IKGBuIoJkwdyjycgMFggMEgHcRgHcgggMGAIgRcIggcgMHgHcBgHcgcJnAcqDBDAiQJ5PGbABxOP0ioMaSBwCNCRZZGpg3DAgioMiHGQIGZgAoV5JHAEZhAByJDAgMEpcXAgZhAPhz6GPYU8hDuDOoIwwHgbH+4AgAjQqgJ4MGWgAMEiZHAkZVAJGX/oGX/sAgAHgJQCIRgHcQIHcgqCPAIAB5CZGS/gwLwCAAeAmAdxAgdyDAIAB5CZGO/sAgAHgJgHcQIHcgwCAAeQmRiv7AIAB4CYB3ECAnIMAgACkJgZX+4AgABh8AcKA0DAgioMCHGgLGPABwtEGLk30KfPwGDgAAqDmZ4bnBydGBhP7gCACY4bjBKCmIGagJyNGAghAmAg3AIADYCiAsMNAiECCIIMAgAIkKG3eSyRC3N8RGgf9mRwLGf/8MCCKgwIYmAAwSJrcCxiEAIWj+iFN4I4kCIWf+eQIMAgYdALFj/gwI2AsMGnLH8J0ILQjQKoNwmpMgmRAioMaHmWDBXf6NCegMIqDJdz5TcPAUIqDAVq8ELQmGAgAAKpOYaUsimQidCiD+wCqNdzLtFsnY+QyJC0Zh/wAMEmaHFyFN/ogCjBiCoMgMB3kCIUn+eQIMEoAngwwIRgEAAAwIIqD/IKB0gmEMEBEgZWL/iMGAoHQQESClYf8QESBlYP9WArUiAwEcJyc3HvYyAobQ/iLC/SAgdAz3J7cCBs3+cTb+cCKgKAKgAgByoNJ3El9yoNR3kgIGIQDGxf4AAHgzOCMQESAlT/+NClZqsKKiccCqEYnBgTD+4AgAISj+kSn+wCAAKAKIwSC0NcAiEZAiECC7IHC7gq0IMLvCgTb+4AgAoqPogST+4AgARrH+AADYU8hDuDOoIxARIGVs/4as/rIDAyIDAoC7ESC7ILLL8KLDGBARIOU3/8al/gAAIgMDcgMCgCIRcCIggST+4AgAcZD8IsLwiDeAImMWUqeIF4qCgIxBhgIAicEQESAlI/+CIQySJwSmGQSYJ5eo6RARICUb/xZq/6gXzQKywxiBFP7gCACMOjKgxDlXOBcqMzkXODcgI8ApN4EO/uAIAIaI/gAAIgMDggMCcsMYgCIRODWAIiAiwvBWwwn2UgKGJQAioMlGKgAx7P2BbvzoAymR4IjAiUGIJq0Jh7IBDDqZ4anR6cEQESBlGv+o0YHj/ejBqQGh4v3dCL0HwsEk8sEQicGB9f3gCAC4Js0KqJGY4aC7wLkmoCLAuAOqd6hBiMGquwwKuQPAqYOAu8Cg0HTMmuLbgK0N4KmDFuoBrQiJwZnhydEQESDlJf+IwZjhyNGJA0YBAAAADBydDIyyODWMc8A/McAzwJaz9daMACKgxylVhlP+AFaslCg1FlKUIqDIxvr/KCNWopMQESAlTP+ionHAqhGBvP3gCAAQESAlM/+Bzv3gCABGRv4AKDMWMpEQESClSf+io+iBs/3gCAAQESDlMP/gAgAGPv4AEBEgJTD/HfAAADZBAJ0CgqDAKAOHmQ/MMgwShgcADAIpA3zihg8AJhIHJiIYhgMAAACCoNuAKSOHmSoMIikDfPJGCAAAACKg3CeZCgwSKQMtCAYEAAAAgqDdfPKHmQYMEikDIqDbHfAAAA==","text_start":1073905664,"data":"WAD9P0uLAkDdiwJA8pACQGaMAkD+iwJAZowCQMWMAkDejQJAUY4CQPmNAkDVigJAd40CQNCNAkDojAJAdI4CQBCNAkB0jgJAy4sCQCqMAkBmjAJAxYwCQOOLAkAXiwJAN48CQKqQAkDqiQJA0ZACQOqJAkDqiQJA6okCQOqJAkDqiQJA6okCQOqJAkDqiQJA1I4CQOqJAkDJjwJAqpACQA==","data_start":1073622012,"bss_start":1073545216}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s3.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_32s3.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1077381760,"text":"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","text_start":1077379072,"data":"XADKP16ON0AzjzdAR5Q3QL2PN0BTjzdAvY83QB2QN0A6kTdArJE3QFWRN0DpjTdA0JA3QCyRN0BAkDdA0JE3QGiQN0DQkTdAIY83QH6PN0C9jzdAHZA3QDmPN0AqjjdAkJI3QA2UN0AAjTdALZQ3QACNN0AAjTdAAI03QACNN0AAjTdAAI03QACNN0AAjTdAKpI3QACNN0AlkzdADZQ3QAQInwAAAAAAAAAYAQQIBQAAAAAAAAAIAQQIBgAAAAAAAAAAAQQIIQAAAAAAIAAAEQQI3AAAAAAAIAAAEQQIDAAAAAAAIAAAAQQIEgAAAAAAIAAAESAoDAAQAQAA","data_start":1070279676,"bss_start":1070202880}');

/***/ }),

/***/ "(ssr)/./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_8266.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/esptool-js/lib/targets/stub_flasher/stub_flasher_8266.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"entry":1074843652,"text":"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","text_start":1074843648,"data":"CIH+PwUFBAACAwcAAwMLANTXEEAL2BBAOdgQQNbYEECF5xBAOtkQQJDZEEDc2RBAhecQQKLaEEAf2xBA4NsQQIXnEECF5xBAeNwQQIXnEEBV3xBAHOAQQFfgEECF5xBAhecQQPPgEECF5xBA2+EQQIHiEEDA4xBAf+QQQFDlEECF5xBAhecQQIXnEECF5xBAfuYQQIXnEEB05xBAsN0QQKnYEEDC5RBAydoQQBvaEECF5xBACOcQQE/nEECF5xBAhecQQIXnEECF5xBAhecQQIXnEECF5xBAhecQQELaEEB/2hBA2uUQQAEAAAACAAAAAwAAAAQAAAAFAAAABwAAAAkAAAANAAAAEQAAABkAAAAhAAAAMQAAAEEAAABhAAAAgQAAAMEAAAABAQAAgQEAAAECAAABAwAAAQQAAAEGAAABCAAAAQwAAAEQAAABGAAAASAAAAEwAAABQAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABgAAAAcAAAAHAAAACAAAAAgAAAAJAAAACQAAAAoAAAAKAAAACwAAAAsAAAAMAAAADAAAAA0AAAANAAAAAAAAAAAAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAANAAAADwAAABEAAAATAAAAFwAAABsAAAAfAAAAIwAAACsAAAAzAAAAOwAAAEMAAABTAAAAYwAAAHMAAACDAAAAowAAAMMAAADjAAAAAgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQAAAAAAAAAAAAAAAAAAABAREgAIBwkGCgULBAwDDQIOAQ8AAQEAAAEAAAAEAAAA","data_start":1073720488,"bss_start":1073643776}');

/***/ })

};
;